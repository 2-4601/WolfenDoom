/* 
  New Conversation Dialog Format by AFADoomer

  Draws a standard graphic as the background for all conversations (CONVBACK)
  Draws the USDF/ZSDF 'panel' background image scaled to ~32x32 as a speaker icon
  Replaces the mouse click coordinate translation algorithm (screen space to 320x200) to be more accurate (original algorithm in GZDoom doesn't take widescreen resolutions into account)
  Implements scaling text for name, speaker text, and responses
  Implements scrolling of long speaker text

*/

class BoAConversationMenu : ConversationMenu
{
	double namescale, textscale, replytextscale;
	int BulletWidth, leftside, topside;
	int scrollTop, scrollBottom, scrollPosition, scrollMax;
	bool initial;

	//=============================================================================
	//
	// Returns the y position of the replies to position the terminal response.
	//
	//=============================================================================

	override int Init(StrifeDialogueNode CurNode, PlayerInfo player, int activereply)
	{
		mCurNode = CurNode;
		mPlayer = player;
		mShowGold = false;
		ConversationPauseTic = gametic + 20;
		DontDim = true;

		leftside = 74;
		topside = 16;

		namescale = 0.85;
		textscale = 0.75;
		replytextscale = 0.7;

		ReplyWidth = 320 - leftside - 30;
		SpeechWidth = int(ReplyWidth / textscale);
		BulletWidth = 16;

		FormatReplies(activereply); //Format replies first to determine where the bottom of the message scroll box will be
		FormatSpeakerMessage();

		return 100; //Is returned as the Y location (320x200) where success/failure messages appear
	}

	//=============================================================================
	//
	// Sets up array of lines for reply values with given width
	//
	//=============================================================================
	
	override int FormatReplies(int activereply)
	{
		mSelection = -1;

		StrifeDialogueReply reply;
		int r = -1;
		int i = 1,j;
		for (reply = mCurNode.Children; reply != NULL; reply = reply.Next)
		{
			r++;
			if (reply.ShouldSkipReply(mPlayer))
			{
				continue;
			}
			if (activereply == r) mSelection = i - 1;

			mShowGold |= reply.NeedsGold;

			let ReplyText = Stringtable.Localize(reply.Reply);
			if (reply.NeedsGold) ReplyText.AppendFormat(" for %u", reply.PrintAmount);

			let ReplyLines = SmallFont.BreakLines (ReplyText, int((ReplyWidth - BulletWidth) / replytextscale));

			mResponses.Push(mResponseLines.Size());
			for (j = 0; j < ReplyLines.Count(); ++j)
			{
				mResponseLines.Push(ReplyLines.StringAt(j));
			}
			
			++i;
			ReplyLines.Destroy();
		}
		if (mSelection == -1)
		{
			mSelection = r < activereply ? r + 1 : 0;
		}
		let goodbyestr = mCurNode.Goodbye;
		if (goodbyestr.Length() == 0)
		{
			goodbyestr = String.Format("$TXT_RANDOMGOODBYE_%d", Random[RandomSpeech](1, NUM_RANDOM_GOODBYES));
		}
		else if (goodbyestr.Left(7) == "RANDOM_")
		{
			goodbyestr = String.Format("$TXT_%s_%02d", goodbyestr, Random[RandomSpeech](1, NUM_RANDOM_LINES));
		}
		goodbyestr = Stringtable.Localize(goodbyestr);
		if (goodbyestr.Length() == 0 || goodbyestr.CharAt(0) == "$") goodbyestr = "Bye.";
		mResponses.Push(mResponseLines.Size());
		mResponseLines.Push(goodbyestr);

		int fontheight = int(OptionMenuSettings.mLinespacing * replytextscale  * 1.5);
		int h = mResponseLines.Size() * fontheight + 4;

		mYpos = 225 - h;

		return true;
	}

	//=============================================================================
	//
	// Format line breaks for speaker message
	//
	//=============================================================================

	override void FormatSpeakerMessage()
	{
		// Format the speaker's message.
		String toSay = mCurNode.Dialogue;
		if (toSay.Left(7) == "RANDOM_")
		{
			let dlgtext = String.Format("$TXT_%s_%02d", toSay, random[RandomSpeech](1, NUM_RANDOM_LINES));
			toSay = Stringtable.Localize(dlgtext);
			if (toSay.CharAt(0) == "$") toSay = Stringtable.Localize("$TXT_GOAWAY");
		}
		else
		{
			// handle string table replacement
			toSay = Stringtable.Localize(toSay);
		}
		if (toSay.Length() == 0)
		{
			toSay = ".";
		}
		mDialogueLines = SmallFont.BreakLines(toSay, SpeechWidth);
	}

	//=============================================================================
	//
	// Handle key presses
	//
	//=============================================================================

	override bool MenuEvent(int mkey, bool fromcontroller)
	{
		if (demoplayback)
		{ // During demo playback, don't let the user do anything besides close this menu.
			if (mkey == MKEY_Back)
			{
				Close();
				return true;
			}
			return false;
		}

		if (mkey == MKEY_Up)
		{
			if (scrollMax > 0)
			{
				if (mSelection == -1)
				{
					if (scrollPosition > 0)
					{
						scrollPosition--;
						mSelection = -1;
					}
					else
					{
						scrollPosition = 0;
						mSelection = mResponses.Size() - 1;
					}
				}
				else
				{
					if (--mSelection < 0)
					{
						mSelection = -1;
						scrollPosition = scrollMax;
					}
				}
			}
			else
			{
				if (--mSelection < 0) mSelection = mResponses.Size() - 1;
			}
			return true;
		}
		else if (mkey == MKEY_Down)
		{
			if (scrollMax > 0)
			{
				if (mSelection == -1)
				{
					if (scrollPosition < scrollMax)
					{
						scrollPosition++;
						mSelection = -1;
					}
					else
					{
						scrollPosition = scrollMax;
						mSelection = 0;
					}
				}
				else
				{
					if (++mSelection >= mResponses.Size())
					{
						mSelection = -1;
						scrollPosition = 0;
					}
				}
			}
			else
			{
				if (++mSelection >= mResponses.Size()) mSelection = 0;
			}
			return true;
		}
		else if (mkey == MKEY_Back)
		{
			SendConversationReply(-1, GetReplyNum());
			Close();
			return true;
		}
		else if (mkey == MKEY_Enter)
		{
			int replynum = GetReplyNum();
			if (mSelection >= mResponses.Size())
			{
				SendConversationReply(-2, replynum);
			}
			else
			{
				// Send dialogue and reply numbers across the wire.
				SendConversationReply(mCurNode.ThisNodeNum, replynum);
			}
			Close();
			return true;
		}
		return false;
	}

	//=============================================================================
	//
	// Handle mouse clicks
	//
	//=============================================================================

	override bool MouseEvent(int type, int x, int y)
	{
		int sel = -1;
		int fontheight;

		// Custom equivalent to Clean(X/Y)Fac that more closely matches scaling of other screen elements (fixes a bug at odd screen sizes in the standard mouse handling)
		double widthRatio = screen.GetWidth() / 320.;
		double heightRatio = screen.GetHeight() / 240.;
		double screenRatio = widthRatio / heightRatio;

		if (screenRatio > 1.275) { widthRatio = 4 + (widthRatio - 4) / 2; } 

		double xOffset = (screen.GetWidth() - 320 * heightRatio) / 2;
		double yOffset = (screen.GetHeight() - 240 * widthRatio) / 2;

		if (xOffset < 0) { xOffset = 0; heightRatio = widthRatio; }
		else if (yOffset < 0) { yOffset = 0; widthRatio = heightRatio; }

		x = int((x - xOffset) / widthRatio);
		y = int((y - yOffset) / heightRatio);

		fontheight = int(OptionMenuSettings.mLinespacing * replytextscale  * 1.5);
		if (x >= leftside && x <= leftside + ReplyWidth && y >= mYpos && y <= mYpos + fontheight * mResponseLines.Size() + 4)
		{
			sel = (y - 4 - mYpos) / fontheight;
			for(int i = 0; i < mResponses.Size(); i++)
			{
				if (mResponses[i] > sel)
				{
					sel = i-1;
					break;
				}
			}
		}
		mSelection = sel;
		if (type == MOUSE_Release)
		{
			if (x > leftside && x < leftside + ReplyWidth && y > scrollTop && y < scrollBottom)
			{
				mSelection = -1;
				return false;
			}

			if (scrollMax > 0)
			{
				//Scrollbar arrows...  Check for click within a 1-character radius of the actual arrow
				fontheight = int(OptionMenuSettings.mLinespacing * textscale  * 1);
				if (x >= (leftside + ReplyWidth - 8) && x < leftside + ReplyWidth + 16)
				{
					if (y > scrollTop - 8 && y < scrollTop + fontheight + 8)
					{
						mSelection = -1; 
						return MenuEvent(MKEY_Up, true);
					}
					else if (y > scrollBottom - fontheight - 8 && y < scrollBottom + 8)
					{
						mSelection = -1; 
						return MenuEvent(MKEY_Down, true);
					}
				}
			}
			return MenuEvent(MKEY_Enter, true);
		}
		return true;
	}

	//============================================================================
	//
	// DrawConversationMenu
	//
	//============================================================================

	override void Drawer()
	{
		if (mCurNode == NULL)
		{
			Close ();
			return;
		}

		DrawBackdrop();
		DrawBackdropIcon();
		DrawReplies();
		DrawSpeakerText(false); //Requires the former dimbg boolean as a parameter, but unused here.
		DrawGold();
	}

	//============================================================================
	//
	// Draw the backdrop, returns true if the text background should be dimmed
	//
	//============================================================================

	override bool DrawBackdrop()
	{
		let tex = TexMan.CheckForTexture ("CONVBACK", TexMan.Type_MiscPatch);
		if (tex.isValid())
		{
			screen.DrawTexture(tex, false, 0, 0, DTA_DestWidth, 320, DTA_DestHeight, 240, DTA_VirtualWidth, 320, DTA_VirtualHeight, 240, DTA_KeepRatio, true);
			return false;
		}
		return true;
	}

	//============================================================================
	//
	// Draw the ZSDF-defined backdrop, fit to a square for use as a speaker icon
	//
	//============================================================================

	void DrawBackdropIcon()
	{
		let tex = TexMan.CheckForTexture (mCurNode.Backdrop, TexMan.Type_MiscPatch);
		if (tex.isValid())
		{
			int w = 38;
			int h = 38;
			int posx = leftside - 10 - w;
			int posy = topside;

			DimArea(posx, posy, w + 1, h + 3);

			screen.DrawTexture(tex, false, posx + 1, posy + 3, DTA_VirtualWidth, 320, DTA_VirtualHeight, 240, DTA_DestWidth, 38, DTA_DestHeight, 38);
		}
	}

	//============================================================================
	//
	// Draw the speaker text
	//
	//============================================================================

	override void DrawSpeakerText(bool dimbg)
	{
		String speakerName;
		int fontsize = int(OptionMenuSettings.mLinespacing * textscale);
		int linesize = int(OptionMenuSettings.mLinespacing * 2.15 * textscale);
		int cnt = mDialogueLines.Count();
		int x, y;

		// Who is talking to you?
		if (mCurNode.SpeakerName.Length() > 0)
		{
			speakerName = Stringtable.Localize(mCurNode.SpeakerName);
		}
		else
		{
			speakerName = players[consoleplayer].ConversationNPC.GetTag("Person");
		}

		x = int(leftside / namescale);
		y = int(topside / namescale);

		if (speakerName.Length() > 0)
		{
			screen.DrawText(SmallFont, Font.CR_WHITE, x, y, speakerName, DTA_VirtualWidth, int(320 / namescale), DTA_VirtualHeight, int(240 / namescale));
		}

		x = int(leftside / textscale);
		y = int(topside / textscale + linesize);

		scrollTop = int(y * textscale);

		int color1 = Font.CR_GREY;
		int color2 = Font.CR_GREY;

		//Slightly dim background for speaker text area
		if (mSelection < 0)
		{
			DimArea(leftside, scrollTop, ReplyWidth, scrollBottom - scrollTop, 0.1);
		}

		for (int i = scrollPosition; i < cnt; i++)
		{
			screen.DrawText(SmallFont, Font.CR_GREEN, x, y, mDialogueLines.StringAt(i), DTA_VirtualWidth, int(320 / textscale), DTA_VirtualHeight, int(240 / textscale));
			y += linesize;

			if (scrollPosition == 0)
			{
				if (y + fontsize > scrollBottom / textscale)
				{
					scrollMax = cnt - i - 1;
					if (!initial)  //Default selection to text if it needs to scroll
					{
						initial = true;
						if (scrollMax > 0) { mSelection = -1; }
					}
					color2 = Font.CR_RED;
				}
				else { scrollMax = 0; }
			}
			else if (scrollPosition < scrollMax)
			{
				color1 = Font.CR_RED;
				color2 = Font.CR_RED;
			}
			else if (scrollPosition == scrollMax)
			{
				color1 = Font.CR_RED;
			}

			if (y + fontsize > scrollBottom / textscale) { break; }
		}

		if (scrollMax > 0)
		{
			int arrowx = int((leftside + ReplyWidth) / textscale);
			int arrowy = int(scrollTop / textscale);
			int arrow2y = int((scrollBottom) / textscale) - 4;

			screen.DrawText(ConFont, color1, arrowx, arrowy, "\x1a", DTA_VirtualWidth, int(320 / textscale), DTA_VirtualHeight, int(240 / textscale));
			screen.DrawText(ConFont, color2, arrowx, arrow2y, "\x1b", DTA_VirtualWidth, int(320 / textscale), DTA_VirtualHeight, int(240 / textscale));
		}
	}

	//============================================================================
	//
	// Draw the replies
	//
	//============================================================================

	override void DrawReplies()
	{
		int fontheight = int(OptionMenuSettings.mLinespacing * replytextscale  * 1.5);

		int posx = leftside;
		int h = mResponseLines.Size() * fontheight + 4;
		int posy = 225 - h;
		int w = ReplyWidth;

		scrollBottom = posy - 8;

		DimArea(posx, posy, w, h);

		int response = 0;
		for (int i = 0; i < mResponseLines.Size(); i++)
		{
			int x = int((posx + 4 + BulletWidth) / replytextscale);
			int y = int((posy + 4 + (i * fontheight)) / replytextscale);

			screen.DrawText(SmallFont, Font.CR_GREEN, x, y, mResponseLines[i], DTA_VirtualWidth, int(320 / replytextscale), DTA_VirtualHeight, int(240 / replytextscale));

			if (i == mResponses[response])
			{
				String tbuf;

				response++;
				tbuf = String.Format("%d.", response);
				x = int((posx + 4) / replytextscale);
				screen.DrawText(SmallFont, Font.CR_GREY, x, y, tbuf, DTA_VirtualWidth, int(320 / replytextscale), DTA_VirtualHeight, int(240 / replytextscale));

				if (response == mSelection + 1)
				{
					int colr = ((MenuTime() % 8) < 4) || GetCurrentMenu() != self ? Font.CR_RED : Font.CR_GREY;

					x = int((posx + 4 + BulletWidth) / replytextscale - 6);
					y = y + (fontheight / 2) - 4;

					screen.DrawText(ConFont, colr, x, y, "\xd", DTA_VirtualWidth, int(320 / replytextscale), DTA_VirtualHeight, int(240 / replytextscale));
				}
			}
		}
	}

	void DimArea(int x = 0, int y = 0, int w = 320, int h = 200, double alpha = 0.45)
	{
		double widthRatio = screen.GetWidth() / 320.;
		double heightRatio = screen.GetHeight() / 240.;
		double screenRatio = widthRatio / heightRatio;

		//Adjust because the text block starts to stretch at this point 
		// (needs work - not particularly accurate, but works for all of the resolutions on my machine)
		if (screenRatio > 1.275) { widthRatio = 4 + (widthRatio - 4) / 2; } 

		double xOffset = (screen.GetWidth() - 320 * heightRatio) / 2;
		double yOffset = (screen.GetHeight() - 240 * widthRatio) / 2;

		if (xOffset < 0) { xOffset = 0; heightRatio = widthRatio; }
		else if (yOffset < 0) { yOffset = 0; widthRatio = heightRatio; }

		x = int(xOffset + x * widthRatio);
		w = int(w * widthRatio);
		y = int(yOffset + y * heightRatio);
		h = int(h * heightRatio);

		screen.Dim(0, alpha, x, y, w, h);
	}
}