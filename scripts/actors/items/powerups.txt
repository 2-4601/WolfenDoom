class PowerupToggler : PowerupGiver
{
	Inventory powerinv;

	override void Tick()
	{
		if (globalfreeze || level.Frozen) { return; }
		if (owner)
		{
			if (powerinv && powerinv is "Powerup")
			{
				EffectTics = Powerup(powerinv).EffectTics;
			}
		}
		if (EffectTics == 1)
		{
			Destroy();
		}
	}

	override void PostBeginPlay()
	{
		// Ensure item gets removed properly
		EffectTics += 1;
	}

	override bool Use(bool pickup)
	{
		if (powerinv)
		{
			powerinv.Destroy();
		}
		else
		{
			Super.Use(pickup);
			Class<Inventory> PowerType = PowerupType.GetClassName();
			if (PowerType)
			{
				powerinv = Owner.FindInventory(PowerType);
			}
		}
		return false;
	}

	override bool TryPickup(in out Actor toucher)
	{
		// Picking up another of the same item
		PowerupGiver existing = PowerupGiver(toucher.FindInventory(GetClass()));
		if (existing)
		{
			Class<Inventory> PowerType = PowerupType.GetClassName();
			if (PowerType)
			{
				Powerup curPower = Powerup(toucher.FindInventory(PowerType, true));
				// If powerup is active, modify powerup EffectTics
				if (curPower)
				{
					if (curPower.EffectTics < Default.EffectTics)
					{
						if (bAdditiveTime)
						{
							curPower.EffectTics += Default.EffectTics;
						}
						else
						{
							curPower.EffectTics = Default.EffectTics;
						}
						GoAwayAndDie();
						return true;
					}
				}
				else
				{
					// Powerup is not active, modify toggler EffectTics
					if (existing.EffectTics < Default.EffectTics)
					{
						if (bAdditiveTime)
						{
							existing.EffectTics += Default.EffectTics;
						}
						else
						{
							existing.EffectTics = Default.EffectTics;
						}
						GoAwayAndDie();
						return true;
					}
				}
			}
		}
		return Super.TryPickup(toucher);
	}
}

class ZyklonMask : PowerupToggler
{
	Default
	{
		//$Category Powerups (BoA)
		//$Title Zyklon Mask (any poison protection)
		//$Color 6
		Scale 0.35;
		Tag "$TAGZMASK";
		Inventory.Icon "ZASKB0";
		Inventory.PickupMessage "$ZMASK";
		Inventory.MaxAmount 1;
		Powerup.Duration -60;
		Powerup.Type "PowerZyklonMask";
		+INVENTORY.INVBAR
		+INVENTORY.UNDROPPABLE
	}

	States
	{
	Spawn:
		ZASK A -1;
		Stop;
	}

	override void Tick()
	{
		if (globalfreeze || level.Frozen) { return; }
		// Zyklon mask cannot be used underwater
		if (powerinv && owner.waterlevel >= 3)
		{
			A_PlaySound("flamer/steam", CHAN_AUTO, Random(15, 45));
			powerinv.Destroy();
		}
		Super.Tick();
	}
}

class PowerZyklonMask : PowerProtection
{
	Default
	{
		DamageFactor "UndeadPoisonAmbience", 0;
	}

	override void Tick()
	{
		if (Owner == null || EffectTics == 0)
		{
			Destroy();
		}
	}
}

class LanternPickup : CustomInventory
{
	bool active;

	Default
	{
		//$Category Powerups (BoA)
		//$Title Useable Lantern (requires Oil)
		//$Color 6
		Scale 0.5;
		Tag "$TAGLANTR";
		Inventory.Icon "LANTB0";
		Inventory.PickupMessage "$LANTERN";
		Inventory.MaxAmount 1;
		Inventory.PickupSound "misc/gadget_pickup";
		+INVENTORY.INVBAR
		+INVENTORY.UNDROPPABLE
	}

	States
	{
		Spawn:
			LANT A -1;
			Stop;
		Pickup:
			"####" A 0 A_GiveInventory("LanternOil", 1000);
			Stop;
		Use:
			"####" A 0 {
				invoker.active = !invoker.active;

				if (invoker.active && !FindInventory("LanternOil")) { invoker.active = false; }
			}
			Fail;
	}

	override void Tick()
	{
		if (globalfreeze || level.Frozen) { return; }

		if (owner && active)
		{
			if (owner.waterlevel >= 3)
			{
				A_PlaySound("flamer/steam", CHAN_AUTO, Random(15, 45));
				active = false;
			}
			else if (owner.FindInventory("LanternOil")) { owner.TakeInventory("LanternOil", 1); }
			else { active = false; }
		}
	}
}

class MineSweeper : CustomInventory
{
	bool active;

	Default
	{
		//$Category Powerups (BoA)
		//$Title Human Mine Scanning (pickups)
		//$Color 6
		Scale 0.5;
		Tag "$TAGSWEEP";
		Inventory.Icon "MSPUB0";
		Inventory.PickupMessage "$SWEEPER";
		Inventory.MaxAmount 1;
		+INVENTORY.INVBAR
		+INVENTORY.UNDROPPABLE
	}

	States
	{
		Spawn:
			MSPU A -1;
			Stop;
		Pickup:
			"####" A 0 {
				if (CountInv("MineSweeper") == 0) {
					A_GiveInventory ("Power", 2400);
					return true;
				} else if (CountInv("MineSweeper") > 0 && CountInv("Power") < 2400) {
					A_GiveInventory ("Power", 2400 - CountInv("Power"));
					A_TakeInventory ("MineSweeper", 1); // The player will immediately get another minesweeper.
					return true;
				} else {
					return false;
				}
			}
			Stop;
		Use:
			"####" A 0 {
				invoker.active = !invoker.active;

				if (invoker.active && !FindInventory("Power")) { invoker.active = false; }
			}
			Fail;
	}

	override void Tick()
	{
		if (globalfreeze || level.Frozen || !owner || !owner.player) { return; }

		if (owner && active)
		{
			if (owner.FindInventory("Power")) { owner.TakeInventory("Power", 1); }
			else { active = false; }
		}
	}
}

class BoACompass : CustomInventory
{
	bool active;

	Default
	{
		//$Category Pickups (BoA)
		//$Title Compass
		//$Color 13
		Scale 0.2;
		Tag "$TAGCOMPS";
		Inventory.Icon "CMPSB0";
		Inventory.PickupMessage "$COMPASS";
		Inventory.PickupSound "misc/armor_head";
		Inventory.MaxAmount 1;
		+INVENTORY.INVBAR
	}

	States
	{
		Spawn:
			CMPS A -1;
			Stop;
		Use:
			TNT1 A 0 {
				invoker.active = !invoker.active;
			}
			Fail;
	}

	override Inventory CreateTossable(int amt)
	{
		active = false;
		return Super.CreateTossable(amt);
	}

	static void Add(Actor thing, String iconName = "", bool usesprite = false, int actorTID = 0)
	{
		if (!thing || actorTID)
		{
			if (actorTID)
			{
				let it = ActorIterator.Create(actorTID, "Actor");
				Actor mo;

				while (mo = Actor(it.Next()))
				{
					Add(mo, iconName, usesprite); // Add each thing that has a matching TID
				}
			}

			return; // If no thing was passed, silently fail here
		} 

		CompassHandler compassEvent = CompassHandler(EventHandler.Find("CompassHandler"));
		if (!compassEvent) { return; } // If no CompassHandler was found (somehow), silently fail

		if (iconName == "") { iconName = CompassHandler.GetDefaultIcon(thing, usesprite); }

		compassEvent.Add(thing, iconName);
	}

	static void Remove(Actor thing)
	{
		if (!thing) { return; } // If no thing was passed, silently fail

		CompassHandler compassEvent = CompassHandler(EventHandler.Find("CompassHandler"));
		if (!compassEvent) { return; }

		int i = compassEvent.FindCompassItem(thing);

		if (i < compassEvent.CompassItems.Size())
		{
			compassEvent.CompassItems[i].Destroy();
			compassEvent.CompassItems.Delete(i, 1);
			compassEvent.CompassItems.ShrinkToFit();
		}
	}

	static void Flash()
	{
		CompassHandler compassEvent = CompassHandler(EventHandler.Find("CompassHandler"));
		if (!compassEvent) { return; }

		compassEvent.drawflash = level.time;
	}

	static void ForceActivate(Actor owner, bool activate)
	{
		if (owner && owner.player)
		{
			Inventory cmpsitem = owner.FindInventory("BoACompass");
			if (cmpsitem)
			{
				BoACompass compass = BoACompass(cmpsitem);
				compass.active = activate;
			}
		}
	}
}

// Disguise token to change player sprites and properties
//  Formerly handled in CheckSpriteToken function in BoAPlayer class
//  Properties are named similarly to their corresponding PlayerPawn property
//  If you don't specify a crouch sprite, the standing sprite is used and default squishing applies
//  DropItem list is used as the list of weapons that are allowed to be carried without breaking the disguise
//
// See RyanToken below for simple example.
class DisguiseToken : CustomInventory
{
	int viewheight;
	double playerscale;
	double viewbob;
	double forwardmove1, forwardmove2;
	double sidemove1, sidemove2;
	String HUDsprite;
	SpriteID basesprite, crouchsprite;
	bool notarget;
	int notargettimeout;

	Property ViewHeight:viewheight;
	Property PlayerScale:playerscale;
	Property ViewBob:viewbob;
	Property ForwardMove:forwardmove1, forwardmove2;
	Property SideMove:sidemove1, sidemove2;
	Property HUDSprite:HUDsprite;
	Property NoTarget:notarget;

	Default
	{
		+INVENTORY.KEEPDEPLETED
		Inventory.MaxAmount 1;
		DisguiseToken.PlayerScale 0.65; // Overrides scale of original player class
		DisguiseToken.ViewHeight -1; // -1 means 'use player class default' for everything below...
		DisguiseToken.ViewBob -1;
		DisguiseToken.ForwardMove -1, -1;
		DisguiseToken.SideMove -1, -1;
		DisguiseToken.HUDSprite "STF"; // Default to using the default mugshot
		DisguiseToken.NoTarget True; // If True, disguise hides player from Nazis.  If False, player just uses alternate skin but is fired at normally.
		DropItem "NullWeapon"; // Misappropriate DropItem to list weapons that can be equipped without breaking disguise
		DropItem "FakeID", 1; // Drop probability is used as a flag field; set to 1 to allow this weapon to be fired in disguise and to not alert enemies
	}

	States
	{
		Use:
			TNT1 A -1;
			Stop;
		// Define WalkSprite (and CrouchSprite, if used) in token actor's states
		WalkSprite:
			PLAY A 0;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		State WalkState = FindState("WalkSprite");
		State CrouchState = FindState("CrouchSprite");

		basesprite = WalkState.sprite;

		if (CrouchState) { crouchsprite = CrouchState.sprite; }
	}

	override void Tick()
	{
		Super.Tick();

		let p = PlayerPawn(owner);

		if (!p || !p.player) { return; }

		if (Amount > 0) // Apply token-specific settings and sprites to the player
		{
			if (playerscale > 0) { p.scale = (1.0, 1.0) * playerscale; }

			if (crouchsprite && p.player.crouchfactor < 0.75)
			{
				p.sprite = crouchsprite;
				p.scale.y *= 1.0 / p.player.crouchfactor; // Negate crouch sprite scaling
			}
			else
			{
				p.sprite = basesprite;
			}

			if (viewheight > -1)
			{
				p.viewheight = viewheight;
				p.attackzoffset = p.Default.attackzoffset * viewheight / p.Default.viewheight;
			}

			if (p.scale.x != playerscale) { p.A_SetSize(p.Default.radius * p.scale.x / p.Default.scale.x, p.Default.height * p.scale.y / p.Default.scale.y); }

			if (viewbob > -1) { p.viewbob = viewbob; }
			if (forwardmove1 > -1 && forwardmove2 > -1) { p.forwardmove1 = forwardmove1; p.forwardmove2 = forwardmove2; }
			if (sidemove1 > -1 && sidemove2 > -1) { p.sidemove1 = sidemove1; p.sidemove2 = sidemove2; }

			if (notarget) { SetNoTarget(); }
		}
		else // Restore player defaults
		{
			p.sprite = p.SpawnState.sprite;
			p.viewheight = p.Default.viewheight;
			p.attackzoffset = p.Default.attackzoffset;
			if (p.scale != p.Default.scale)
			{
				p.scale = p.Default.scale;
				p.A_SetSize(p.Default.radius, p.Default.height);
			}
			p.viewbob = p.Default.viewbob;
			p.forwardmove1 = p.Default.forwardmove1;
			p.forwardmove2 = p.Default.forwardmove2;
			p.sidemove1 = p.Default.sidemove1;
			p.sidemove2 = p.Default.sidemove2;

			Destroy();
		}
	}

	void SetNoTarget()
	{
		bool hide = true;
		let weap = owner.player.ReadyWeapon;

		if (weap && !owner.FindInventory("DisguiseFailToken", true))
		{
			DropItem allowedweapons = GetDropItems();

			if (allowedweapons)
			{
				for (DropItem weaponitem = allowedweapons; weaponitem != null; weaponitem = weaponitem.Next)
				{
					Class<Weapon> testweapon = weaponitem.Name;

					if (testweapon && testweapon == weap.GetClass())
					{
						let psp = owner.player.GetPSprite(PSP_WEAPON);

						if ( // If in ready state, up state, or down state, turn notarget on unless enemies are already alerted
							weaponitem.Probability != 255 ||
							psp.CurState == weap.GetReadyState() ||
							psp.CurState == weap.GetUpState() ||
							psp.CurState == weap.GetDownState()
						) 
						{
							Inventory vis = owner.FindInventory("BoAVisibility");	

							if (!vis || !BoAVisibility(vis).alertedcount) // If no enemies are already alerted, turn on notarget
							{
								notargettimeout = level.time + 2;
							}
						}
						else
						{
							notargettimeout = level.time;
						}

						break;
					}
				}
			}
		}

		if (notargettimeout)
		{
			if (notargettimeout <= level.time) // Turn off notarget and reset speed
			{
				owner.player.cheats &= ~CF_NOTARGET;
				owner.speed = owner.Default.speed;

				notargettimeout = 0;
			}
			else // Turn on notarget and slow down your movement
			{
				owner.player.cheats |= CF_NOTARGET;
				owner.speed = owner.Default.speed * 0.85;
			}
		}
	}
}

class RyanToken : DisguiseToken
{
	Default
	{
		DisguiseToken.ViewBob 0.22; // Less bob then BJ
		DisguiseToken.ForwardMove 0.9, 0.45; // Just a little slower than BJ
		DisguiseToken.SideMove 0.9, 0.45;
		DisguiseToken.HUDSprite "RTF"; // Ryan Mugshot
		DisguiseToken.NoTarget False; // Don't hide player from enemies
	}

	States
	{
		WalkSprite:
			PLRR A 0;
		CrouchSprite:
			PLYR A 0;
	}
}

class PowerRepairing : Powerup
{
	Default
	{
		Powerup.Duration -15;
		Powerup.Strength 3; // Per tic HP increase
	}

	override void DoEffect()
	{
		Super.DoEffect();
		if (!Owner)
		{
			return;
		}
		else if (Owner is "ShermanPlayer")
		{
			// I would like to transfer the powerup to the tank body if the
			// player exits the tank, but I don't know if that is even possible.
			Owner.GiveBody(int(Strength), GetDefaultByType("ShermanPlayer").Health);
		}
		else
		{
			Destroy();
		}
	}
}

class RepairKit : CompassItem
{
	Default
	{
		//$Title Repair Kit (electric)
		Tag "$TAGREKIT";
		Inventory.Icon "EKPKA0";
		Inventory.PickupMessage "$ELECPAK";
		Inventory.PickupSound "misc/gadget_pickup";
		Inventory.MaxAmount 3;
	}

	States
	{
	Spawn:
		EKPK B -1;
		Stop;
	}

	override bool Use(bool pickup)
	{
		if (Owner.FindInventory("PowerRepairing"))
		{
			return false;
		}
		if (Owner is "ShermanPlayer")
		{
			Inventory repairing = Owner.GiveInventoryType("PowerRepairing");
			return true;
		}
		return false;
	}
}

class BandagesPowerup : PowerUp
{
	Default
	{
		Powerup.Duration -10;
		Powerup.Strength 1;
	}

	// Derived from base PowerRegeneration class, but using actual ticrate-based seconds instead of running every 32 tics
	override void DoEffect()
	{
		Super.DoEffect();

		if (owner && owner.health > 0 && (Level.maptime % TICRATE) == 0)
		{
			if (Owner.GiveBody(int(Strength)))
			{
				Owner.A_StartSound("*regenerate", CHAN_ITEM);
			}
		}
	}
}

class ZyklonResistance: PowerupGiver
{
	Default
	{
		+INVENTORY.INVBAR
		Radius 8;
		Height 16;
		Scale 0.3;
		Inventory.Icon "BEAKD0";
		Inventory.MaxAmount 1;
		Inventory.PickupSound "misc/k_pkup";
		Inventory.PickupMessage "You picked up a glowing green vial!";
		Powerup.Duration 0x7FFFFFFF;
		Powerup.Type "PowerZyklonResistance";
	}

	States
	{
		Spawn:
			BEAK D -1 BRIGHT;
			Stop;
	}
}

class PowerZyklonResistance : PowerProtection
{
	Default
	{
		DamageFactor "UndeadPoison", 0.25;
		DamageFactor "UndeadPoisonAmbience", 0.25;
	}
}