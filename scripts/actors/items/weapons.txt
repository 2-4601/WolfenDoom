/*

  Base class for BoA Weapons

  Custom Properties
	NaziWeapon.Stealth
	- Boolean property that allows the weapon to be carried while in disguise 
	  without breaking the disguise.  See Shovel and NullWeapon for example.
	- Firing the weapon can still alert enemies and cause the disguise to fail.

*/
class NaziWeapon : Weapon
{
	bool allowdisguised;
	int notargettimeout;

	Property Stealth:allowdisguised; // Weapons tagged as stealth can be carried while in disguise without breaking the disguise unless they are fired

	Default
	{
		+WEAPON.AMMO_CHECKBOTH
		+WEAPON.NOALERT
		Weapon.BobStyle "InverseSmooth";
		Weapon.BobSpeed 2.2;
		Weapon.BobRangeY 1.0;
		Weapon.BobRangeX 1.25;
		NaziWeapon.Stealth False;
	}

	States
	{
		Dryfire:
			"####" "#" 1 A_JumpIf(CallACS("Autoreload")==1,"Reload");
			"####" "#" 1 Offset(0,35) A_PlaySound("weapon/dryfire", CHAN_WEAPON);
			"####" "#" 9 Offset(0,34);
			"####" "#" 0 A_Jump(256,"Ready");
			Stop;
	}

	override void PostBeginPlay()
	{
		// Allow the drop amount of the weapon to set the amount of primary ammunition that is in a pickup
		// Default drop amount value is 1, and is interpreted as normal drop amount handling...
		if (Amount > 1)
		{
			// Take skill ammo drop amounts into account when calculating amount of ammo to give
			float dropammofactor = G_SkillPropertyFloat(SKILLP_DropAmmoFactor);
			if (dropammofactor == -1) { dropammofactor = 0.5; }

			// Default to affecting AmmoType1, with fallback to AmmoType2 if the
			//  weapon does not give any of AmmoType1 (Nazis weapons use AmmoType1
			//  as the current clip's amount, and give only to AmmoType2 normally.
			if (AmmoGive1 > 0) { AmmoGive1 = int(Amount * dropammofactor); }
			else if (AmmoGive2 > 0) { AmmoGive2 = int(Amount * dropammofactor); }

			Amount = 1;
		}
		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (allowdisguised && owner && owner.player)
		{
			if (owner.player.ReadyWeapon == self && owner.FindInventory("DisguiseToken", true))
			{
				let psp = owner.player.GetPSprite(PSP_WEAPON);

				if (psp.CurState == GetReadyState()) // If in ready state, turn notarget on unless enemies are already alerted
				{
					Inventory vis = owner.FindInventory("BoAVisibility");

					if (vis && BoAVisibility(vis).alertedcount > 0) { owner.player.cheats &= ~CF_NOTARGET; } // Disguise fails if there are active enemies
					else
					{
						owner.player.cheats |= CF_NOTARGET;
						notargettimeout = level.time + 1;
					}
				}
				else if (psp.CurState == GetUpState()) // If in select state, turn notarget on and slow down your movement
				{
					owner.player.cheats |= CF_NOTARGET;
					owner.speed = owner.Default.speed * 0.85;
					notargettimeout = level.time + 1; 
				}
				else if (
					psp.CurState == GetDownState() || // If in deselect state, reset speed and turn off notarget
					psp.CurState == GetAtkState(false) || // or if in fire state
					psp.CurState == GetAtkState(true) || // or if in hold state
					psp.CurState == GetAltAtkState(false) || // or if in altfire state
					psp.CurState == GetAltAtkState(true) // or if in althold state
				)
				{
					owner.player.cheats &= ~CF_NOTARGET;
					owner.speed = owner.Default.speed;
				}
			}
			else if (notargettimeout && notargettimeout < level.time)
			{
				owner.player.cheats &= ~CF_NOTARGET;
				notargettimeout = 0;
			}
		}

		Super.Tick();
	}

	action void A_SpawnLightning(Class<LightningBeam> beam = "LightningBeam")
	{
		bool spawned;
		Actor b;

		let p = player.mo;

		double pitchoffset = p.radius * -sin(p.pitch);

		[spawned, b] = A_SpawnItemEx(beam, pitchoffset, 0, player.viewheight * 0.8);
		if (spawned)
		{
			b.master = p;
			b.pitch = p.pitch;
			b.angle = p.angle;

			// The beam segment actors handle damaging enemeis themseleves, but we must get
			// the default properties of the actual specified beam's segment actor so we can...
			Class<MovingTrailBeam> trail = LightningBeam(b).trail;
			let def = GetDefaultByType(trail);

			// Spawn a short-range bullet attack immediately in front to ensure that you 
			// damage enemies that are closer to you than the first damaging beam segment,
			// which spawns 64 units away from the player's center in order to keep from 
			// damaging the player whenever you fire the weapon.  
			// Uses the beam segment actor's damage amount, or defaults to Random(0, 1)
			A_CustomBulletAttack(0, 0, 1, def ? def.Damage : Random(0, 1), "LightningPuff", 64, CBAF_AIMFACING);
		}
	}
}

class NullWeapon : NaziWeapon
{
	Default
	{
		+INVENTORY.UNDROPPABLE
		+WEAPON.NOALERT
		Weapon.SelectionOrder 99999; // Make this absolutely last in weapon priority
		Tag "$TAGCLOAK";
		NaziWeapon.Stealth True;
	}

	States
	{
		Select:
			TNT1 A 1 A_Raise;
			Loop;
		Deselect:
			TNT1 A 1 A_Lower;
			Loop;
		Fire:
		Ready:
			TNT1 A 1 A_WeaponReady(WRF_NOFIRE);
			Loop;
	}
}

// The astrostein weapons have altfires that should use primary (loaded) ammo
class NaziAstroWeapon : NaziWeapon {
	Default
	{
		Scale 0.50;
	}

	// DryFire state definition removed because it was the same as the DryFire state for NaziWeapon

	// Astrostein weapons use primary ammo for both fire modes.
	override bool CheckAmmo (int firemode, bool autoSwitch, bool requireAmmo = false, int ammocount = -1) {
		// True if player has loaded ammo, or ammo in the stockpile.
		// For the shocker, or if player has infinite ammo powerup.
		if (bAmmo_Optional || Owner.FindInventory("PowerInfiniteAmmo", true)) return true;
		// Make sure player has either loaded ammo, or ammo in the stockpile.
		if (AmmoType1 && AmmoType2 && !Owner.FindInventory(AmmoType1) && !Owner.FindInventory(AmmoType2)) return false;
		return Super.CheckAmmo(firemode, autoSwitch, requireAmmo, ammocount);
	}

	override bool DepleteAmmo (bool altfire, bool checkEnough = true, int ammouse = -1) {
		if (AmmoUse1 == 0 || Owner.FindInventory("PowerInfiniteAmmo", true)) return true;

		bool requireAmmo = AmmoUse1 > 0 || AmmoUse2 > 0 || !bAmmo_Optional;

		if (checkEnough) {
			if (CheckAmmo(PrimaryFire, true, requireAmmo, ammouse)) {
				if (AmmoType1) {
					Ammo magAmmo = Ammo(Owner.FindInventory(AmmoType1));
					if (magAmmo) {
						magAmmo.amount -= AmmoUse1;
						return true;
					}
				}
			}
		}
		return false;
	}
}