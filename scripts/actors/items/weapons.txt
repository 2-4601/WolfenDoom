/*

  Base class for BoA Weapons

  Custom Properties
	NaziWeapon.Stealth
	- Boolean property that allows the weapon to be carried while in disguise 
	  without breaking the disguise.  See Shovel and NullWeapon for example.
	- Firing the weapon can still alert enemies and cause the disguise to fail.

*/
class NaziWeapon : Weapon
{
	bool allowdisguised;
	int notargettimeout;

	Property Stealth:allowdisguised; // Weapons tagged as stealth can be carried while in disguise without breaking the disguise unless they are fired

	Default
	{
		+WEAPON.AMMO_CHECKBOTH
		+WEAPON.NOALERT
		Weapon.BobStyle "InverseSmooth";
		Weapon.BobSpeed 2.2;
		Weapon.BobRangeY 1.0;
		Weapon.BobRangeX 1.25;
		NaziWeapon.Stealth False;
	}

	States
	{
		Dryfire:
			"####" "#" 1 A_JumpIf(CallACS("Autoreload")==1,"Reload");
			"####" "#" 1 Offset(0,35) A_PlaySound("weapon/dryfire", CHAN_WEAPON);
			"####" "#" 9 Offset(0,34);
			"####" "#" 0 A_Jump(256,"Ready");
			Stop;
	}

	override void PostBeginPlay()
	{
		// Allow the drop amount of the weapon to set the amount of primary ammunition that is in a pickup
		// Default drop amount value is 1, and is interpreted as normal drop amount handling...
		if (Amount > 1)
		{
			// Take skill ammo drop amounts into account when calculating amount of ammo to give
			float dropammofactor = G_SkillPropertyFloat(SKILLP_DropAmmoFactor);
			if (dropammofactor == -1) { dropammofactor = 0.5; }

			// Default to affecting AmmoType1, with fallback to AmmoType2 if the
			//  weapon does not give any of AmmoType1 (Nazis weapons use AmmoType1
			//  as the current clip's amount, and give only to AmmoType2 normally.
			if (AmmoGive1 > 0) { AmmoGive1 = int(Amount * dropammofactor); }
			else if (AmmoGive2 > 0) { AmmoGive2 = int(Amount * dropammofactor); }

			Amount = 1;
		}
		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (allowdisguised && owner && owner.player)
		{
			if (owner.player.ReadyWeapon == self && owner.FindInventory("DisguiseToken", true))
			{
				let psp = owner.player.GetPSprite(PSP_WEAPON);

				if ( // If in ready state, up state, or down state, turn notarget on unless enemies are already alerted
					psp.CurState == GetReadyState() ||
					psp.CurState == GetUpState() ||
					psp.CurState == GetDownState()
				) 
				{
					Inventory vis = owner.FindInventory("BoAVisibility");

					if (!vis || !BoAVisibility(vis).alertedcount) // If no enemies are already alerted, turn on notarget
					{
						notargettimeout = level.time + 2;
					}
				}
				else
				{
					notargettimeout = level.time;
				}
			}

			if (notargettimeout)
			{
				if (notargettimeout <= level.time) // Turn off notarget and reset speed
				{
					if (
						owner.player.ReadyWeapon == self ||
						(
							!NaziWeapon(owner.player.ReadyWeapon) ||
							!NaziWeapon(owner.player.ReadyWeapon).allowdisguised)
						)
					{
						owner.player.cheats &= ~CF_NOTARGET;
						owner.speed = owner.Default.speed;
					}
					notargettimeout = 0;
				}
				else // Turn on notarget and slow down your movement
				{
					owner.player.cheats |= CF_NOTARGET;
					owner.speed = owner.Default.speed * 0.85;
				}
			}
		}

		Super.Tick();
	}

	action void A_SpawnLightning(Class<LightningBeam> beam = "LightningBeam")
	{
		bool spawned;
		Actor b;

		let p = player.mo;

		double pitchoffset = p.radius * -sin(p.pitch);

		[spawned, b] = A_SpawnItemEx(beam, pitchoffset, 0, player.viewheight * 0.8);
		if (spawned)
		{
			b.master = p;
			b.pitch = p.pitch;
			b.angle = p.angle;

			// The beam segment actors handle damaging enemeis themseleves, but we must get
			// the default properties of the actual specified beam's segment actor so we can...
			Class<MovingTrailBeam> trail = LightningBeam(b).trail;
			let def = GetDefaultByType(trail);

			// Spawn a short-range bullet attack immediately in front to ensure that you 
			// damage enemies that are closer to you than the first damaging beam segment,
			// which spawns 64 units away from the player's center in order to keep from 
			// damaging the player whenever you fire the weapon.  
			// Uses the beam segment actor's damage amount, or defaults to Random(0, 1)
			A_CustomBulletAttack(0, 0, 1, def ? def.Damage : Random(0, 1), "LightningPuff", 64, CBAF_AIMFACING);
		}
	}
}

class NullWeapon : NaziWeapon
{
	Default
	{
		+INVENTORY.UNDROPPABLE
		+WEAPON.NOALERT
		Weapon.SelectionOrder 99999; // Make this absolutely last in weapon priority
		Tag "$TAGCLOAK";
		NaziWeapon.Stealth True;
	}

	States
	{
		Select:
			TNT1 A 1 A_Raise;
			Loop;
		Deselect:
			TNT1 A 1 A_Lower;
			Loop;
		Fire:
		Ready:
			TNT1 A 1 A_WeaponReady(WRF_NOFIRE);
			Loop;
	}
}

// The astrostein weapons have altfires that should use primary (loaded) ammo
class NaziAstroWeapon : NaziWeapon {
	Default
	{
		Scale 0.50;
	}

	// DryFire state definition removed because it was the same as the DryFire state for NaziWeapon

	// Astrostein weapons use primary ammo for both fire modes.
	override bool CheckAmmo (int firemode, bool autoSwitch, bool requireAmmo, int ammocount) {
		// True if player has loaded ammo, or ammo in the stockpile.
		// For the shocker, or if player has infinite ammo powerup.
		if (bAmmo_Optional || Owner.FindInventory("PowerInfiniteAmmo", true)) return true;
		// Make sure player has either loaded ammo, or ammo in the stockpile.
		if (AmmoType1 && AmmoType2 && !Owner.FindInventory(AmmoType1) && !Owner.FindInventory(AmmoType2)) return false;
		return Super.CheckAmmo(firemode, autoSwitch, requireAmmo, ammocount);
	}

	override bool DepleteAmmo (bool altfire, bool checkEnough, int ammouse) {
		if (AmmoUse1 == 0 || Owner.FindInventory("PowerInfiniteAmmo", true)) return true;

		bool requireAmmo = AmmoUse1 > 0 || AmmoUse2 > 0 || !bAmmo_Optional;

		if (checkEnough) {
			if (CheckAmmo(PrimaryFire, true, requireAmmo, ammouse)) {
				if (AmmoType1) {
					Ammo magAmmo = Ammo(Owner.FindInventory(AmmoType1));
					if (magAmmo) {
						magAmmo.amount -= AmmoUse1;
						return true;
					}
				}
			}
		}
		return false;
	}
}

class Cannon75mm : NaziWeapon // Weapon used when morphed into a tank. 
{
	int cannontimeout;

	Default
	{
		Weapon.SelectionOrder 1;
	}

	States
	{
		Ready:
			TNT1 A 1 A_TankRefire();
			Loop;
		Select:
			TNT1 A 1 A_Raise;
			Loop;
		Deselect:
			TNT1 A 1 A_Lower;
			Loop;
		Fire:
			TNT1 A 2 DoCannon();
			TNT1 A 0 A_TankRefire();
			Goto Ready;
		AltFire:
			TNT1 A 6 DoMachineGun();
			TNT1 A 20 A_TankRefire();
			Goto Ready;
		Spawn:
			UNKN A -1;
			Loop;
	}

	action void A_TankReFire(statelabel flash = null)
	{
		let player = self.player;

		if (!player) { return; }

		if ((player.cmd.buttons & BT_ATTACK) && player.health > 0 && !player.refire) 
		{
			player.refire++;
			player.mo.FireWeapon(ResolveState(flash));
		}
		else if ((player.cmd.buttons & BT_ALTATTACK) && player.health > 0)
		{
			if (player.mo is "ShermanPlayer") { ShermanPlayer(player.mo).altrefire++; }
			else { player.refire++; }
			player.mo.FireWeaponAlt(ResolveState(flash));
		}
		else
		{
			if (player.mo is "ShermanPlayer") { ShermanPlayer(player.mo).altrefire = 0; }
			else { player.refire = 0; }
		}
	}

	override void Tick()
	{
		Super.Tick();

		if (cannontimeout > 0) { cannontimeout--; }
		else if (owner && owner.player && !(owner.player.cmd.buttons & BT_ATTACK)) { owner.player.refire = 0; }
	}

	action void DoCannon()
	{
		Actor origin = self;
		if (origin && ShermanPlayer(origin) && ShermanPlayer(origin).turret && US_ShermanTurret(ShermanPlayer(origin).turret).gun) { origin = US_ShermanTurret(ShermanPlayer(origin).turret).gun; }

		double angledelta = deltaangle(angle, origin.angle);
		double pitchdelta = deltaangle(pitch, origin.pitch);

		A_PlaySound("Panzer/fire", CHAN_WEAPON);
		A_GunFlash();
		Actor mo = A_FireProjectile("ShermanRocket", angledelta, False, 0, 0, FPF_NOAUTOAIM, pitchdelta);
		if (mo && origin != self)
		{
			mo.SetOrigin(origin.pos, false); // Move the rocket so that it flies from the model's gun
		}

		invoker.cannontimeout = 40;
	}

	action void DoMachineGun()
	{
		Actor origin = self;
		if (origin && ShermanPlayer(origin) && ShermanPlayer(origin).treads) { origin = ShermanPlayer(origin).treads; }

		// Nullify angle and pitch so the weapon always fires straight ahead
		double angledelta = deltaangle(angle, origin.angle);
		double pitchdelta = deltaangle(pitch, origin.pitch);

		A_PlaySound("mauser/fire", CHAN_WEAPON, FRandom(0.6, 0.8));
		Actor mo = A_FireProjectile("Kar98kTracer", angledelta + Random(-2, 2), False, 20, 16, 0, pitchdelta + Random(-2, 2));
		if (mo)
		{
			mo.bMThruSpecies = true;
		}
	}
}

class ShermanRocket : Actor
{
	Default
	{
		Radius 5;
		Height 6;
		Speed 70;
		Projectile;
		-NOTELEPORT
		+WINDTHRUST
		+THRUGHOST
		+MTHRUSPECIES
		Damage (2500);
		DamageType "Rocket";
		Decal "Scorch";
		Obituary "$OBPANZA";
		ProjectileKickback 25000;
	}

	States
	{
		Spawn:
			TNT1 A 2;
		SpawnLoop:
			MNSS A 1 Bright Light("BOAFLMW2") A_PlaySound("panzer/fly", CHAN_VOICE, 1.0, TRUE);
			MNSS A 1 Bright Light("BOAFLMW2") A_SpawnItemEx("RocketFlame", random(-1,1), 0, random(-1,1));
			Wait;
		Death:
			EXP1 A 0 A_SetScale(1.25, 1.25);
			EXP1 A 0 A_AlertMonsters();
			EXP1 A 0 A_StopSound(CHAN_VOICE);
			EXP1 A 0 A_PlaySound("panzer/explode", CHAN_VOICE, 1.0, FALSE, ATTN_NORM);
			EXP1 A 0 A_Explode(192);
			TNT1 AAAAAAAAAAAAAAAAAAAAAAAAAAA 0 A_SpawnItemEx("TracerSpark_Longlive", 0, 0, 0, random(-5,5), random(-5,5), random(-5,5), random(0,359)); //T667 improvements
			TNT1 A 0 A_SpawnItemEx("PanzerNuke", 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
			TNT1 A 8 A_SpawnItemEx("GeneralExplosion_Large", 56, 0, 32);
			EXP1 A 2 Bright Light("BOAFLMW2") A_Quake(9, 15, 0, 1024, "");
			EXP1 BCDEFGHIJKLMN 2 Bright Light("BOAFLMW2");
			Stop;
	}
}

class TurretSwivel : Actor
{
	Default
	{
		Height 2;
		Radius 2;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+NOINTERACTION
		+THRUSPECIES
		Species "Turret";
	}

	States
	{
		Spawn:
			 MDLA A -1;
		Stop;
	}
}

class TurretGun : Actor
{
	Actor swivel, light, light2, light3;
	double shotcount;
	int maxshotcount;
	int cooldowntime, cooldowntimeout, heatlevel, heatthreshold;

	Property MaxShotCount:maxshotcount;
	Property TemperatureThreshold:heatthreshold;
	Property CoolDownTime:cooldowntime;

	Default
	{
		Radius 2;
		Height 2;
		+MOVEWITHSECTOR
		+NOBLOCKMAP
		+NOGRAVITY
		+NOINTERACTION
		+THRUSPECIES
		Species "Turret";
		TurretGun.MaxShotCount 100; // How many rounds to fire before reloading
		TurretGun.TemperatureThreshold 200; // How many tics of continuous fire before cooldown (roughly 50 degrees per 100 rounds)
		TurretGun.CoolDownTime 140; // How many tics you must wait before firing again after hitting max temperature (does NOT guarantee full cooldown!)
	}

	States
	{
		Spawn:
			MDLA A 1;
			Loop;
		Reload:
			MDLA A 5 A_PlaySound("weapon/dryfire", CHAN_WEAPON);
			MDLA A 35 DoReload();
			MDLA A 5 A_PlaySound("mp40/reload", CHAN_WEAPON);
			MDLA A 5;
			Goto Spawn;
		Cooldown:
			MDLA A 0 DoCoolDown();
			Goto Spawn;
		Fire:
			MDLA ABCD 2 {
				A_PlaySound("mp40/fire", CHAN_WEAPON);
				A_SpawnItemEx("9MMCasing", 4 * scale.x, 4 * scale.x, 8 * scale.y, 8, Random(-2,2), Random(0,4), Random(50,80), SXF_NOCHECKPOSITION);
				A_SpawnItemEx("KTFlare", 34 * scale.x * cos(-pitch), 0, 8 * scale.y + 34 * scale.x * sin(-pitch), 0, 0, 0, 0, SXF_NOCHECKPOSITION | SXF_TRANSFERROLL | SXF_TRANSFERPITCH);
				Actor mo = A_SpawnProjectile("KTurretTracer", 8 * scale.y, 0, FRandom(-1.0, 1.0), CMF_AIMDIRECTION, pitch + FRandom(-1.0, 1.0));

				shotcount++;
				heatlevel++;

				if (maxshotcount && shotcount > maxshotcount) { return ResolveState("Reload"); }
				if (heatthreshold && heatlevel > heatthreshold) { return ResolveState("Cooldown"); }
				return ResolveState(null);
			}
			Goto Spawn;
	}

	override void PostBeginPlay()
	{
		while (!swivel) { swivel = Spawn("TurretSwivel", pos); }
		swivel.scale = scale;

		while (!light) { light = Spawn("AlphaLight", pos + (RotateVector((28 * scale.x, 0), angle), 8 * scale.y)); }
		light.scale = scale;
		light.master = self;
		DynamicLight(light).bAdditive = true;
		AlphaLight(light).clr = 0xFF2000;

		while (!light2) { light2 = Spawn("AlphaLight", pos + (RotateVector((28 * scale.x, 0), angle), 8 * scale.y)); }
		light2.scale = scale;
		light2.master = self;
		AlphaLight(light2).clr = 0xFF6600;

		while (!light3) { light3 = Spawn("AlphaLight", pos + (RotateVector((28 * scale.x, 0), angle), 8 * scale.y)); }
		light3.scale = scale;
		light3.master = self;
		AlphaLight(light2).clr = 0xFFFFDD;

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (heatlevel && level.time && level.time % 4 == 0) { heatlevel--; }

		if (swivel) { swivel.angle = angle; }

		double heatamt = double(heatlevel) / heatthreshold;

		if (light) { light.alpha = clamp(heatamt * 1.25, 0, 1.0); }
		if (light2) { light2.alpha = clamp((heatamt - 0.75) * 3, 0, 1.0); }
		if (light3) { light3.alpha = clamp((heatamt - 0.85) * 5.7, 0, 1.0); }

		Super.Tick();
	}

	void DoReload()
	{
		shotcount = 0;
		A_PlaySound("mauser/insert", CHAN_WEAPON);
	}

	void DoCoolDown()
	{
		A_SetTics(cooldowntime);
		A_PlaySound("STEAM_BURST", CHAN_WEAPON);
	}
}

class TurretStand : SwitchableDecoration
{
	Actor shooter, gun;
	Weapon playerlastweapon;
	FLineTraceData crosshairtrace;
	double pangle, ppitch;
	bool freezeonreload;

	Property FreezeOnReload:freezeonreload;

	Default
	{
		//$Category Weapons (Wolf3D)
		//$Title Usable Turret (ZScript)
		//$Color 14
		Radius 8;
		Height 32;
		+MOVEWITHSECTOR
		+MTHRUSPECIES
		+SOLID
		+THRUSPECIES
		Species "Turret";
		TurretStand.FreezeOnReload False;
	}

	States
	{
		Spawn:
			MDLA A -1;
	}

	override bool Used(Actor user)
	{
		if (shooter)
		{
			if (shooter == user)
			{
				shooter = null;
				return true;
			}

			return false;
		}
		
		double delta = deltaangle(angle, AngleTo(user));

		if (user.player && abs(delta) > 135) // Player must be within +/-45 degrees of directly behind the gun
		{
			shooter = user;
			if (gun)
			{
				gun.target = user;
				user.angle = gun.angle;
			}
			return true;
		}

		return false;
	}

	override void PostBeginPlay()
	{
		bool sp;

		while (!gun) { [sp, gun] = A_SpawnItemEx("TurretGun", 0, 0, 18); }
		gun.master = self;
		gun.scale = scale;

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (shooter && shooter.player && gun)
		{
			if (
				shooter.player.cmd.buttons & BT_CROUCH ||
				shooter.player.cmd.buttons & BT_JUMP ||
				shooter.player.cmd.forwardmove ||
				shooter.player.cmd.sidemove
			)
			{
				shooter.player.PendingWeapon = playerlastweapon;
				shooter.player.MinPitch = -90;
				shooter.player.MaxPitch = 90;
				shooter.player.viewheight = PlayerPawn(shooter).viewheight;
				shooter = null;
			}
			else
			{
				shooter.SetOrigin(pos + RotateVector((-24, 0), angle), true); // Keep the shooter at the firing position

				Weapon lowered = Weapon(shooter.FindInventory("NullWeapon"));

				if (shooter.player.ReadyWeapon != lowered)
				{
					playerlastweapon = shooter.player.ReadyWeapon;
					shooter.player.PendingWeapon = lowered;
				}
				else

				if (!freezeonreload || !gun.InStateSequence(gun.CurState, gun.FindState("Reload")))
				{
					gun.angle += shooter.player.cmd.yaw * (360./65536.);
					gun.angle = clamp(gun.angle, angle - 90, angle + 90);

					gun.pitch = clamp(pitch + gun.pitch - shooter.player.cmd.pitch * (360. / 65536.), -55, 55);

					gun.LineTrace(gun.angle, 2048, gun.pitch, TRF_THRUHITSCAN | TRF_THRUBLOCK | TRF_THRUACTORS | TRF_THRUSPECIES, 0.0, 0.0, 8.0, crosshairtrace);

					Vector3 offset = crosshairtrace.HitLocation - (shooter.pos + (0, 0, shooter.player.viewheight));
					offset = (RotateVector(offset.xy, -angle), offset.z);

					pangle = angle - atan(-offset.y / offset.x);
					ppitch = pitch - atan(offset.z / offset.xy.length());
				}

				shooter.player.viewheight = PlayerPawn(shooter).viewheight * 7 / 8; // Crouch slightly over the gun
				shooter.player.MinPitch = ppitch; // Force the pitch to wherever the gun is aiming
				shooter.player.MaxPitch = ppitch;

				shooter.angle = pangle;

				if (shooter.player.cmd.buttons & BT_ATTACK)
				{
					if (gun.InStateSequence(gun.CurState, gun.SpawnState)) { gun.SetStateLabel("Fire"); }
				}
			}
		}

		Super.Tick();
	}
}

class AlphaLight : DynamicLight
{
	Color clr;
	double maxradius;
	Vector3 spawnoffset;

	Property LightColor:clr;
	Property LightRadius:maxradius;

	Default
	{
		DynamicLight.Type "Point";
		AlphaLight.LightColor 0xFFFFFF;
		AlphaLight.LightRadius 16;
	}

	override void BeginPlay ()
	{
		alpha = 0;

		args[LIGHT_RED] = clr.r;
		args[LIGHT_GREEN] = clr.g;
		args[LIGHT_BLUE] = clr.b;
		args[LIGHT_INTENSITY] = int(maxradius); //int(maxradius * scale.y * alpha);

		Super.BeginPlay();
	}

	override void PostBeginPlay()
	{
		if (master)
		{
			spawnoffset = pos - master.pos;

			Vector2 temp = RotateVector((spawnoffset.x, spawnoffset.y), -master.angle);
			spawnoffset = (temp.x, temp.y, spawnoffset.z);
		}

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		args[LIGHT_RED] = int(clr.r * alpha);
		args[LIGHT_GREEN] = int(clr.g * alpha);
		args[LIGHT_BLUE] = int(clr.b * alpha);
		args[LIGHT_INTENSITY] = int(maxradius); //int(maxradius * scale.y * alpha);

		if (master && spawnoffset != (0, 0, 0)) { Rotate(); }

		Super.Tick();
	}

	void Rotate()
	{
		Vector2 temp = RotateVector((spawnoffset.y, spawnoffset.z), master.roll);
		Vector3 offset = (spawnoffset.x, temp.x, temp.y);

		temp = RotateVector((offset.x, offset.z), 360 - master.pitch);
		offset = (temp.x, offset.y, temp.y);

		temp = RotateVector((offset.x, offset.y), master.angle);
		offset = (temp.x, temp.y, offset.z);

		offset.x *= master.scale.x;
		offset.y *= master.scale.x;
		offset.z *= master.scale.y;

		SetOrigin(master.pos + offset, true);
	}
}
