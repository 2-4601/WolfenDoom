/*

 Base actor for the gatekeeper.  These actors started life as Star Trek-style sliding doors.

  On map load, these actors make whatever line they are placed on impassible.  When a player 
  approaches, the line is made passible and the actor's state is changed.  Once the player
  moves away, the line returns to being impassible, and the actor returns to the Spawn state.

  The actor can optionally be configured to check for a specific class and amount of an 
  inventory item that the player must be carrying in order to pass.

  Gatekeepers can be linked together (both will deactivate if one is passed) by assigning
  them the same TID.

 The GhostGate actor below uses this base actor to create an impassible swirling portal that
 spews unfriendly ghosts that cause damage to player in range who do not carry the necessary
 amount of the 'Soul' inventory item.  The amount of 'Soul' needed can be specified in the
 first argument of the map object (default is 25).

 The GhostGateHelper actor is the same as the GhostGate actor, but has no swirl, light, spirits,
 or numeric display effects.  It's intended for use when you want to block multiple linedefs
 with a single Ghostgate - just give the helpers the same TID as the main GhostGate actor.

*/
class GateKeeper : Actor
{

	int timeout, maxtimeout, activationradius, user_keyamount, linelength;
	double lineangle;
	Line linedef;
	Array<Actor> Activators;
	Class<Inventory> key;

	Property ActivationRadius:ActivationRadius;
	Property Timeout:maxtimeout;
	Property Key:key;
	Property KeyAmount:user_keyamount;

	Default
	{
		+SPECIAL
		+INVISIBLE
		-SOLID
		Height 92;
		Radius 8;
		GateKeeper.ActivationRadius 92;
		GateKeeper.Timeout 5;
		ActiveSound "";
	}

	States
	{
		Spawn:
			UNKN A -1;
			Stop;
		Disperse:
			UNKN A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		// Find the line that this actor's centerpoint is closest to
		double dist;

		BlockLinesIterator it = BlockLinesIterator.Create(self);

		While (it.Next())
		{
			Line current = it.curline;

			// Discard lines that definitely don't cross the actor's center point
			if (
				(current.v1.p.x > pos.x + radius && current.v2.p.x > pos.x + radius) ||
				(current.v1.p.x < pos.x - radius && current.v2.p.x < pos.x - radius) ||
				(current.v1.p.y > pos.y + radius && current.v2.p.y > pos.y + radius) ||
				(current.v1.p.y < pos.y - radius && current.v2.p.y < pos.y - radius) 
			) { continue; }

			// Find the line that is closest based on proximity to end vertices
			double curdist = (current.v1.p - pos.xy + current.v2.p - pos.xy).Length();
			if (!linedef || curdist <= dist)
			{
				linedef = current;
				dist = curdist;
			}
		}

		if (!linedef)
		{
			Destroy(); 
			return;
		}

		linedef.flags |= Line.ML_BLOCKEVERYTHING;
		linelength = int(linedef.delta.Length());

		if (!linedef.delta.x) { lineangle = 0; }
		else if (!linedef.delta.y) { lineangle = 90; }
		else { lineangle = (atan(linedef.delta.y / linedef.delta.x) + 90) % 360; }

		angle = lineangle;

		activationradius = max(activationradius, linelength);

		A_SetSize(activationradius);
	}

	override void Touch(Actor toucher)
	{
		if (Activators.Find(toucher) == Activators.Size()) { Activators.Push(toucher); }
	}

	override void Tick()
	{
		if (globalfreeze || level.Frozen) { return; }

		Super.Tick();

		target = null;

		for (int i = 0; i < Activators.Size(); i++)
		{
			if (Activators[i])
			{
				if (
					Distance2D(Activators[i]) <= Activators[i].Radius * 2 ||
					Distance2D(Activators[i]) <= Radius
				)
				{
					if (
						!key || 
						(
							Activators[i].FindInventory(key) &&
							Activators[i].FindInventory(key).Amount >= user_keyamount
						) ||
						timeout < 0
					)
					{
						if (maxtimeout < 0 && timeout > maxtimeout)
						{
							if (Distance2D(Activators[i]) < linelength / 2)
							{
								Activators[i].TakeInventory(key, user_keyamount);
								user_keyamount = 0;
								timeout = maxtimeout;
							}
						}
						else
						{
							timeout = maxtimeout;
						}
						if (!target || Distance2D(Activators[i]) < Distance2D(target)) { target = Activators[i]; }
					}
					else
					{
						if (Distance2D(Activators[i]) <= linelength * 3 / 5)
						{
							Activators[i].Thrust(0.5, AngleTo(Activators[i]));
						}
					}
				}
				else { Activators.Delete(i); }
			}
		}

		if (timeout == 0)
		{
			if (!InStateSequence(CurState, SpawnState)) { SetStateLabel("Spawn"); }
			if (linedef) { linedef.flags |= Line.ML_BLOCKEVERYTHING; }
		}
		else
		{
			if (!InStateSequence(CurState, FindState("Disperse"))) { SetStateLabel("Disperse"); }
			if (linedef) { linedef.flags &= ~Line.ML_BLOCKEVERYTHING; }

			if (tid)
			{ // If there's a TID, affect all Gatekeepers with that TID
				let it = ActorIterator.Create(tid, "Gatekeeper");
				Actor mo;

				while (mo = Actor(it.Next()))
				{
					Gatekeeper(mo).timeout = timeout;
					GateKeeper(mo).user_keyamount = user_keyamount;

					if (GhostGate(mo))
					{
						if (GhostGate(mo).swirl) { GhostGate(mo).swirl.Destroy(); }
						if (GhostGate(mo).light) { GhostGate(mo).light.Destroy(); }
					}
				}
			}
		}

		if (timeout > 0) { timeout--; }
	}
}

Class CreepyEffect : Actor
{
	Vector3 offset;
	int dir, angledelta;

	Default
	{
		+NOCLIP
		+NOGRAVITY
		Height 16;
		Radius 8;
		RenderStyle 'Add';
		Alpha 0.45;
	}

	States
	{
		Spawn:
			SPI1 BAABBAABB 2 Bright { A_FadeIn(0.05); }
		SpawnLoop:
			SPI1 AABB 2 Bright { A_FadeOut(0.01); }
			Loop;
	}

	override void BeginPlay()
	{
		alpha = 0;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		if (master)
		{
			offset = pos - master.pos;
			if (master is "GateKeeper") { angledelta = max(64 * 8 / GateKeeper(master).linelength, 1); }
			else { angledelta = 8; }
		}

		dir = offset.y > 0 ? 1 : -1;
	}

	override void Tick()
	{
		Super.Tick();

		if (globalfreeze || level.Frozen) { return; }
	
		if (master)
		{
			Warp(master, 0, offset.y, offset.z, angle + angledelta * dir, WARPF_ABSOLUTEANGLE | WARPF_NOCHECKPOSITION | WARPF_INTERPOLATE);
		}

		if (alpha > 0.25) { A_Explode(1, 1); }
	}
}

class GateLight : DynamicLight
{
	Color clr;
	int lightradius;
	int targetradius;

	override void BeginPlay ()
	{
		clr.r = 50;
		clr.g = 180;
		clr.b = 128;

		lightradius = 64;
		targetradius = 64;

		args[LIGHT_RED] = clr.r;
		args[LIGHT_GREEN] = clr.g;
		args[LIGHT_BLUE] = clr.b;
		args[LIGHT_INTENSITY] = lightradius;

		Super.BeginPlay();
	}

	override void Tick()
	{
		if (globalfreeze || level.Frozen) { return; }

		scale.x = max(scale.x, 1.0);

		args[LIGHT_RED] = int(clr.r / scale.x);
		args[LIGHT_GREEN] = int(clr.g / scale.x);
		args[LIGHT_BLUE] = int(clr.b / scale.x);

		if (lightradius > 64) { lightradius = 64; }
		if (targetradius > 64) { targetradius = 64; }

		if (level.time)
		{
			if (args[LIGHT_INTENSITY] == targetradius)
			{
				targetradius = int((lightradius + Random(-2, 2)) * scale.x);
			}
			else
			{
				int step = max(abs(args[LIGHT_INTENSITY] - targetradius) / 4, 1);

				if (args[LIGHT_INTENSITY] > targetradius) { args[LIGHT_INTENSITY] = max(targetradius, args[LIGHT_INTENSITY] - step); }
				if (args[LIGHT_INTENSITY] < targetradius) { args[LIGHT_INTENSITY] = min(targetradius, args[LIGHT_INTENSITY] + step); }
			}
		}
		else { args[LIGHT_INTENSITY] = 0; }

		Super.Tick();
	}
}

class GhostGate : GateKeeper
{
	double startalpha;
	Array<Actor> spawns;
	Array<Actor> numbers;
	Actor swirl, light;
	sound loopsound, opensound;
	color textcolor, targetcolor;
	int textspeed;
	double pulseratio;

	Property LoopSound:loopsound;
	Property OpenSound:opensound;

	Default
	{
		//$Category Hazards (Wolf3D)
		//$Title "Soul Gate"
		//$Color 12
		//$Sprite SWRLA0
		//$Arg0 "Amount of 'Soul' item required"
		//$Arg0Default 25;
		//$Arg0Tooltip "How many of the 'Soul' inventory item must be carried by the player to pass this gate.\nCan also be set via the 'user_keyamount' UDMF property."

		GateKeeper.Key "Soul";
		GateKeeper.KeyAmount 25;
		GateKeeper.ActivationRadius 192;
		GateKeeper.Timeout -1;

		GhostGate.LoopSound "creepyrift/loop";
		GhostGate.OpenSound "creepy/born";
	}

	States
	{
		Spawn:
			UNKN A 2 {
				if (spawns.Size() < user_keyamount)
				{
					tics = Random(1, 10);

					bool sp;
					Actor mo;
	
					[sp, mo] = A_SpawnItemEx("CreepyEffect", 0, Random(-linelength / 2, linelength / 2), Random(16, 96), 0, 0, random(1, 2), 180 - angle, SXF_NOCHECKPOSITION | SXF_SETMASTER);

					if (sp)
					{
						mo.alpha = 0;
						mo.Scale *= FRandom(0.4, 0.6);
						spawns.Push(mo);
					}
				}
			}
			Loop;
		Disperse:
			UNKN A 1;
			Loop;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		if (!linedef)
		{
			console.printf("\cgERROR: \clSoul Gate actor at %d, %d, %d was not placed on a linedef!", pos.x, pos.y, pos.z);
			return;
		}
		else if (!linedef.sidedef[0] || !linedef.sidedef[1])
		{
			console.printf("\cgERROR: \clSoul Gate actor at %d, %d, %d was placed on a one-sided line!  Unexpected behavior may result.", pos.x, pos.y, pos.z);
		}

		if (user_keyamount == 25 && args[0]) { user_keyamount = args[0]; }

		SpawnDigits(user_keyamount, "FlatNumber");

		swirl = Spawn("Swirl_Wall", pos + (0, 0, 64));

		if (swirl)
		{
			swirl.angle = angle;
			swirl.alpha = 0.85;
		}

		light = Spawn("GateLight", pos + (0, 0, 64));

		if (light)
		{
			GateLight(light).lightradius = linelength / 2;
			GateLight(light).targetradius = linelength / 2;
		}

		TextureID tex = TexMan.CheckForTexture("WATR_G98", TexMan.Type_Any);

		if (tex && ceilingz - pos.z < 128)
		{
			if (linedef.sidedef[0])
			{
				linedef.sidedef[0].SetTexture(Side.mid, tex);
				linedef.sidedef[0].SetTextureXScale(Side.mid, 3);
				linedef.sidedef[0].SetTextureYScale(Side.mid, 3);
			}

			if (linedef.sidedef[1])
			{
				linedef.sidedef[1].SetTexture(Side.mid, tex);
				linedef.sidedef[1].SetTextureXScale(Side.mid, 3);
				linedef.sidedef[1].SetTextureYScale(Side.mid, 3);
			}

			linedef.alpha = 0.05;

			linedef.flags |= Line.ML_WRAP_MIDTEX ;
		}

		startalpha = linedef.alpha;

		targetcolor = "189454"; // Creepy green;
		textspeed = 8;

		A_PlaySound(loopsound, CHAN_6, 0.45, true, ATTN_NORM);
	}

	Actor ClosestPlayer(double dist = 0)
	{
		Actor ClosestPlayer = null;

		for (int p = 0; p < MAXPLAYERS; p++) { // Iterate through all of the players and find the closest one
			Actor mo = players[p].mo;

			if (mo) {
				if (dist > 0 && Distance2d(mo) > dist) { continue; }
				if (!mo.bShootable || mo.health <= 0) { continue; }
				if (ClosestPlayer && Distance2d(mo) > Distance2d(ClosestPlayer)) { continue; }

				ClosestPlayer = mo;
			}
		}
		return ClosestPlayer;
	}

	void SpawnDigits(int number, Class<Actor> numactor)
	{
		int digits;
		int temp = number;

		double position;
		double width = 14 * 0.4;

		while (temp)
		{
			digits++;
			temp /= 10;
		}

		position = width * digits / 2 - width / 2;

		for (int i = 0; i < digits; i++)
		{
			int digit = number % 10;

			bool sp;
			Actor mo;
	
			[sp, mo] = A_SpawnItemEx(numactor, 2, -position, 30, flags: SXF_NOCHECKPOSITION);
			if (sp)
			{
				numbers.Push(mo);
				FlatNumber(mo).value = digit;
				mo.master = self;
			}

			[sp, mo] = A_SpawnItemEx(numactor, -2, -position, 30, angle:180, flags: SXF_NOCHECKPOSITION);
			if (sp)
			{
				numbers.Push(mo);
				FlatNumber(mo).value = digit;
				mo.master = self;
			}

			number /= 10;
			position -= width;
		}
	}

	SpriteID LookupSprite(Name spritecheck)
	{
		SpriteID temp = GetSpriteIndex(spritecheck);
		if (temp > -1) { return temp; }

		console.printf("\cgERROR: \cjThe sprite name index for '\cf%s\cj' could not be found.  Did you forget to add it to one of the actor's states?", spritecheck);
		return sprite;
	}

	override void Tick()
	{
		if (globalfreeze || level.Frozen) { return; }

		Super.Tick();

		double distratio = 1.0;
		double pratio = 1.0;

		if (target) { distratio = clamp(sin((Distance2D(target) - 64) * 90 / (activationradius - 64)), 0.001, 1.0); }

		Actor p = ClosestPlayer(activationradius);
		if (p) { pratio = Distance2D(p) / activationradius; }

		linedef.alpha = distratio * startalpha;

		if (swirl)
		{
			if (target)
			{
				swirl.scale = swirl.default.scale / pratio;
				swirl.alpha = 0.85 * distratio ** 2;
			}
			else {
				swirl.scale = swirl.default.scale;
				swirl.alpha = 0.85;
			}

			if (distratio <= 0.05 && !user_keyamount)
			{
				A_PlaySound(opensound, CHAN_6, 0.25, false, ATTN_NORM);
				
				swirl.Destroy();
			}
		}

		if (light)
		{
			if (target) { light.scale = light.default.scale / pratio ** 2; }
			else { light.scale = light.default.scale; }

			if (pratio <= 0.05 && !user_keyamount)
			{
				light.Destroy();
			}
		}

		for (int i = 0; i < spawns.Size(); i++)
		{
			if (spawns[i] && distratio < 1)
			{
				spawns[i].alpha = min(spawns[i].alpha, distratio * spawns[i].default.alpha);
				if (!swirl) { spawns[i].Destroy(); }
			}

			if (!spawns[i])
			{
				spawns.Delete(i);
			}
		}

		if (textcolor != targetcolor)
		{
			if (textcolor.r < targetcolor.r) { textcolor.r = int(min(targetcolor.r, textcolor.r + textspeed)); }
			else if (textcolor.r > targetcolor.r) { textcolor.r = int(max(targetcolor.r, textcolor.r - textspeed)); }

			if (textcolor.g < targetcolor.g) { textcolor.g = int(min(targetcolor.g, textcolor.g + textspeed)); }
			else if (textcolor.g > targetcolor.g) { textcolor.g = int(max(targetcolor.g, textcolor.g - textspeed)); }

			if (textcolor.b < targetcolor.b) { textcolor.b = int(min(targetcolor.b, textcolor.b + textspeed)); }
			else if (textcolor.b > targetcolor.b) { textcolor.b = int(max(targetcolor.b, textcolor.b - textspeed)); }
		}

		for (int i = 0; i < numbers.Size(); i++)
		{
			if (numbers[i])
			{
				if (!user_keyamount) { numbers[i].Destroy(); }
				else if (!target)
				{
					double sratio = p ? sin(level.time * textspeed) : 0;

					if (!p) { targetcolor = "189454"; }

					if (sratio != pulseratio)
					{
						if (sratio > pulseratio)
						{
							targetcolor = "FF0000";
						}
						else
						{
							targetcolor = "189454";
						}
					}

					pulseratio = sratio;

					numbers[i].alpha = (numbers[i].alpha + (distratio * numbers[i].default.alpha + sratio * (1.0 - numbers[i].default.alpha))) / 2; // Smooth any abrupt transitions
					numbers[i].scale = (numbers[i].default.scale.x + 0.05 * sratio, numbers[i].default.scale.y + 0.05 * sratio); // Make the number pulse when a player is in range but doesn't have enough souls
				}
				else
				{
					numbers[i].alpha = distratio * numbers[i].default.alpha;
				}

				if (numbers[i]) { numbers[i].SetShade(textcolor); }
			}

			if (!numbers[i])
			{
				numbers.Delete(i);
			}
		}

		if (!swirl && !light && !user_keyamount && !Spawns.Size() && !numbers.Size())
		{
			Destroy();
		}

	}
}

// Ghost gate with no swirl, light, spirits, or numbers.

class GhostGateHelper : GhostGate
{
	Default
	{
		//$Category Hazards (Wolf3D)
		//$Title "Soul Gate (No effects)"
		//$Color 12
		//$Sprite SWRLA0
		//$Arg0 "Amount of 'Soul' item required"
		//$Arg0Default 25;
		//$Arg0Tooltip "How many of the 'Soul' inventory item must be carried by the player to pass this gate.\nCan also be set via the 'user_keyamount' UDMF property."
	}

	States
	{
		Spawn:
			UNKN A 2;
			Loop;
		Disperse:
			UNKN A 1;
			Loop;
	}


	override void PostBeginPlay()
	{
		GateKeeper.PostBeginPlay();

		if (!linedef)
		{
			console.printf("\cgERROR: \clSoul Gate helper actor at %d, %d, %d was not placed on a linedef!", pos.x, pos.y, pos.z);
			return;
		}
		else if (!linedef.sidedef[0] || !linedef.sidedef[1])
		{
			console.printf("\cgERROR: \clSoul Gate helper actor at %d, %d, %d was placed on a one-sided line!  Unexpected behavior may result.", pos.x, pos.y, pos.z);
		}

		if (user_keyamount == 25 && args[0]) { user_keyamount = args[0]; }

		TextureID tex = TexMan.CheckForTexture("WATR_G98", TexMan.Type_Any);

		if (tex && ceilingz - pos.z < 128)
		{
			if (linedef.sidedef[0])
			{
				linedef.sidedef[0].SetTexture(Side.mid, tex);
				linedef.sidedef[0].SetTextureXScale(Side.mid, 3);
				linedef.sidedef[0].SetTextureYScale(Side.mid, 3);
			}

			if (linedef.sidedef[1])
			{
				linedef.sidedef[1].SetTexture(Side.mid, tex);
				linedef.sidedef[1].SetTextureXScale(Side.mid, 3);
				linedef.sidedef[1].SetTextureYScale(Side.mid, 3);
			}

			linedef.alpha = 0.1;

			linedef.flags |= Line.ML_WRAP_MIDTEX ;
		}

		startalpha = linedef.alpha;

		targetcolor = "189454"; // Creepy green;
		textspeed = 8;

		A_PlaySound(loopsound, CHAN_6, 0.45, true, ATTN_NORM);
	}
}

class FlatNumber : Actor
{
	int value;
	Vector3 offset;

	Default
	{
		+NOGRAVITY
		-SOLID
		+WALLSPRITE
		+MASKROTATION
		Radius 0;
		Height 0;
		Alpha 0.85;
		Scale 0.4;
		Renderstyle 'AddShaded';
		StencilColor "000000";
		VisibleAngles -90, 90;
		VisiblePitch -90, 90;
	}

	States
	{
		Spawn:
			FNUM A -1 Bright;
			Stop;
	}

	override void PostBeginPlay()
	{
		SpawnPoint = pos;
		offset = pos - master.pos;
		offset = (RotateVector(offset.xy, -master.angle), offset.z);

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (globalfreeze || level.Frozen) { return; }

		frame = value;

		if (level.time)
		{
			Vector2 newpos = RotateVector((offset.x * scale.x / default.scale.x, offset.y * scale.x / default.scale.x), master.angle);

			SetOrigin((master.pos.x + newpos.x, master.pos.y + newpos.y, master.pos.z + offset.z + 2 * sin(level.time) / 2), true);
		}

		Super.Tick();
	}
}