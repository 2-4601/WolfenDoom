class Alarm : Base
{
	bool active;
	int looptime;

	Default
	{
		+WALLSPRITE
		+ROLLSPRITE
		+NOGRAVITY
		-SOLID
		Height 16;
		Radius 8;
	}

	States
	{
		Spawn:
			ALRM A 0;
		Inactive:
			"####" A 35 { active = false; }
			Loop;
		Active:
			"####" AB 1 { active = true; }
			Loop;
	}

	override void Tick()
	{
		Super.Tick();

		if (active)
		{
			SoundAlert(target, false, 512);
			if (looptime-- <= 0)
			{
				A_PlaySound("alarm_ring", CHAN_AUTO);
				looptime = 70; // Duration of alarm loop sound in tics
			}
		}
	}
}

class AlarmPanel : SwitchableDecoration
{
	bool active;

	Default
	{
		+WALLSPRITE
		+ROLLSPRITE
		+NOGRAVITY
		-SOLID
		Height 48;
		Radius 24;
	}

	States
	{
		Deactivate:
			"####" Q 0 A_SetPeerState(false);
		Spawn:
			ALRM Q 0;
		Inactive:
			"####" Q 35 { FindActivator(); active = false; }
			Loop;
		Activate:
			"####" P 0 A_SetPeerState();
		Active:
			"####" P 35 Light("LAZERRED") { active = true; }
			Loop;
	}

	override bool Used(Actor user)
	{ // Handle the player activating/deactivating the alarm
		target = user;
		if (active) { SetStateLabel("Deactivate"); }
		else { SetStateLabel("Activate"); }
		return false;
	}

	void FindActivator(int range = 1024)
	{
		NaziStandard closest;

		BlockThingsIterator it = BlockThingsIterator.Create(self, range);
		NaziStandard mo;

		while (it.Next())
		{
			mo = NaziStandard(it.thing);

			if (!mo) { continue; }
			if (!mo.bShootable || mo.health <= 0) { mo.alarm = null; continue; }
			if (!CheckSight(mo)) { mo.alarm = null; continue; }
			if (closest && Distance3d(mo) > Distance3d(closest)) { mo.alarm = null; continue; }

			closest = mo;
		}

		if (closest) { closest.alarm = self; }
	}

	void A_SetPeerState(bool makeactive = true)
	{
		if (tid)
		{ // If there's a TID, affect all actors with that TID
			let it = ActorIterator.Create(tid, "Actor");
			Actor mo;

			while (mo = Actor(it.Next()))
			{
				DoActivation(mo, makeactive);
			}

			DoActivation(self, makeactive);
		}
	}

	void DoActivation(Actor mo, bool makeactive)
	{
		if (!makeactive)
		{
			mo.target = null;
			mo.SoundAlert(NULL, false);
			mo.SetStateLabel("Inactive");
		}
		else
		{
			if (LastHeard && LastHeard is "PlayerPawn") { target = LastHeard; }
			if (!target) { target = FindClosestPlayer(360); }
			mo.target = target;
			mo.SetStateLabel("Active");
		}
	}

	Actor FindClosestPlayer(int fov = 120, int dist = 0, bool IgnoreFriendlies = True) // Also sets up initial sight parameters
	{
		Actor ClosestPlayer = null;

		LookExParams SearchParams;

		SearchParams.fov = fov;
		SearchParams.minDist = 0;
		SearchParams.maxDist = dist;
		SearchParams.maxHearDist = dist;

		for (int p = 0; p < MAXPLAYERS; p++) { // Iterate through all of the players and find the closest one
			Actor mo = players[p].mo;

			if (mo) {
				if (!mo.bShootable || mo.health <= 0) { continue; }
				if (players[p].cheats & CF_NOTARGET) { continue; }
				if (!IsVisible(mo, false, SearchParams)) { continue; }
				if (IgnoreFriendlies) { if (isFriend(mo)) { continue; } }
				if (ClosestPlayer && Distance3d(mo) > Distance3d(ClosestPlayer)) { continue; }

				ClosestPlayer = mo;
			}
		}
		return ClosestPlayer;
	}
}

class AlarmSpawner : Base
{
	Array<Actor> Guards;
	int guardcount;

	Default
	{
		+INVISIBLE
	}

	States
	{
		Spawn:
			UNKN A 1;
		Inactive:
			UNKN A 35;
			Loop;
		Active:
			UNKN A 35 A_SetTics(Random[Spawn](1, 3) * 35);
		Active.Spawn:
			UNKN A 1 {
				guardcount = 0;

				for (int i = 0; i < Guards.Size(); i++) {
					Actor mo = Guards[i];

					if (mo) {
						if (!mo.bShootable || mo.health <= 0) {
							Guards.Delete(i);
							Guards.ShrinkToFit();
						} else {
							guardcount++;
						}
					}
				}
			}
			UNKN A 1 {
				if (guardcount < 3) {
					vector3 location = pos;

					if (guardcount == 1) { location += (-24, 24, 0); }
					else if (guardcount == 2) { location += (-24, -24, 0); }

					//Spawn enemies if not visible to player
					if (!InPlayerSight()) {
						Actor guard = Spawn("SneakableSSMP40Guard", location);
						guard.target = target;
						guard.angle = angle;
						Nazi(guard).BecomeAlerted();
						Guards.Push(guard);
					}
					return ResolveState("Active");
				}
				return ResolveState("Inactive");
			}
	}
}