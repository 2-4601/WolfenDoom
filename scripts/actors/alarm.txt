/*

  These actors allow for activatable alarms that alert actors within a 512-unit radius.  
  Optionally, alarm activation can trigger spawn of additional enemies.

  Three actors are involved:
    AlarmPanel
	These are usable flatsprite actors that control Alarms and Alarm Spawners that have the
	same TID as the panel.  The Nazi-class descendant actor who is closest to the alarm panel
	(within 1024 units) will be automatically selected as the activator, and, once alerted, 
	will automatically walk to the alarm panel and activate it.  

	Any actors with the same TID as the Alarm Panel will be set to their 'Active' or 'Inactive'
	state, so any Alarm of Alarm Spawner actors (as well as any other switchable decorations)
	that have the same TID as the panel can be controlled by the panel.

	To silence alarms, the player must manually deactivate the alarm, or the Alarm Panel can 
	be set to the "Deactivate" state via ACS to set inactive all controlled actors.

	Players can also turn deactivated alarms on...  This would normally be dumb, but might be 
	useful for flushing guards into a courtyard away from a key, or something similar.

	Active AlarmPanel actors have a red glow on them.

    Alarm
	These are simple actors that, upon activation, alert all actors within a 512-
	unit radius and set the actors' target to the alarm panel activator's target.

    AlarmSpawner
	These are spawn point actors that spawn up to three SneakableSSMP40Guard actors
	when they are activated.  A maximum of three guards will be present at any time; 
	if three guards were spawned and one guard was killed before the alarm was shut
	off, the next time the alarm goes off, only one additional guard will spawn.

	Spawning only occurs when no player can see the spawn point.

	Useful custom properties (set on Custom tab of thing properties in GZDB):
	  user_tid
	    Sets the TID that the spawned enemies are given.  By default they have no TID.

	  user_goal
	    Sets the goal/patrolpoint TID that the spawned enemies will walk to once they return to 
	    being idle.  By default, they go back to their spawn point and stand still.

  Alarms and Alarm Spawners must be given the same TID as an Alarm Panel that will control
  them, otherwise they will not function.  You can have multiple Alarm Panels with the same
  TID (e.g., so that the player can turn of alarms from a side office after the alarms are 
  turned on by a guard in a main area).

*/
class Alarm : Base
{
	bool active;
	int looptime;

	Default
	{
		+WALLSPRITE
		+ROLLSPRITE
		+NOGRAVITY
		-SOLID
		Height 16;
		Radius 8;
	}

	States
	{
		Spawn:
			ALRM A 35;
		Inactive:
			"####" A 35 { active = false; }
			Loop;
		Active:
			"####" AB 1 { active = true; }
			Loop;
	}

	override void Tick()
	{
		Super.Tick();

		if (active)
		{
			SoundAlert(target, false, 512);

			looptime--;
			if (looptime <= 0)
			{
				A_PlaySound("alarm_ring", CHAN_AUTO);
				looptime = 70; // Duration of alarm loop sound in tics
			}
		}
	}
}

class AlarmPanel : SwitchableDecoration
{
	bool active;
	Actor activator;

	Default
	{
		+WALLSPRITE
		+ROLLSPRITE
		+NOGRAVITY
		-SOLID
		Height 48;
		Radius 16;
	}

	States
	{
		Spawn:
			ALRM Q 35;
		Deactivate:
			"####" Q 0 A_SetPeerState(false);
		Inactive:
			"####" Q 35 {
				if (
					!NaziStandard(activator) || 
					!activator.bShootable || 
					!activator.health > 0 || 
					(NaziStandard(activator).activationgoal && NaziStandard(activator).activationgoal != self)
				) {
					activator = FindActivator();
				}
				active = false;
			}
			Loop;
		Activate:
			"####" P 0 A_SetPeerState();
		Active:
			"####" P 35 Light("LAZERRED") { active = true; }
			Loop;
	}

	override bool Used(Actor user)
	{ // Handle the player activating/deactivating the alarm
		target = user;
		if (active) { SetStateLabel("Deactivate"); }
		else { SetStateLabel("Activate"); }
		return false;
	}

	Actor FindActivator(int range = 1024)
	{
		NaziStandard closest;

		BlockThingsIterator it = BlockThingsIterator.Create(self, range);
		NaziStandard mo;

		while (it.Next())
		{
			mo = NaziStandard(it.thing);

			if (!mo) { continue; }
			if (!mo.bShootable || mo.health <= 0) { mo.activationgoal = null; continue; }
			if (!CheckSight(mo)) { mo.activationgoal = null; continue; }
			if (closest && Distance3d(mo) > Distance3d(closest)) { mo.activationgoal = null; continue; }

			closest = mo;
		}

		if (closest) { closest.activationgoal = self; }
		return closest;
	}

	void A_SetPeerState(bool makeactive = true)
	{
		if (tid)
		{ // If there's a TID, affect all actors with that TID
			let it = ActorIterator.Create(tid, "Actor");
			Actor mo;

			while (mo = Actor(it.Next()))
			{
				DoActivation(mo, makeactive);
			}

			DoActivation(self, makeactive);
		}
	}

	void DoActivation(Actor mo, bool makeactive)
	{
		if (!makeactive)
		{
			mo.target = null;
			mo.SoundAlert(NULL, false);
			mo.SetStateLabel("Inactive");
		}
		else
		{
			if (LastHeard && LastHeard is "PlayerPawn") { target = LastHeard; }
			if (!target) { target = FindClosestPlayer(360); }
			mo.target = target;
			mo.SetStateLabel("Active");
		}
	}

	Actor FindClosestPlayer(int fov = 120, int dist = 0, bool IgnoreFriendlies = True) // Also sets up initial sight parameters
	{
		Actor ClosestPlayer = null;

		LookExParams SearchParams;

		SearchParams.fov = fov;
		SearchParams.minDist = 0;
		SearchParams.maxDist = dist;
		SearchParams.maxHearDist = dist;

		for (int p = 0; p < MAXPLAYERS; p++) { // Iterate through all of the players and find the closest one
			Actor mo = players[p].mo;

			if (mo) {
				if (!mo.bShootable || mo.health <= 0) { continue; }
				if (players[p].cheats & CF_NOTARGET) { continue; }
				if (!IsVisible(mo, false, SearchParams)) { continue; }
				if (IgnoreFriendlies) { if (isFriend(mo)) { continue; } }
				if (ClosestPlayer && Distance3d(mo) > Distance3d(ClosestPlayer)) { continue; }

				ClosestPlayer = mo;
			}
		}
		return ClosestPlayer;
	}
}

class AlarmSpawner : Base
{
	Array<Actor> Guards;
	int guardcount;
	int user_tid;
	int user_goal;

	States
	{
		Spawn:
			TNT1 A 35;
		Inactive:
			TNT1 A 35;
			Loop;
		Active:
			TNT1 A 35 A_SetTics(Random[Spawn](1, 3) * 35);
		Active.Spawn:
			TNT1 A 1 {
				guardcount = 0;

				for (int i = 0; i < Guards.Size(); i++) {
					Actor mo = Guards[i];

					if (mo) {
						if (!mo.bShootable || mo.health <= 0) {
							Guards.Delete(i);
							Guards.ShrinkToFit();
						} else {
							guardcount++;
						}
					}
				}
			}
			TNT1 A 1 {
				if (guardcount < 3) {
					vector3 location = pos;

					if (guardcount == 1) { location += (-24, 24, 0); }
					else if (guardcount == 2) { location += (-24, -24, 0); }

					//Spawn enemies if not visible to player
					if (!InPlayerSight()) {
						Actor guard = Spawn("SneakableSSMP40Guard", location);
						guard.target = target;
						guard.angle = angle;
						guard.ChangeTID(user_tid);
						if (user_goal > 0)
						{
							let it = ActorIterator.Create(user_goal, "PatrolPoint");
							Actor goal;
							if (it) { goal = it.Next(); }
							if (goal) { guard.goal = goal; }
						}
						Nazi(guard).BecomeAlerted();
						Guards.Push(guard);
					}
					return ResolveState("Active");
				}
				return ResolveState("Inactive");
			}
	}
}