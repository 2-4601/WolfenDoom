class Tiltable : Actor
{
	double leveltilt, oldtilt;
	double spawnheight, oldvel;

	Default
	{
		MaxStepHeight 0;
	}

	override void PostBeginPlay()
	{
		spawnheight = pos.z;
	}

	override void Tick()
	{
		Super.Tick();

		if (globalfreeze || level.Frozen) { return; }

		for (int i = 0; i < MAXPLAYERS; i++)
		{
			PlayerPawn mo = players[i].mo;
			if (playeringame[i] && BoAPlayer(mo))
			{
				leveltilt = BoAPlayer(mo).leveltilt;
				break;
			}
		}

		if (abs(leveltilt) > 10)
		{
			bNoGravity = leveltilt != 0;

			double grav = level.gravity * CurSector.gravity * Gravity * 0.00125 * floorz == pos.z ? 100.0 / (min(Mass, 1000) * max(cos(leveltilt), 0.01)) : 1;

			vel.z -= grav * cos(leveltilt);
			vel.x -= grav * sin(leveltilt);

			if (leveltilt != oldtilt)
			{
				if (leveltilt == 0)
				{
					A_SetSize(Default.Radius, Default.Height);
				}
				else
				{
					double abstilt = abs(leveltilt);
					double newradius = Default.radius * cos(abstilt) + Default.height / 2 * sin(abstilt);
					double newheight = Default.radius * sin(abstilt) + Default.height / 2 * cos(abstilt);

					if (height != newheight || radius != newradius) { A_SetSize(newradius, newheight, true); }
				}

				oldtilt = leveltilt;
			}

			if (oldvel != vel.Length())
			{
				angle += Random(-1, 1) * vel.Length();
			}

			if (abs(spawnheight - pos.z) > 10 * Height || (abs(oldvel - vel.Length())) > FRandom(1.0, 2.0) * Mass / 100) { DamageMobj(null, null, health, "none", DMG_FORCED); }

			oldvel = vel.Length();
		}
	}
}