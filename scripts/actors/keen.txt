// Base enemy class
class CKBaseEnemy : Actor
{
	bool stunned, stunframes;
	int stuntime, stuncounter, wakeontouch;
	Actor confusion;
	State StunState, ReviveState, AttackState;

	// Some generic variables for CK_ internal functions.  I'd rather put these functions all in the actual classes, but DECORATE...
	int counter, counter2;
	Vector3 offset;

	Property StunTime:stuntime;
	Property StunFrames:stunframes;
	Property WakeOnTouch:wakeontouch;

	Default
	{
		Monster;
		Damage 15;
		Scale 2.0;
		Gravity 1.2;
		+DONTTHRUST
		+FLOORCLIP
		+LOOKALLAROUND
		+NODAMAGE
		+NOBLOOD

		CKBaseEnemy.StunTime -1; // Default to staying stunned forever
		CKBaseEnemy.StunFrames 1; // Default to one possible frames for stun state (some actors have 2)
	}

	States
	{
		// Generic placeholder states, just in case something doesn't get defined properly
		Stunned:
			TNT1 A -1;
			Stop;
		Revive:
			TNT1 A 0 { SetState(SpawnState); }
	}

	override void PostBeginPlay()
	{
		StunState = FindState("Stunned");
		ReviveState = FindState("Revive");
		AttackState = FindState("Attack");
		if (!AttackState) { AttackState = FindState("Missile"); }
		if (!AttackState) { AttackState = FindState("Melee"); }

		SpawnPoint = pos;

		Super.PostBeginPlay();
	}

	// Don't take damage, only stun if stunnable (and the player is the one that shot you)
	// Be nice and let the 'kill monsters' cheat still work (won't stop enemies from reviving, though)
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (wakeontouch > 1)
		{
			wakeontouch = false;
			SetStateLabel("See");
		}

		if (bSolid && ((source && source.player || source is "PlayerFollower") || mod == "Massacre") && stuntime != 0 && !stunned) { DoStun(true); }

		return 0;
	}

	// Handles other actor touching this actor
	// If wake on touch is set, set this actor to See state
	// Otherwise, damage any player that is touched
	// Unless damage is set 0, then fall back to executing the actor's special
 	override void Touch(Actor toucher)
	{
		if (wakeontouch && toucher && toucher.player)
		{
			wakeontouch = false;
			SetStateLabel("See");
		}
		else if (damage && toucher && toucher.player)
		{
			if (!stunned) { toucher.DamageMobj(self, self, damage, "Melee"); }
		}
		else if (special) { Level.ExecuteSpecial(special, self, null, false, args[0], args[1], args[2], args[3], args[4]); }
	}

	override bool Used(Actor user)
	{
		if (self is "CKBounder")
		{
			if (!target || target != user) { user.SetOrigin(pos + (0, 0, height), true); return true; }
		}

		return false;
	}

	override void Tick()
	{
		Super.Tick();

		if (stunned) { DoStun(); }
	}

	// Force calling of the Touch function for players without resorting to using 
	// the SPECIAL flag, which changes other things with collision and interaction
	override bool CanCollideWith(Actor other, bool passive)
	{
		if (bShootable && other.player)
		{
			Touch(other);
			return true;
		}
		else if (!bShootable)
		{
			return false;
		}

		return true;
	}

	// Generic function for handling stunning of enemies
	void DoStun(bool initial = false)
	{
		if (!InStateSequence(CurState, StunState)) { SetState(StunState); }

		if (initial)
		{
			if (stunframes > 1) { frame += Random(0, stunframes - 1); } // Pick a random frame within set range
			stuncounter = stuntime;
			A_SetSize(Default.Radius, Default.Height / 2);
			bNotAutoAimed = true;

			stunned = true;
		}
		else
		{
			// Spawn confusion ring once the actor has hit the floor
			if (!confusion && (pos.z == floorz || bOnMobj))
			{
				vel *= 0;
				confusion = Spawn("CKConfusion", pos);
			}

			if (stuncounter > 0)
			{
				stuncounter--;
			}
			else if (stuncounter == 0)
			{
				stunned = false;
				if (confusion) { confusion.Destroy(); }

				A_SetSize(Default.Radius, Default.Height);
				bNotAutoAimed = Default.bNotAutoAimed;

				SetState(ReviveState);
			}
		}
	}

	// Function to handle Mad Mushroom bouncing pattern
	void CK_MushroomBounce()
	{
		if (pos.z == floorz || bOnMobj)
		{
			counter = (counter + 1) % 3;

			if (counter == 0)
			{
				vel.z = 17.0;
			}
			else
			{
				vel.z = 10.0;
			}

			A_PlaySound("ckeen/madmushroombounce");
		}
	}

	// Function to handle Bounder bounce pattern, re-imagined in 3D space
	void CK_BounderBounce()
	{
		LookforPlayers(true);

		bool blocked = BlockingLine;

		if (
			target &&
			(
				(Distance2D(target) < (Radius + target.radius) * 1.4 && target.pos.z >= pos.z + height && target.pos.z <= pos.z + height + 16) ||
				(
					target.pos.z >= pos.z + height &&
					(target.bOnMobj || (target.player && target.player.jumptics == 0)) && 
					Distance3D(target) < radius * 2
				)
			)
		)
		{ offset = target.pos - pos; }
		else { target = null; }

		if (!blocked && BlockingMobj)
		{
			if (BlockingMobj != target) { blocked = true; }
		}

		if (bOnMobj)
		{
			Actor onmo = FindOnMobj();
			if (!onmo || onmo == target) { bOnMobj = false; }
		}

		if (pos.z == floorz || blocked || waterlevel || bOnMobj)
		{
			if (pos.z == floorz || waterlevel || bOnMobj)
			{
				counter++;
				A_PlaySound("ckeen/madmushroombounce");
				vel.z = 12.0;
			}

			if (target)
			{
				counter = 0;

				angle = target.angle;

				double scale = 1.0 - (abs(target.pitch) / 90);
				scale *= 0.75;
				scale -= 0.25;
				
				vel.xy = RotateVector((Speed * 1.5 * scale, 0), angle);

				if (!CheckMove(pos.xy + vel.xy))
				{
					vel.xy *= 0;
				}
			}
			else if (counter > 2 && counter2)
			{
				counter2 = 0;

				if (Random() < 200)
				{
					angle = Random(0, 359);
					vel.xy = RotateVector((Speed, 0), angle);
				}
			}
			else
			{
				counter2 = 1;
				vel.xy *= 0;
			}
		}

		if (target)
		{
			if (target.CheckMove(pos.xy + offset.xy) && CheckMove(pos.xy + vel.xy)) { target.SetOrigin(pos + (vel.xy, vel.z * gravity) + offset, true); }
		}
	}

	// Function to move an actor in a straight line until it hits something, then change directions randomly, with preference for moving toward player.
	void CK_Glide(int maxstep = 0)
	{
		LookforPlayers(true);

		if (BlockingMobj || BlockingLine || SpawnTime == level.time || (maxstep && counter >= maxstep))
		{
			if (target && IsVisible(target, true))
			{
				if (angle != AngleTo(target)) { angle = AngleTo(target); }
				else { angle += 180; }
			}
			else { angle = Random(0, 359); }

			counter = 0;
		}

		vel.xy = RotateVector((Speed, 0), angle);

		if (AttackState && Distance2D(target) <= Radius + MaxTargetRange)
		{
			SetState(AttackState);
		}

		counter++;
	}

	void CK_Float(int dist = 16, double speed = 1.5)
	{
		SetOrigin(pos + (0, 0, speed), true);

		if (abs(pos.z - SpawnPoint.z) > dist) { FloatSpeed *= -1; }
	}

	Actor FindOnMObj()
	{
		BlockThingsIterator it = BlockThingsIterator.Create(self, 1);

		while (it.Next())
		{
			let mo = it.thing;

			if (mo == self) { continue; } // Ignore itself

			if (mo.bSolid && pos.z == mo.pos.z + mo.height)
			{
				return mo;
			}
		}

		return null;
	}
}

// Pickup items: points, health, and gems
/* GZDB-BF cant parse mixins right now...  Copy/pasting redundant code to each item type's base class below for now
mixin class CKPickup
{
	Actor touched;
	double vspeed;
	State PickupState;
	int ticker;

	Property VSpeed:vspeed;

	Default
	{
		//$Category Commander Keen (BoA)/Pickups
		//$Color 17

		Scale 2.0;
		+NOGRAVITY
	}

	override void PostBeginPlay()
	{
		SpawnPoint = pos;
		PickupState = FindState("Pickup");

		Super.PostBeginPlay();
	}

	override void Touch(Actor toucher)
	{
		if (toucher.player && !touched)
		{
			touched = toucher;
			ticker = 12;

			bDropped = false;

			Super.Touch(toucher);
		}
	}

	override void Tick()
	{
		if (touched)
		{
			if (!InStateSequence(CurState, PickupState))
			{
				SetState(PickupState);

				vel.z = vspeed;
			}

			if (ticker > 0) { ticker--; }
			else
			{
				bInvisible = true;
				touched = null;

				GoAwayAndDie();
			}
		}

		Super.Tick();
	}

	override bool ShouldStay ()
	{
		if (touched && ticker) { return true; }

		return false;
	}
}
*/

class CKTreasure : StackableInventory
{
//	mixin CKPickup;
	Actor touched;
	double vspeed;
	State PickupState;
	int ticker;

	Property VSpeed:vspeed;

	Default
	{
		//$Category Commander Keen (BoA)/Pickups
		//$Color 17

		Scale 2.0;
		+NOGRAVITY
		+COUNTITEM

		Inventory.MaxAmount 10000000;
		Inventory.PickupFlash "";
		Inventory.PickupSound "ckeen/pickup";
		+INVENTORY.UNDROPPABLE

		CKTreasure.VSpeed 4;
	}

	override void PostBeginPlay()
	{
		SpawnPoint = pos;
		PickupState = FindState("Pickup");

		Super.PostBeginPlay();
	}

	override void Touch(Actor toucher)
	{
		if (toucher.player && !touched)
		{
			touched = toucher;
			ticker = 12;

			bDropped = false;

			Super.Touch(toucher);
		}
	}

	override void Tick()
	{
		if (touched)
		{
			if (!InStateSequence(CurState, PickupState))
			{
				SetState(PickupState);

				vel.z = vspeed;
			}

			if (ticker > 0) { ticker--; }
			else
			{
				bInvisible = true;
				touched = null;

				SetOrigin(SpawnPoint, false);

				GoAwayAndDie();
			}
		}

		Super.Tick();
	}

	override bool ShouldStay ()
	{
		if (touched && ticker) { return true; }

		return false;
	}
}

class CKHealth : Health
{
//	mixin CKPickup;
	Actor touched;
	double vspeed;
	State PickupState;
	int ticker;

	Property VSpeed:vspeed;

	Default
	{
		//$Category Commander Keen (BoA)/Pickups
		//$Color 17

		Scale 2.0;
		+NOGRAVITY

		Inventory.PickupFlash "";
		Inventory.PickupSound "ckeen/pickup";

		CKHealth.VSpeed 4;
	}

	override void PostBeginPlay()
	{
		SpawnPoint = pos;
		PickupState = FindState("Pickup");

		Super.PostBeginPlay();
	}

	override void Touch(Actor toucher)
	{
		if (toucher.player && !touched)
		{
			touched = toucher;
			ticker = 12;

			bDropped = false;

			Super.Touch(toucher);
		}
	}

	override void Tick()
	{
		if (touched)
		{
			if (!InStateSequence(CurState, PickupState))
			{
				SetState(PickupState);

				vel.z = vspeed;
			}

			if (ticker > 0) { ticker--; }
			else
			{
				bInvisible = true;
				touched = null;

				GoAwayAndDie();
			}
		}

		Super.Tick();
	}

	override bool ShouldStay ()
	{
		if (touched && ticker) { return true; }

		return false;
	}
}

class CKPuzzleItem : PuzzleItem
{
//	mixin CKPickup;
	Actor touched;
	double vspeed;
	State PickupState;
	int ticker;

	Property VSpeed:vspeed;

	Default
	{
		Scale 2.0;
		+NOGRAVITY

		//$Category Commander Keen (BoA)/Items
		//$Color 13

		Inventory.MaxAmount 1;
		Inventory.PickupFlash "";
		Inventory.PickupSound "ckeen/gem";
		-INVENTORY.INVBAR

		CKPuzzleItem.VSpeed 4;
	}

	override void PostBeginPlay()
	{
		SpawnPoint = pos;
		PickupState = FindState("Pickup");

		Super.PostBeginPlay();
	}

	override void Touch(Actor toucher)
	{
		if (toucher.player && !touched)
		{
			touched = toucher;
			ticker = 12;

			bDropped = false;

			Super.Touch(toucher);
		}
	}

	override void Tick()
	{
		if (touched)
		{
			if (!InStateSequence(CurState, PickupState))
			{
				SetState(PickupState);

				vel.z = vspeed;
			}

			if (ticker > 0) { ticker--; }
			else
			{
				bInvisible = true;
				touched = null;

				GoAwayAndDie();
			}
		}

		Super.Tick();
	}

	override bool ShouldStay ()
	{
		if (touched && ticker) { return true; }

		return false;
	}
}

class CKWeapon : Weapon
{
//	mixin CKPickup;
	Actor touched;
	double vspeed;
	State PickupState;
	int ticker;

	Property VSpeed:vspeed;

	Default
	{
		Scale 2.0;
		+NOGRAVITY

		//$Category Commander Keen (BoA)/Weapons
		//$Color 14

		Inventory.PickupFlash "";

		CKWeapon.VSpeed 4;
	}

	override void PostBeginPlay()
	{
		SpawnPoint = pos;
		PickupState = FindState("Pickup");

		Super.PostBeginPlay();
	}

	override void Touch(Actor toucher)
	{
		if (toucher.player && !touched)
		{
			touched = toucher;
			ticker = 12;

			bDropped = false;

			Super.Touch(toucher);
		}
	}

	override void Tick()
	{
		if (touched)
		{
			if (!InStateSequence(CurState, PickupState))
			{
				SetState(PickupState);

				vel.z = vspeed;
			}

			if (ticker > 0) { ticker--; }
			else
			{
				bInvisible = true;
				touched = null;

				GoAwayAndDie();
			}
		}

		Super.Tick();
	}

	override bool ShouldStay ()
	{
		if (touched && ticker) { return true; }

		return false;
	}
}

// Player class
class KeenPlayer : PlayerPawn
{
	Default
	{
		Speed 1;
		Health 100;
		Radius 16;
		Height 56;
		Mass 100;
		PainChance 255;
		Scale 2.0;
		DamageFactor "Falling", 0.0;
		+NOSKIN

		Player.SideMove 0.5, 0.5;
		Player.ForwardMove 0.5, 0.5;
		Player.ViewBob 0.1;
		Player.DisplayName "Billy Blaze";
		Player.MorphWeapon "CKStunner";
		Player.StartItem "CKStunner";
		Player.WeaponSlot 1, "CKStunner";
	}

	States
	{
		Spawn:
			KEEN A 1;
			Loop;
		See:
			KEEN ABCD 4;
			Loop;
		See.Pogo:
			KEEN H 1 { // Temp sprites for while pogosticking!
				if (player && player.onground) { frame = 8; }
			}
			Loop;
		Missile:
			KEEN E 12;
			Goto Spawn;
		Melee:
			KEEN F 6 BRIGHT;
			Goto Missile;
		Pain:
			KEEN G 4;
			KEEN G 4 A_Pain;
			Goto Spawn;
		Death:
		XDeath:
			KEEN H 10
			{
				A_PlayerScream();
				vel = (FRandom(-5.0, 5.0), FRandom(-5.0, 5.0), FRandom(1.0, 5.0));
			}
			KEEN I 70;
			KEEN I -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		TakeInventory("BoATilt", 1);

		Super.PostBeginPlay();
	}

	// Stripped down give cheat so that we can keep the +invuse key for activating the pogostick
	override void CheatGive(String name, int amount)
	{
		int i;
		Class<Inventory> type;
		let player = self.player;

		if (player.mo == NULL || player.health <= 0)
		{
			return;
		}

		int giveall = ALL_NO;
		if (name ~== "all") { giveall = ALL_YES; }
		else if (name ~== "everything") { giveall = ALL_YES; }

		if (giveall || name ~== "health")
		{
			if (amount > 0)
			{
				health += amount;
				player.health = health;
			}
			else
			{
				player.health = health = GetMaxHealth(true);
			}

			if (!giveall) { return; }
		}


		if (giveall || name ~== "ammo")
		{
			let ammoitem = FindInventory("CKStunnerAmmo");

			if (!ammoitem)
			{
				let ammoitem = Inventory(Spawn("CKStunnerAmmo"));
				ammoitem.AttachToOwner (self);
				ammoitem.Amount = ammoitem.MaxAmount;
			}
			else if (ammoitem.Amount < ammoitem.MaxAmount)
			{
					ammoitem.Amount = ammoitem.MaxAmount;
			}

			if (!giveall) { return; }
		}

		if (giveall || name ~== "keys")
		{
			for (i = 0; i < AllActorClasses.Size(); ++i)
			{
				let type = (class<CKPuzzleItem>)(AllActorClasses[i]);
				if (type != null)
				{
					let def = GetDefaultByType (type);
					if (def.Icon.isValid())
					{
						GiveInventory(type, amount <= 0 ? def.MaxAmount : amount, true);
					}
				}
			}

			if (!giveall) { return; }
		}


		if (giveall || name ~== "weapons")
		{
			GiveInventory("CKStunner", 1);

			if (!giveall) { return; }
		}

		if (giveall) { return; }

		type = name;
		if (!type)
		{
			if (PlayerNumber() == consoleplayer)
				A_Log(String.Format("Unknown item \"%s\"\n", name));
		}
		else
		{
			if (name.left(2) ~== "CK") { GiveInventory(type, amount, true); }
			else if (PlayerNumber() == consoleplayer)
				A_Log(String.Format("Can't give item \"%s\" while you are Commander Keen!\n", name));
		}
	}

	// No running...
	override double, double TweakSpeeds (double forward, double side)
	{
		forward *= ForwardMove1;
		side *= SideMove1;

		return forward, side;
	}
}

class Billy : PowerMorph
{
	int armor;
	double savepercent;

	Default
	{
		PowerMorph.MorphStyle MRF_LOSEACTUALWEAPON | MRF_NEWTIDBEHAVIOUR | MRF_UNDOBYDEATHSAVES;
		PowerMorph.MorphFlash "Nothing"; 
		PowerMorph.UnMorphFlash "Nothing";
		PowerMorph.PlayerClass "KeenPlayer";
		Powerup.Duration 0x7FFFFFFF;
	}

	override void InitEffect() 
	{
		if (owner && owner.player)
		{
			// Save the standard Doom-style armor values.  Doesn't support Hexen armor.
			BasicArmor a = BasicArmor(owner.FindInventory("BasicArmor"));
			if (a)
			{
				armor = a.Amount;
				savepercent = a.SavePercent;
			}
		}

		Super.InitEffect();
	}

	override void EndEffect()
	{
		if (MorphedPlayer && MorphedPlayer.mo)
		{
			// Restore armor amount and savepercent
			MorphedPlayer.mo.SetInventory("BasicArmor", armor);

			BasicArmor a = BasicArmor(MorphedPlayer.mo.FindInventory("BasicArmor"));
			if (a) { a.SavePercent = savepercent; }
		}
 
		Super.EndEffect();
	}
}

// Moving Platforms
class CKPlatform : Actor
{
	Array<Actor> touchers;
	Vector3[64] offsets;

	Actor thrust;
	Class<Actor> ExhaustActor;

	double moveangle, moved, user_movedist;

	Property Exhaust:ExhaustActor;

	Default
	{
		//$Category Commander Keen (BoA)/Props
		//$Title Platform (Moving)
		//$Color 8

		Radius 46;
		Height 12;
		MaxStepHeight 0;
		Speed 4;
		+CANPASS
		+DONTTHRUST
		+NOGRAVITY
		+SOLID
		CKPlatform.Exhaust "CKPlatformThrust";
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
		Active:
			MDLA A -1;
			Stop;
		Inactive:
			MDLA A -1;
			Stop;
	}

	override void Touch(Actor toucher)
	{
		if (toucher == self || toucher.bNoGravity || toucher is "CKPlatform") { return; }
		if (toucher.pos.z > pos.z + 32.0 || toucher.pos.z < pos.z - 16) { return; }
		if (touchers.Find(toucher) == touchers.Size()) { touchers.Push(toucher); }
	}

	override void PostBeginPlay()
	{
		moveangle = angle;

		bDormant = SpawnFlags & MTF_DORMANT;

		if (bDormant) { Deactivate(self); }
		else { Activate(self); }

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (IsFrozen() || bDormant)
		{
			Actor.Tick();

			return;
		}

		CheckTouchers();

		Vector2 newpos = pos.xy + RotateVector((Speed, 0), moveangle);
		moved += Speed;


		if (CheckMove(newpos, 0) && (user_movedist <= 0 || moved <= user_movedist))
		{
			SetOrigin((newpos, pos.z), true);

			MatchMovement();
			Actor.Tick();
		}
		else
		{
			moveangle = (moveangle + 180) % 360;
			moved = 0;
			Actor.Tick();
		}
	}

	void CheckTouchers()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
		Actor mo;

		while (mo = Actor(it.Next(false)))
		{
			if (Distance2D(mo) <= Radius + mo.Radius)
			{
				Touch(mo);
			}
		}

		it = ThinkerIterator.Create("Actor", Thinker.STAT_PLAYER);

		while (mo = Actor(it.Next(false)))
		{
			if (Distance2D(mo) <= Radius + mo.Radius)
			{
				Touch(mo);
			}
		}

		for (int i = 0; i < min(touchers.Size(), 64); i++)
		{
			if (touchers[i])
			{
				if (
					Distance3D(touchers[i]) > (Radius + touchers[i].radius) * 1.4 ||
					touchers[i].pos.z + touchers[i].height < pos.z ||
					!touchers[i].bOnMobj
				) { touchers.Delete(i); }
				else { offsets[i] = touchers[i].pos - pos; }
			}
			else { touchers.Delete(i); touchers.ShrinkToFit(); }
		}
	}

	void MatchMovement()
	{
		for (int i = 0; i < min(touchers.Size(), 64); i++)
		{
			if (
				touchers[i] && 
				(
					(Distance2D(touchers[i]) < (Radius + touchers[i].radius) * 1.4 && touchers[i].pos.z == pos.z + height) ||
					absangle(angle, AngleTo(touchers[i])) < 45 ||
					((touchers[i].bOnMobj || (touchers[i].player && touchers[i].player.jumptics == 0)) && Distance3D(touchers[i]) < radius * 2)
				)
			)
			{
				if (touchers[i].CheckMove(pos.xy + offsets[i].xy)) { touchers[i].SetOrigin(pos + offsets[i], true); }
			}
		}
	}

	override void Activate(Actor activator)
	{
		bDormant = false;
		if (ExhaustActor) { thrust = Spawn(ExhaustActor); }
		if (thrust) { thrust.master = self; }
		Super.Activate(activator);
	}

	override void Deactivate(Actor activator)
	{
		bDormant = true;
		if (thrust) { thrust.Destroy(); }
		Super.Deactivate(activator);
	}
}

class CKPlatformFalling : CKPlatform
{
	int movetimer;
	double movez;
	bool hitbottom;

	Default
	{
		//$Title Platform (Falling)
		+INTERPOLATEANGLES
		CKPlatform.Exhaust "";
	}

	override void PostBeginPlay()
	{
		SpawnPoint = pos;

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (IsFrozen() || bDormant)
		{
			Actor.Tick();

			return;
		}

		CheckTouchers();

		if (movetimer == 16)
		{
			if (pos.z == floorz)
			{
				if (touchers.Size()) { movez = 0;}
				else { movez = Speed; hitbottom = true; }
			}
			else
			{
				if (touchers.Size() || !hitbottom) { movez = -Speed; hitbottom = false; }
				else if (pos.z < SpawnPoint.z && hitbottom) { movez = Speed; }
				else { movez = 0; movetimer = 0; }
			}
		}
		else if (touchers.Size()) { movetimer++; }
		else if (level.time % 20 == 0) { movetimer = max(movetimer - 1, 0); }

		SetOrigin(pos + (0, 0, movez), true);

		MatchMovement();
		Actor.Tick();
	}
}

class CKPlatformVertical : CKPlatform
{
	double movedist, movez;
	bool hitbottom;

	Default
	{
		//$Title Platform (Vertical)
		Speed 2;
		+INTERPOLATEANGLES
		CKPlatform.Exhaust "CKPlatformEnergy";
	}

	override void PostBeginPlay()
	{
		SpawnPoint = pos;

		movedist = user_movedist ? user_movedist : 256;

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (IsFrozen() || bDormant)
		{
			Actor.Tick();

			return;
		}

		CheckTouchers();

		if (pos.z == SpawnPoint.z - movedist || pos.z == floorz || pos.z + 64.0 == ceilingz)
		{
			movez = Speed;
			hitbottom = true;
		}
		else
		{
			if (!hitbottom)
			{
				movez = -Speed;
			}
			else if (pos.z < SpawnPoint.z && hitbottom)
			{
				movez = Speed;
			}
			else
			{
				movez = 0; hitbottom = false;
			}
		}

		SetOrigin(pos + (0, 0, movez), true);

		MatchMovement();
		Actor.Tick();
	}
}

class CKPlatformThrust : Actor
{
	Default
	{
		+BRIGHT
		+FORCEXYBILLBOARD
		+NOGRAVITY
		+NOINTERACTION
		Scale 2.0;
	}

	States
	{
		Spawn:
			CKPT AB 2;
			Loop;
	}

	override void Tick()
	{
		if (CKPlatform(master) && !master.bDormant) { SetXYZ((master.pos.xy - RotateVector((master.Radius, 0), CKPlatform(master).moveangle), master.pos.z + master.height / 2)); }
		else { Destroy(); }

		Super.Tick();
	}
}

class CKPlatformEnergy : CKPlatformThrust
{
	Default
	{
		Scale 1.0;
	}

	States
	{
		Spawn:
			MDLA A 1;
			Loop;
	}

	override void Tick()
	{
		if (CKPlatform(master) && !master.bDormant) { SetXYZ(master.pos); }
		else { Destroy(); }

		Actor.Tick();
	}
}

class CKPlatformGlass : Actor
{
	int phasecounter, user_phaseoffset; // user_phaseoffset controls which phase of transparency the actor stars in.  Default is 0 (solid).

	Default
	{
		//$Category Commander Keen (BoA)/Props
		//$Title Platform (Glass, Disappearing)
		//$Color 8

		Radius 46;
		Height 12;
		MaxStepHeight 0;
		+CANPASS
		+DONTTHRUST
		+NOGRAVITY
		+SOLID
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		frame = min(user_phaseoffset, 3);

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (IsFrozen() || bDormant) { return; }

		if (phasecounter < 85) { phasecounter++; }
		else
		{
			phasecounter = 0;

			frame++;

			if (frame > 3) { frame = 0; } // Rotate through A, B, C only

			bSolid = (frame != 2); // Solid on frame A, B, and D
		}

		Super.Tick();
	}
}

// Climbable Pipes
class CKPipe : LadderBase
{
	Class<Actor> top;

	Property Top:top;

	Default
	{
		//$Category Commander Keen (BoA)/Props
		Radius 1;
		Height 0;
		-NOINTERACTION
		+SOLID
		LadderBase.ClimbRadius 24;
		LadderBase.Friction 0.75;
		LadderBase.LadderHeight -1;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		SetOrigin((pos.xy, pos.z - ladderheight), false);

		A_SetSize(-1, ladderheight);
		scale.y = -ladderheight / (64.0 / 1.2);

		if (top) { Spawn(top, pos + (0, 0, ladderheight)); }
	}
}

class CKPipeTopBlue : Actor
{
	Default
	{
		+NOINTERACTION
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
	}
}

class CKPipeTopPink : CKPipeTopBlue {}
class CKPipeTopGold : CKPipeTopBlue {}

class CKPipeBlue : CKPipe
{
	Default
	{
		//$Title Climbable Pipe (Blue)
		CKPipe.Top "CKPipeTopBlue";
	}
}

class CKPipePink : CKPipe
{
	Default
	{
		//$Title Climbable Pipe (Pink)
		CKPipe.Top "CKPipeTopPink";
	}
}

class CKPipeGold : CKPipe
{
	Default
	{
		//$Title Climbable Pipe (Gold)
		CKPipe.Top "CKPipeTopGold";
	}
}

// Enemies and NPCs
class CKLick : CKBaseEnemy
{
	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Lick
		//$Color 4

		Speed 8;
		Radius 18;
		Height 36;
		Damage 0; // Damages on touch only during attack state
		Obituary "$CK_LICK";
	}

	States
	{
		Spawn:
			CKLC AAAAABBBBB 1 CK_LickBounce();
		See:
			CKLC CCCCCDDDDD 1 CK_LickBounce();
			Goto Spawn;
		Stunned:
			CKLC H 1 A_ChangeVelocity(0, 0, 4, CVF_RELATIVE);
			CKLC H -1;
			Stop;
		Attack:
			CKLC E 2
			{
				A_PlaySound("ckeen/lick/attack");
				vel.xy = RotateVector((1, 0), angle);
				SetDamage(15);
			}
			CKLC FGFEFGF 2;
			CKLC F 0 { SetDamage(0); }
			Goto See; // Original code sent actor back to thirds state (C frame), which is why Spawn and See are split the way they are above.
	}

	void CK_LickBounce()
	{
		LookforPlayers(true);

		double dist = target ? Distance2D(target) - target.radius * 1.4 : 0;

		bool blocked = BlockingLine || BlockingMobj;

		if (!CheckMove(pos.xy + vel.xy)) { blocked = true; }

		if (pos.z == floorz || blocked || bOnMobj)
		{
			if (pos.z == floorz || bOnMobj)
			{
				if (target && dist < 32)
				{
					SetState(AttackState);
					return;
				}

				if (dist > 48) { vel.z = 8.0; }
				else { vel.z = 4.0; }
			}

			if (target) { angle = AngleTo(target); }
			else if (blocked) { angle = Random(0, 359); }

			vel.xy = RotateVector((dist > 48 ? Speed : Speed / 2, 0), angle);
		}
	}

	override void Tick()
	{
		// They would jump into tar originally and fall off of the map...  I think this is the best way to handle that.
		if (waterlevel && !stunned) { DoStun(true); }

		Super.Tick();
	}
}

class CKWormouth : CKBaseEnemy
{
	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Wormouth
		//$Color 4

		Speed 4;
		Radius 18;
		Height 36;
		Damage 0; // Damages on touch only during attack state
		Obituary "$CK_WORMOUTH";
		-SOLID
	}

	States
	{
		Spawn:
			CKSN A 1;
		See:
			CKSN AA 1 CK_WormMove();
			Loop;
		LookAround:  // There are frames missing here...  Eyes blink (the 4-tic frames) in original.
			// This will need to be redone once we have a full set of sprites for all look angles
			CKSN C 10;
			CKSN C 4; // <--
			CKSN C 10 CK_Look(90);
			CKSN A 4;
			CKSN B 10;
			CKSN B 4; // <--
			CKSN B 10 CK_Look(-90);
			CKSN A 4 A_Face(target);
			Goto See;
		Stunned:
			CKSN G -1;
			Stop;
		Attack:
			CKSN D 4
			{
				A_Face(target);
				vel.xy = RotateVector((1, 0), angle);
				bSolid = true;
				A_PlaySound("ckeen/wormouth/attack");
				SetDamage(15);
			}
			CKSN E 4;
			CKSN F 8;
			CKSN ED 4;
			CKLC F 0
			{
				if (target && Distance2D(target) < 16) { SetState(AttackState); return; }
				bSolid = false;
				SetDamage(0);
			}
			Goto See;
	}

	void CK_WormMove()
	{
		LookforPlayers(true);

		double dist = target ? Distance2D(target) - target.radius * 1.4 : 0;

		if (target && dist < 128 && Random() < 6) // Range is ~48 in original code
		{
			vel.xy *= 0;
			SetStateLabel("LookAround");
			return;
		}

		if (target && dist < 16)
		{
			SetState(AttackState);
			return;
		}

		bool blocked = BlockingLine || BlockingMobj;

		if (!TryMove(pos.xy + RotateVector((Speed, 0), angle), false)) { blocked = true; }

		if (blocked) { angle = Random(0, 359); }
	}

	void CK_Look(int angleoffset = 0, int anglerange = 30)
	{
		if (!target) { return; }

		if (absangle(angle + angleoffset, AngleTo(target)) < anglerange)
		{
			A_Face(target);
			SetState(SeeState);
		}
	}
}

class CKMine : CKBaseEnemy
{
	double moveangle, moved, user_movedist;

	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Mine
		//$Color 4

		Radius 24;
		Height 50;
		Speed 4;
		MaxStepHeight 0;
		+NOGRAVITY
		+FORCEXYBILLBOARD
	}

	States
	{
		Spawn:
			CKMN A -1;
			Stop;
		Explode:
			CKMN B 0 A_PlaySound("ckeen/mine/explode");
			CKMN BD 15 Bright A_Explode();
			Stop;
	}

	override void PostBeginPlay()
	{
		moveangle = angle;

		bDormant = SpawnFlags & MTF_DORMANT;

		if (bDormant) { Deactivate(self); }
		else { Activate(self); }

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (IsFrozen() || bDormant)
		{
			Actor.Tick();

			return;
		}

		Vector2 newpos = pos.xy + RotateVector((Speed * cos(abs(pitch)), 0), moveangle);
		moved += Speed;

		if (CheckMove(newpos, 0) && (user_movedist <= 0 || moved <= user_movedist) && waterlevel == 3 && pos.z > floorz && !bOnMobj) // Keep them underwater if they move up and down
		{

			SetOrigin((newpos, pos.z + Speed * sin(pitch)), true);
		}
		else // Swap directions
		{

			Speed = -Speed;
			moved = 0;

			SetOrigin((newpos, pos.z + Speed * sin(pitch)), true);
		}

		Super.Tick();
	}

	override void Touch(Actor toucher)
	{
		if (toucher && toucher.player && !InStateSequence(CurState, FindState("Explode")))
		{
			vel *= 0;
			bDormant = true;
			SetStateLabel("Explode");
		}
	}

	override void Activate(Actor activator)
	{
		bDormant = false;
		Super.Activate(activator);
	}

	override void Deactivate(Actor activator)
	{
		bDormant = true;
		Super.Deactivate(activator);
	}
}

class CKSmirky : CKBaseEnemy
{
	double teleportcounter;

	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Treasure Eater
		//$Color 4

		Speed 5;
		Radius 40;
		Height 64;
		Damage 0; 
		Obituary "$CK_SMIRKY";
	}

	States
	{
		Spawn:
			CKGN AAAAAAAAAABBBBBBBBBB 1;
			CKGN B 0 CK_SmirkyLook();
		See:
			CKGN CCCDDDEEEDDD 1 CK_SmirkyBounce();
			CKGN D 0 A_Stop();
			Goto Spawn;
		Stunned:
			CKGN C 3;
			CKGN F -1;
			Stop;
		Teleport:
			CKGN J 10 A_PlaySound("ckeen/smirky/teleport");
			CKGN IHG 10;
			CKGN G 10 CK_WarpToItem();
			CKGN HIJ 10 CK_CheckPickup();
			Goto See;
	}

	void CK_SmirkyLook()
	{
		if (CheckIfSeen()) { SetState(SpawnState); } // Don't do any thieving unless a player is in sight (otherwise he'll clean the level out)
	}

	void CK_SmirkyBounce()
	{
		LookForItem();

		CK_CheckPickup();

		double dist = goal ? Distance2D(goal) : 0;

		bool blocked = BlockingLine || BlockingMobj;

		if (!CheckMove(pos.xy + vel.xy)) { blocked = true; }

		if (pos.z == floorz || blocked || bOnMobj)
		{
			if (pos.z == floorz || bOnMobj)
			{
				if ((!dist || dist > radius) && teleportcounter >= 12)
				{
					vel *= 0;
					SetStateLabel("Teleport"); 
					return;
				}

				vel.z = 12.0;
			}

			if (!blocked && goal && IsVisible(goal, true)) { angle = AngleTo(goal); }
			else
			{
				angle = Random(0, 359);
				teleportcounter++;
			}

			if (dist && dist < radius) { vel.xy *= 0; } // Stop if you're at the item so that you can jump to grab it next loop
			else { vel.xy = RotateVector((Speed, 0), angle); }

			if (CheckMove(pos.xy + vel.xy)) { return; }

			if (pos.z == floorz || bOnMobj)
			{
				if (teleportcounter++ == 12)
				{
					vel *= 0;
					SetStateLabel("Teleport");
					return;
				}
			}
		}
	}

	void CK_CheckPickup()
	{
		if (!goal) { return; }

		if (goal && Distance2D(goal) < radius && Distance3D(goal) < height)
		{
			Vector3 goalpos = goal.pos;

			if (Inventory(goal).CallTryPickup(self))
			{
				Spawn("CKStolenItem", goalpos);
				A_PlaySound("ckeen/smirky/steal");
			}
		}
	}

	void CK_WarpToItem()
	{
		teleportcounter = 0;

		if (!goal) { LookForItem(); } // Last chance to check for remaining items
		if (!goal) { Destroy(); return; } // Teleport away forever if no more items are in the level to steal

		Vector2 targetpos = goal.pos.xy;

		if (!CheckMove(targetpos))
		{
			// If stuck in a line, try one time to move him out.  Otherwise he'll get out on his own next time he teleports
			if (BlockingLine)
			{
				int s = PointOnLineSide(targetpos.x, targetpos.y, BlockingLine);

				double lineangle = 0;

				if (!BlockingLine.delta.x) { lineangle = 0; }
				else if (!BlockingLine.delta.y) { lineangle = 90; }
				else { lineangle = (atan(BlockingLine.delta.y / BlockingLine.delta.x) + 270) % 360; }

				if (s) { lineangle += 180; }

				targetpos += RotateVector((Radius, 0), lineangle);
			}
		}

		SetOrigin((targetpos, (goal.pos.z - goal.floorz < 128 ? goal.floorz : goal.pos.z)), false);
	}

	int PointOnLineSide(double x, double y, line l)
	{
		return (y - l.v1.p.y) * l.delta.x + (l.v1.p.x - x) * l.delta.y > (1.0 / 65536);
	}

	void LookForItem()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
		Actor mo;
		int count;

		while (mo = Actor(it.Next()))
		{
			if (mo is "CKHealth" || mo is "CKTreasure") // Look for health and coin items first
			{
				count++;

				if (mo.pos.z - mo.floorz >= 128) { continue; } // Only go after items within jumping reach!

				if (!goal || Distance2D(mo) < Distance2D(goal))
				{
					goal = mo;
				}
			}
		}

		if (count) { return; } // If you found treasure left in the level, stop looking here

		it.Reinit();

		while (mo = Actor(it.Next())) // Otherwise, look for key gems and steal those instead so that we can't complete the map!
		{
			if (mo is "CKPuzzleItem")
			{
				if (!goal || Distance2D(mo) < Distance2D(goal))
				{
					goal = mo;
				}
			}
		}
	}
}

class CKStolenItem : Actor
{
	Default
	{
		Scale 2.0;
		+NOINTERACTION
		+NOGRAVITY
	}

	States
	{
		Spawn:
			CKST ABCD 5;
			Stop;
	}
}

class CKLindsey : CKBaseEnemy
{
	Default
	{
		//$Category Commander Keen (BoA)/NPCs
		//$Title Princess Lindsey
		//$Color 11
		Speed 0;
		FloatSpeed 1.5;
		Radius 16;
		Height 64;
		Damage 0;
		+FRIENDLY
		+NOGRAVITY
		+NOTAUTOAIMED
		Obituary "$CK_LINDSEY";
		CKBaseEnemy.StunTime 0;
	}

	States
	{
		Spawn:
			CKPL A 1;
		See:
			CKPL AAAAAAAAAABBBBBBBBBBCCCCCCCCCCDDDDDDDDDD 1 CK_Float(12, FloatSpeed); // Allow interpolated bobbing motion across 10-tic frames
			Loop;
	}

	override void PostBeginPlay()
	{
		if (pos.z - floorz < 25) { SetOrigin((pos.xy, floorz + 25), false); }

		Super.PostBeginPlay();
	}
}

class CKDopefish : CKBaseEnemy
{
	int turncounter, zdir;
	double oldangle;

	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Dopefish
		//$Color 4

		Speed 2.5;
		FloatSpeed 1.25;
		Radius 64;
		Height 128;
		Damage 0; // Damages on touch only during attack state
		+NOGRAVITY
		+NOTAUTOAIMED
		Obituary "$CK_DOPEFISH";
		CKBaseEnemy.StunTime 0;
	}

	States
	{
		Spawn:
			CKDF A 1;
		See:
			CKDF AAAAAAAAAABBBBBBBBBB 1 CK_DopefishSwim();
			Loop;
		Attack:
			CKDF C 10 // Open mouth
			{
				vel *= 0;

				// Use alternate frames...  C is original-style sprite, E and F have tongue and tooth greens
				if (Random() < 128) { frame = 4; }
				else { frame = 5; }
			}
			CKDF A 1 // Bite!
			{
				A_PlaySound("ckeen/dopefish/attack");
				vel.xy = RotateVector((1, 0), angle);
				SetDamage(15);
				if (target is "CKSchoolFish") { target.Destroy(); }
			}
			CKDF A 29; // Closed mouth
			CKDF A 0 // Reset
			{
				SetDamage(0);
				if (target && target.health > 0) { SetState(AttackState); } // Keep attacking the player without burping
			}
		Burp:
			CKDF A 30
			{
				oldangle = angle;
				A_Face(players[consoleplayer].mo); // Minimize need for angled burp sprites by making him face the console player to burp
			}
			CKDF D 30
			{
				A_PlaySound("ckeen/dopefish/burp");
				Spawn("CKBubble", pos + (RotateVector((56, -4), angle + 90), 32));
			}
			CKDF A 30;
			CKDF A 0 { angle = oldangle; }
			Goto See;
	}

	void CK_DopeFishSwim()
	{
		LookforPlayers(true);

		bool blocked = BlockingLine || BlockingMobj;

		if (BlockingMobj && BlockingMobj is "CKSchoolfish")
		{
			target = BlockingMobj;
			A_Face(target);

			SetState(AttackState);
			return;
		}

		if (!CheckMove(pos.xy + vel.xy)) { blocked = true; }

		if (turncounter > 0) { turncounter--; }

		if (blocked)
		{
			if (BlockingMobj && BlockingMobj == target)
			{
				SetState(AttackState);
				return;
			}

			if (!turncounter)
			{
				angle += Random(-115, -245);
				turncounter = 70;
			}

			zdir = Random(-1, 1);
		}
		else if (target && IsVisible(target, true))
		{
			if (!turncounter)
			{
				angle = AngleTo(target);
				turncounter = 70;
			}

			if (pos.z > target.pos.z) { zdir = -1; }
			else if (pos.z < target.pos.z) { zdir = 1; }
			else { zdir = 0; }
		}

		if (waterlevel < 3) { zdir = min(zdir, 0); } // Keep them underwater!

		vel.xy = RotateVector((Speed, 0), angle);
		vel.z = FloatSpeed * zdir;
	}
}

class CKBubble : Actor
{
	Default
	{
		Scale 2.0;
		+NOCLIP
	}

	States
	{
		Spawn:
			CKBU ABCD 10;
			Loop;
	}

	override void Tick()
	{
		if (waterlevel < 2) { Destroy(); }

		vel.z = 5;

		Super.Tick();
	}
}

class CKSchoolfish : CKBaseEnemy
{
	int turncounter, zdir, swimoffset;

	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Schoolfish
		//$Color 4

		Speed 2.5;
		FloatSpeed 1.25;
		Radius 14;
		Height 20;
		Damage 0;
		+NOGRAVITY
		+NOTAUTOAIMED
		CKBaseEnemy.StunTime 0;
	}

	States
	{
		Spawn:
			CKSF A 1;
		See:
			CKSF AAAAAAAAAABBBBBBBBBB 1 CK_SchoolfishSwim();
			Loop;
	}

	override void PostBeginPlay()
	{
		swimoffset = Random(-32, 32);
		turncounter = Random(0, 35);

		Super.PostBeginPlay();
	}

	void CK_SchoolFishSwim()
	{
		LookforPlayers(true);

		bool blocked = BlockingLine || BlockingMobj;

		if (!CheckMove(pos.xy + vel.xy)) { blocked = true; }

		if (turncounter > 0) { turncounter--; }

		if (blocked)
		{
			if (!turncounter)
			{
				angle += Random(-115, -245);
				turncounter = 70;
			}

			zdir = Random(-1, 1);
			swimoffset = Random(-32, 32);
		}
		else if (target && IsVisible(target, true))
		{
			if (!turncounter)
			{
				angle = AngleTo(target) + Random(-45, 45);
				turncounter = 70;
			}

			double swimheight = (target.player ? target.player.viewheight : target.height / 2) + swimoffset;

			if (pos.z > target.pos.z + swimheight + height) { zdir = -1; }
			else if (pos.z < target.pos.z + swimheight - height) { zdir = 1; }
			else { zdir = 0; }
		}

		if (waterlevel < 3) { zdir = min(zdir, 0); } // Keep them underwater!

		vel.xy = RotateVector((Speed, 0), angle);
		vel.z = FloatSpeed * zdir;
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (other is "CKSchoolfish" || other.player) { return false; } // Swim through other fish and the player

		return Super.CanCollideWith(other, passive);
	}	
}

class CKInchworm : CKBaseEnemy
{
	int turncounter, lasttouch, count;
	bool egg;

	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Inchworm
		//$Color 4

		Speed 6;
		Radius 18;
		Height 20;
		Damage 0;
		MaxStepHeight 0;
		+NOTAUTOAIMED
		CKBaseEnemy.StunTime 0;
	}

	States
	{
		Spawn:
			CKWM A Random(0, 15);
		See:
			CKWM AB 15 CK_InchwormMove();
			Loop;
	}

	void CK_InchwormMove()
	{
		LookforPlayers(true);

		bool blocked = BlockingLine || BlockingMobj;

		if (!TryMove(pos.xy + RotateVector((Speed, 0), angle), false)) { blocked = true; }

		if (turncounter > 0) { turncounter--; }

		if (!turncounter)
		{
			if (blocked || !target) { angle = Random(0, 359); }
			else { angle = AngleTo(target); }

			turncounter = 5;
		}
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		// Don't collide with anything, but keep count of how many inchworms are overlapping right now
		if (other is "CKInchWorm")
		{
			if (lasttouch != level.time)
			{
				lasttouch = level.time;
				count = 0;
			}

			count++;

			if (!egg && count == 11)
			{
				// This was an easter egg in CK4...  What to do here?
				Console.Printf("12 inches in a foot... lol");

				egg = true;
			}
		}

		return false;
	}
}

class CKMimRock : CKBaseEnemy
{
	bool bounced;

	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Mimrock
		//$Color 4

		Speed 6;
		Radius 24;
		Height 44;
		Damage 0;
		CKBaseEnemy.StunTime 0; // Only stunnable during moving and attack frames
	}

	States
	{
		Spawn:
			CKMM A 10;
			CKMM A 0 CK_MimRockWait();
		See:
			CKMM BCDEBC 3 CK_MimRockMove();
			Goto Spawn;
		Attack:
			CKMM F 12 { SetDamage(15); }
			CKMM G 5;
		Fall:
			CKMM H 1;
			CKMM H 5 CK_MimRockJump();
			Goto Spawn;
		Stunned:
			CKMM H 6;
			CKMM I -1;
			Stop;
	}

	void CK_MimRockWait()
	{
		stuntime = 0;
		bounced = false;
		SetDamage(0);

		LookForPlayers(true);

		if (target && !InSightOf(target) && Distance2D(target) > 48)
		{
			SetState(SeeState);
		}
		else
		{
			SetState(SpawnState);
		}
	}

	void CK_MimRockMove()
	{
		stuntime = -1; // Can be stunned while walking

		if (target && IsVisible(target, true) && !InsightOf(target) && abs(target.pos.z - pos.z) <= 80)
		{
			A_Face(target);

			if (Distance2D(target) < 128) // Double original range
			{
				vel.xy = RotateVector((5, 0), angle);
				vel.z = 10;

				SetState(AttackState);
			} 
			else
			{
				A_Chase(null, null);
			}
		}
		else { SetState(SpawnState); }
	}

	void CK_MimRockJump()
	{
		stuntime = -1; // Can be stunned while jumping

		if (pos.z == floorz || bOnMobj)
		{
			A_PlaySound("ckeen/mimrock/bounce");

			if (!bounced)
			{
				vel.z = 5;

				bounced = true;

				SetStateLabel("Fall");
			}
			else
			{
				vel.z = 0;
			}
		}
		else
		{
			SetStateLabel("Fall");
		}
	}

	bool InSightOf(Actor other)
	{
		return !(other && absangle(other.angle, other.AngleTo(self)) > 90);
	}
}

class CKSprite : CKBaseEnemy
{
	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Sprite
		//$Color 4
		Speed 0;
		FloatSpeed 2.0;
		Radius 24;
		Height 50;
		Damage 0;
		+NOGRAVITY
		Obituary "$CK_SPRITE";
		CKBaseEnemy.StunTime 0;
	}

	States
	{
		Spawn:
			CKSP A 1;
		See:
			CKSP AAAAA 1 CK_SpriteFloat();
			Loop;
		Attack:
			CKSP B 20 A_Face(target, 0, 0);
			CKSP C 20 {
				A_PlaySound("ckeen/shoot");
				A_SpawnProjectile("CKSpriteProjectile", 18.0, 0, 0, CMF_AIMDIRECTION);
			}
			CKSP C 15;
			Goto See;
	}

	override void PostBeginPlay()
	{
		if (pos.z - floorz < 25) { SetOrigin((pos.xy, floorz + 25), false); }

		Super.PostBeginPlay();
	}

	void CK_SpriteFloat()
	{
		LookForPlayers(true);

		CK_Float(16, FloatSpeed);

		if (target && IsVisible(target, true) && target.pos.z < pos.z + height && target.pos.z + target.height > pos.z) { SetState(AttackState); }

		if (pos.z > SpawnPoint.z + 16 && FloatSpeed < 0) { tics = 10; }
	}
}

class CKSpriteProjectile : Actor
{
	Default
	{
		Projectile;
		Scale 2.0;
		Speed 10;
		+BRIGHT
		+NOGRAVITY
	}

	States
	{
		Spawn:
			CKSP DEFG 5;
			Loop;
		Death:
			TNT1 A 15 A_Explode(15, 64);
			Stop;
	}
}

class CKBirdEgg : CKBaseEnemy
{
	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Blue Bird Egg
		//$Color 4
		//$Sprite CKEGA0

		Speed 0;
		Radius 21;
		Height 48;
		+NOTAUTOAIMED
		CKBaseEnemy.StunTime 0;
		CKBaseEnemy.WakeOnTouch 2;
	}

	States
	{
		Spawn:
			CKEG A 4;
			Loop;
		See:
			CKEG B -1
			{
				A_SetSize(-1, 20);

				Spawn("CKBird", pos);

				Actor shell;

				shell = Spawn("CKBirdEggShellBit", pos);
				if (shell)
				{
					shell.frame = 2;
					shell.vel.xy = RotateVector((-7, 0), Random(0, 359));
					shell.vel.z = 10;
					shell = null;
				}

				shell = Spawn("CKBirdEggShellBit", pos);
				if (shell)
				{
					shell.frame = 3;
					shell.vel.xy = RotateVector((7, 0), Random(0, 359));
					shell.vel.z = 10;
					shell = null;
				}

				shell = Spawn("CKBirdEggShellBit", pos);
				if (shell)
				{
					shell.frame = 4;
					shell.vel.z = 14;
					shell = null;
				}
			}
			Stop;
	}
}

class CKBirdEggShellBit : Actor
{
	Default
	{
		Scale 2.0;
		Gravity 1.2;
	}

	States
	{
		Spawn:
			CKEG C -1;
			Stop;
	}

}

class CKBird : CKBaseEnemy
{
	int turncounter, zdir;

	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Blue Bird
		//$Color 4

		Speed 6;
		FloatSpeed 4;
		Radius 28;
		Height 66;
		CKBaseEnemy.StunTime 120;
		CKBaseEnemy.WakeOnTouch true;
	}

	States
	{
		Spawn:
			CKEA F 60;
		See:
			CKEA FFF 1 CK_BirdWalk();
			CKEA GGGG 1 CK_BirdWalk();
			CKEA HHH 1 CK_BirdWalk();
			CKEA IIII 1 CK_BirdWalk(); // I frame rotations are completely missing!  I had to export and add the current CKEAI0.png image
			Loop;
		Fly:
			CKEA AAAABBBBCCCCDDDD 1 CK_BirdFly();
			Loop;
		Land:
			CKEA D 4;
			CKEA D 0 CK_BirdLand();
			Loop;
		Stunned:
			CKEA E 4;
			CKEA E 0 CK_BirdLand();
			Loop;
		Revive:
			CKEA EFEFE 10;
			Goto See;
	}

	void CK_BirdWalk()
	{
		LookForPlayers(true);

		if (target && (abs(pos.z - target.pos.z) > 48 || target.pos.z - target.floorz > 64))
		{
			vel.z = 2.0;

			bNoGravity = true;
			bFloat = true;
			Speed = FloatSpeed;

			A_SetSize(56, -1, true);

			SetStateLabel("Fly");
		}
		else
		{
			A_Chase(null, null);
		}
	}

	void CK_BirdFly()
	{
		double heightoffset = 0;

		LookForPlayers(true);

		bool blocked = BlockingLine || (BlockingMobj && (!target || BlockingMobj != target));

		if (!CheckMove(pos.xy + vel.xy)) { blocked = true; }

		if (turncounter > 0) { turncounter--; }

		if (blocked)
		{
			if (!turncounter)
			{
				angle += Random(90, 270);
				turncounter = 35;

				zdir = Random(-1, 1);
			}
		}
		else if (target && IsVisible(target, true))
		{
			heightoffset = target.height / 2;

			if (!turncounter)
			{
				angle = AngleTo(target);
				turncounter = 70;
			}

			if (pos.z > target.pos.z + heightoffset) { zdir = -1; }
			else if (pos.z < target.pos.z) { zdir = 1; }
			else { zdir = 0; }
		}

		vel.xy = RotateVector((Speed, 0), angle);
		vel.z = FloatSpeed * zdir;

		if (pos.z <= floorz + heightoffset && vel.z <= 0)
		{
			SetStateLabel("Land");
		}
	}

	void CK_BirdLand()
	{
		bNoGravity = false;
		bFloat = false;
		Speed = Default.Speed;

		A_SetSize(Default.Radius, -1, true);

		if (pos.z == floorz && vel.z <= 0)
		{
			vel *= 0;
			SetState(SeeState);
		}
	}
}

// Inventory Items
class CKPogoStick : CustomInventory
{
	bool active;
	double moveangle;
	State PogoState;

	Default
	{
		//$Category Commander Keen (BoA)/Items
		//$Title Pogostick
		//$Color 11

		Tag "$TAGPOGO";
		+NOGRAVITY
		Inventory.Icon "CKPOG0";
		Inventory.PickupMessage "$CK_POGO";
		Inventory.MaxAmount 1;
		Inventory.PickupSound "";
		+INVENTORY.INVBAR
		+INVENTORY.UNDROPPABLE
	}

	States
	{
		Spawn:
			CKPO G -1;
			Stop;
		Use:
			CKPO G 0
			{
				invoker.active = !invoker.active;
			}
			Fail;
	}


	override void Tick()
	{
		if (IsFrozen()) { return; }

		if (owner && active)
		{
			if (
				!owner.player || 
				owner.waterlevel > 1 ||
				owner.health <= 0 ||
				owner.player.cmd.buttons & BT_ATTACK ||
				owner.player.cmd.buttons & BT_ALTATTACK ||
				owner.player.cheats & CF_NOCLIP
			) { active = false; return; }

			if (!PogoState) { PogoState = owner.FindState("See.Pogo", true); }
			if (PogoState && !InStateSequence(owner.CurState, PogoState)) { owner.SetState(PogoState); }

			// Stomp on all other player sounds (land, grunt), since there doesn't seem to be a way to disable them temporarily
			for (int s = 0; s <= 6; s++) { owner.A_StopSound(s); }

			if (owner.player.onground)
			{
				owner.A_PlaySound("ckeen/pogo", CHAN_7);
				owner.vel.z = 12.0;
				if (owner.player.cmd.buttons & BT_JUMP) { owner.vel.z *= 1.5; }

				moveangle = owner.angle;
			}

			if (owner.player.cmd.buttons & BT_FORWARD) { speed = min(6, speed + 0.25); }
			if (owner.player.cmd.buttons & BT_BACK) { speed = max(0, speed - 0.5); }

			owner.vel.xy = RotateVector((speed, 0), moveangle);
		}
		else
		{
			if (PogoState)
			{
				if (owner)
				{
					 if (owner.health && !InStateSequence(owner.CurState, owner.SeeState)) { owner.SetState(owner.SeeState); }
					 else if (!owner.health && !InStateSequence(owner.CurState, owner.FindState("Death"))) { owner.SetStateLabel("Death"); }
				}
				PogoState = null;
			}
			speed = 0;
		}
	}
}

