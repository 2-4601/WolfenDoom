class CKBaseEnemy : Actor
{
	bool stunned, stunframes, wakeontouch;
	int stuntime, stuncounter;
	Actor confusion;
	State StunState, ReviveState, AttackState;

	// Some generic variables for CK_ internal functions.  I'd rather put these functions all in the actual classes, but DECORATE...
	int counter, counter2;
	Vector3 offset;

	Property StunTime:stuntime;
	Property StunFrames:stunframes;
	Property WakeOnTouch:wakeontouch;

	Default
	{
		Monster;
		Damage 15;
		Scale 2.0;
		Gravity 1.2;
		PainSound "ckeen/kill";
		DeathSound "ckeen/kill";
		+DONTTHRUST
		+FLOORCLIP
		+LOOKALLAROUND
		+NODAMAGE
		+NOBLOOD

		CKBaseEnemy.StunTime -1; // Default to staying stunned forever
		CKBaseEnemy.StunFrames 1; // Default to one possible frames for stun state (some actors have 2)
	}

	States
	{
		// Generic placeholder states, just in case something doesn't get defined properly
		Stunned:
			TNT1 A -1;
			Stop;
		Revive:
			TNT1 A 0 { SetState(SpawnState); }
	}

	override void PostBeginPlay()
	{
		StunState = FindState("Stunned");
		ReviveState = FindState("Revive");
		AttackState = FindState("Attack");
		if (!AttackState) { AttackState = FindState("Missile"); }
		if (!AttackState) { AttackState = FindState("Melee"); }

		Super.PostBeginPlay();
	}

	// Don't take damage, only stun if stunnable (and the player is the one that shot you)
	// Be nice and let the 'kill monsters' cheat still work (won't stop enemies from reviving, though)
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (bSolid && ((source && source.player || source is "PlayerFollower") || mod == "Massacre") && stuntime != 0 && !stunned) { DoStun(true); }

		return 0;
	}

	// Handles other actor touching this actor
	// If wake on touch is set, set this actor to See state
	// Otherwise, damage any player that is touched
	// Unless damage is set 0, then fall back to executing the actor's special
 	override void Touch(Actor toucher)
	{
		if (wakeontouch)
		{
			wakeontouch = false;
			SetStateLabel("See");
		}
		else if (damage && toucher && toucher.player)
		{
			if (!stunned) { toucher.DamageMobj(self, self, damage, "Melee"); }
		}
		else if (special) { Level.ExecuteSpecial(special, self, null, false, args[0], args[1], args[2], args[3], args[4]); }
	}

	override bool Used(Actor user)
	{
		if (self is "CKBounder")
		{
			if (!target || target != user) { user.SetOrigin(pos + (0, 0, height), true); return true; }
		}

		return false;
	}

	override void Tick()
	{
		Super.Tick();

		if (stunned) { DoStun(); }
	}

	// Force calling of the Touch function for players without resorting to using 
	// the SPECIAL flag, which changes other things with collision and interaction
	override bool CanCollideWith(Actor other, bool passive)
	{
		if (bShootable && other.player)
		{
			Touch(other);
			return true;
		}
		else if (!bShootable)
		{
			return false;
		}

		return true;
	}

	// Generic function for handling stunning of enemies
	void DoStun(bool initial = false)
	{
		if (!InStateSequence(CurState, StunState)) { SetState(StunState); }

		if (initial)
		{
			frame += Random(0, stunframes - 1); // Pick a random frame within set range
			stuncounter = stuntime;
			A_SetSize(Default.Radius, Default.Height / 2);

			stunned = true;
		}
		else
		{
			// Spawn confusion ring once the actor has hit the floor
			if (!confusion && (pos.z == floorz || bOnMobj))
			{
				vel *= 0;
				confusion = Spawn("CKConfusion", pos);
			}

			if (stuncounter > 0)
			{
				stuncounter--;
			}
			else if (stuncounter == 0)
			{
				stunned = false;
				if (confusion) { confusion.Destroy(); }

				A_SetSize(Default.Radius, Default.Height);

				SetState(ReviveState);
			}
		}
	}

	// Function to handle Mad Mushroom bouncing pattern
	void CK_MushroomBounce()
	{
		if (pos.z == floorz || bOnMobj)
		{
			counter = (counter + 1) % 3;

			if (counter == 0)
			{
				vel.z = 17.0;
			}
			else
			{
				vel.z = 10.0;
			}

			A_PlaySound("ckeen/madmushroombounce");
		}
	}

	// Function to handle Bounder bounce pattern, re-imagined in 3D space
	void CK_BounderBounce()
	{
		LookforPlayers(true);

		bool blocked = BlockingLine;

		if (
			target &&
			(
				(Distance2D(target) < (Radius + target.radius) * 1.4 && target.pos.z >= pos.z + height && target.pos.z <= pos.z + height + 16) ||
				(
					target.pos.z >= pos.z + height &&
					(target.bOnMobj || (target.player && target.player.jumptics == 0)) && 
					Distance3D(target) < radius * 2
				)
			)
		)
		{ offset = target.pos - pos; }
		else { target = null; }

		if (!blocked && BlockingMobj)
		{
			if (BlockingMobj != target) { blocked = true; }
		}

		if (bOnMobj)
		{
			Actor onmo = FindOnMobj();
			if (!onmo || onmo == target) { bOnMobj = false; }
		}

		if (pos.z == floorz || blocked || waterlevel || bOnMobj)
		{
			if (pos.z == floorz || waterlevel || bOnMobj)
			{
				counter++;
				A_PlaySound("ckeen/madmushroombounce");
				vel.z = 12.0;
			}

			if (target)
			{
				counter = 0;

				angle = target.angle;

				double scale = 1.0 - (abs(target.pitch) / 90);
				scale *= 0.75;
				scale -= 0.25;
				
				vel.xy = RotateVector((Speed * scale, 0), angle);

				if (!CheckMove(pos.xy + vel.xy))
				{
					vel.xy *= 0;
				}
			}
			else if (counter > 2 && counter2)
			{
				counter2 = 0;

				if (Random() < 200)
				{
					angle = Random(0, 359);
					vel.xy = RotateVector((Speed, 0), angle);
				}
			}
			else
			{
				counter2 = 1;
				vel.xy *= 0;
			}
		}

		if (target)
		{
			if (target.CheckMove(pos.xy + offset.xy) && CheckMove(pos.xy + vel.xy)) { target.SetOrigin(pos + (vel.xy, vel.z * gravity) + offset, true); }
		}
	}

	// Function to move an actor in a straight line until it hits something, then change directions randomly, with preference for moving toward player.
	void CK_Glide(int maxstep = 0)
	{
		LookforPlayers(true);

		if (BlockingMobj || BlockingLine || SpawnTime == level.time || (maxstep && counter >= maxstep))
		{
			if (target && IsVisible(target, true))
			{
				if (angle != AngleTo(target)) { angle = AngleTo(target); }
				else { angle += 180; }
			}
			else { angle = Random(0, 359); }

			counter = 0;
		}

		vel.xy = RotateVector((Speed, 0), angle);

		if (AttackState && Distance2D(target) <= Radius + MaxTargetRange)
		{
			SetState(AttackState);
		}

		counter++;
	}

	Actor FindOnMObj()
	{
		BlockThingsIterator it = BlockThingsIterator.Create(self, 1);

		while (it.Next())
		{
			let mo = it.thing;

			if (mo == self) { continue; } // Ignore itself

			if (mo.bSolid && pos.z == mo.pos.z + mo.height)
			{
				return mo;
			}
		}

		return null;
	}
}

class CKPlatform : Actor
{
	Array<Actor> touchers;
	Vector3[64] offsets;

	Actor thrust;
	Class<Actor> ExhaustActor;

	double moveangle, moved, user_movedist;

	Property Exhaust:ExhaustActor;

	Default
	{
		//$Category Commander Keen (BoA)/Props
		//$Title Platform (Moving)
		//$Color 8

		Radius 46;
		Height 12;
		MaxStepHeight 0;
		Speed 4;
		+CANPASS
		+DONTTHRUST
		+NOGRAVITY
		+SOLID
		CKPlatform.Exhaust "CKPlatformThrust";
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
		Active:
			MDLA A -1;
			Stop;
		Inactive:
			MDLA A -1;
			Stop;
	}

	override void Touch(Actor toucher)
	{
		if (toucher == self || toucher.bNoGravity || toucher is "CKPlatform") { return; }
		if (toucher.pos.z > pos.z + 32.0 || toucher.pos.z < pos.z - 16) { return; }
		if (touchers.Find(toucher) == touchers.Size()) { touchers.Push(toucher); }
	}

	override void PostBeginPlay()
	{
		moveangle = angle;

		bDormant = SpawnFlags & MTF_DORMANT;

		if (bDormant) { Deactivate(self); }
		else { Activate(self); }

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (IsFrozen() || bDormant)
		{
			Actor.Tick();

			return;
		}

		CheckTouchers();

		Vector2 newpos = pos.xy + RotateVector((Speed, 0), moveangle);
		moved += Speed;

		FCheckPosition checkpos;

		if (CheckMove(newpos, 0, checkpos) && (user_movedist <= 0 || moved <= user_movedist))
		{
			SetOrigin((newpos, pos.z), true);

			MatchMovement();
			Actor.Tick();
		}
		else
		{
			moveangle = (moveangle + 180) % 360;
			moved = 0;
			Actor.Tick();
		}
	}

	void CheckTouchers()
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
		Actor mo;

		while (mo = Actor(it.Next(false)))
		{
			if (Distance2D(mo) <= Radius + mo.Radius)
			{
				Touch(mo);
			}
		}

		it = ThinkerIterator.Create("Actor", Thinker.STAT_PLAYER);

		while (mo = Actor(it.Next(false)))
		{
			if (Distance2D(mo) <= Radius + mo.Radius)
			{
				Touch(mo);
			}
		}

		for (int i = 0; i < min(touchers.Size(), 64); i++)
		{
			if (touchers[i])
			{
				if (
					Distance3D(touchers[i]) > (Radius + touchers[i].radius) * 1.4 ||
					touchers[i].pos.z + touchers[i].height < pos.z ||
					!touchers[i].bOnMobj
				) { touchers.Delete(i); }
				else { offsets[i] = touchers[i].pos - pos; }
			}
			else { touchers.Delete(i); touchers.ShrinkToFit(); }
		}
	}

	void MatchMovement()
	{
		for (int i = 0; i < min(touchers.Size(), 64); i++)
		{
			if (
				touchers[i] && 
				(
					(Distance2D(touchers[i]) < (Radius + touchers[i].radius) * 1.4 && touchers[i].pos.z == pos.z + height) ||
					absangle(angle, AngleTo(touchers[i])) < 45 ||
					((touchers[i].bOnMobj || (touchers[i].player && touchers[i].player.jumptics == 0)) && Distance3D(touchers[i]) < radius * 2)
				)
			)
			{
				if (touchers[i].CheckMove(pos.xy + offsets[i].xy)) { touchers[i].SetOrigin(pos + offsets[i], true); }
			}
		}
	}

	override void Activate(Actor activator)
	{
		bDormant = false;
		if (ExhaustActor) { thrust = Spawn(ExhaustActor); }
		if (thrust) { thrust.master = self; }
		Super.Activate(activator);
	}

	override void Deactivate(Actor activator)
	{
		bDormant = true;
		if (thrust) { thrust.Destroy(); }
		Super.Deactivate(activator);
	}
}

class CKPlatformFalling : CKPlatform
{
	int movetimer;
	double movez;
	bool hitbottom;

	Default
	{
		//$Title Platform (Falling)
		+INTERPOLATEANGLES
		CKPlatform.Exhaust "";
	}

	override void PostBeginPlay()
	{
		SpawnPoint = pos;

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (IsFrozen() || bDormant)
		{
			Actor.Tick();

			return;
		}

		CheckTouchers();

		if (movetimer == 16)
		{
			if (pos.z == floorz)
			{
				if (touchers.Size()) { movez = 0;}
				else { movez = Speed; hitbottom = true; }
			}
			else
			{
				if (touchers.Size() || !hitbottom) { movez = -Speed; hitbottom = false; }
				else if (pos.z < SpawnPoint.z && hitbottom) { movez = Speed; }
				else { movez = 0; movetimer = 0; }
			}
		}
		else if (touchers.Size()) { movetimer++; }
		else if (level.time % 20 == 0) { movetimer = max(movetimer - 1, 0); }

		SetOrigin(pos + (0, 0, movez), true);

		MatchMovement();
		Actor.Tick();
	}
}

class CKPlatformVertical : CKPlatform
{
	double movedist, movez;
	bool hitbottom;

	Default
	{
		//$Title Platform (Vertical)
		Speed 2;
		+INTERPOLATEANGLES
		CKPlatform.Exhaust "CKPlatformEnergy";
	}

	override void PostBeginPlay()
	{
		SpawnPoint = pos;

		movedist = user_movedist ? user_movedist : 256;

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (IsFrozen() || bDormant)
		{
			Actor.Tick();

			return;
		}

		CheckTouchers();

		if (pos.z == SpawnPoint.z - movedist || pos.z == floorz || pos.z + 64.0 == ceilingz)
		{
			movez = Speed;
			hitbottom = true;
		}
		else
		{
			if (!hitbottom)
			{
				movez = -Speed;
			}
			else if (pos.z < SpawnPoint.z && hitbottom)
			{
				movez = Speed;
			}
			else
			{
				movez = 0; hitbottom = false;
			}
		}

		SetOrigin(pos + (0, 0, movez), true);

		MatchMovement();
		Actor.Tick();
	}
}

class CKPlatformThrust : Actor
{
	Default
	{
		+BRIGHT
		+FORCEXYBILLBOARD
		+NOGRAVITY
		+NOINTERACTION
		Scale 2.0;
	}

	States
	{
		Spawn:
			CKPT AB 2;
			Loop;
	}

	override void Tick()
	{
		if (CKPlatform(master) && !master.bDormant) { SetXYZ((master.pos.xy - RotateVector((master.Radius, 0), CKPlatform(master).moveangle), master.pos.z + master.height / 2)); }
		else { Destroy(); }

		Super.Tick();
	}
}

class CKPlatformEnergy : CKPlatformThrust
{
	Default
	{
		Scale 1.0;
	}

	States
	{
		Spawn:
			MDLA A 1;
			Loop;
	}

	override void Tick()
	{
		if (CKPlatform(master) && !master.bDormant) { SetXYZ(master.pos); }
		else { Destroy(); }

		Actor.Tick();
	}
}

class CKPlatformGlass : Actor
{
	int phasecounter, user_phaseoffset; // user_phaseoffset controls which phase of transparency the actor stars in.  Default is 0 (solid).

	Default
	{
		//$Category Commander Keen (BoA)/Props
		//$Title Platform (Glass, Disappearing)
		//$Color 8

		Radius 46;
		Height 12;
		MaxStepHeight 0;
		+CANPASS
		+DONTTHRUST
		+NOGRAVITY
		+SOLID
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		frame = min(user_phaseoffset, 3);

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (IsFrozen() || bDormant) { return; }

		if (phasecounter < 85) { phasecounter++; }
		else
		{
			phasecounter = 0;

			frame++;

			if (frame > 3) { frame = 0; } // Rotate through A, B, C only

			bSolid = (frame != 2); // Solid on frame A, B, and D
		}

		Super.Tick();
	}
}

class CKPipe : LadderBase
{
	Default
	{
		//$Category Commander Keen (BoA)/Props
		Radius 1;
		Height 0;
		-NOINTERACTION
		+SOLID
		LadderBase.ClimbRadius 24;
		LadderBase.Friction 0.75;
		LadderBase.LadderHeight -1;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		SetOrigin((pos.xy, floorz + 32), false);
		A_SetSize(-1, ladderheight);
		scale.y = -ladderheight / 132.0;
	}
}

class CKPipeBlue : CKPipe
{
	Default
	{
		//$Title Climbable Pipe (Blue)
	}
}

class CKPipePink : CKPipe
{
	Default
	{
		//$Title Climbable Pipe (Pink)
	}
}

class CKLick : CKBaseEnemy
{
	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Lick
		//$Color 4

		Speed 8;
		Radius 18;
		Height 36;
		Damage 0; // Damages on touch only during attack state
		Obituary "$CK_LICK";
	}

	States
	{
		Spawn:
			CKLC AAAAABBBBB 1 CK_LickBounce();
		See:
			CKLC CCCCCDDDDD 1 CK_LickBounce();
			Goto Spawn;
		Stunned:
			CKLC H 1 A_ChangeVelocity(0, 0, 4, CVF_RELATIVE);
			CKLC H -1;
			Stop;
		Attack:
			CKLC E 2
			{
				A_PlaySound("ckeen/lick/attack");
				vel.xy = RotateVector((1, 0), angle);
				SetDamage(15);
			}
			CKLC FGFEFGF 2;
			CKLC F 0 { SetDamage(0); }
			Goto See; // Original code sent actor back to thirds state (C frame), which is why Spawn and See are split the way they are above.
	}

	void CK_LickBounce()
	{
		LookforPlayers(true);

		double dist = target ? Distance2D(target) - target.radius * 1.4 : 0;

		bool blocked = BlockingLine || BlockingMobj;

		if (!CheckMove(pos.xy + vel.xy)) { blocked = true; }

		if (pos.z == floorz || blocked || bOnMobj)
		{
			if (pos.z == floorz || bOnMobj)
			{
				if (target && dist < 32)
				{
					SetState(AttackState);
					return;
				}

				if (dist > 48) { vel.z = 8.0; }
				else { vel.z = 4.0; }
			}

			if (target) { angle = AngleTo(target); }
			else if (blocked) { angle = Random(0, 359); }

			vel.xy = RotateVector((dist > 48 ? Speed : Speed / 2, 0), angle);
		}
	}

	override void Tick()
	{
		// They would jump into tar originally and fall off of the map...  I think this is the best way to handle that.
		if (waterlevel && !stunned) { DoStun(true); }

		Super.Tick();
	}
}

class CKWormouth : CKBaseEnemy
{
	Default
	{
		//$Category Commander Keen (BoA)/Monsters
		//$Title Wormouth
		//$Color 4

		Speed 4;
		Radius 18;
		Height 36;
		Damage 0; // Damages on touch only during attack state
		Obituary "$CK_LICK";
		-SOLID
	}

	States
	{
		Spawn:
			CKSN A 1;
		See:
			CKSN AA 1 CK_WormMove();
			Loop;
		LookAround:  // There are frames missing here...  Eyes blink (the 4-tic frames) in original.
			// This will need to be redone once we have a full set of sprites for all look angles
			CKSN C 10;
			CKSN C 4; // <--
			CKSN C 10 CK_Look(90);
			CKSN A 4;
			CKSN B 10;
			CKSN B 4; // <--
			CKSN B 10 CK_Look(-90);
			CKSN A 4 A_Face(target);
			Goto See;
		Stunned:
			CKSN G -1;
			Stop;
		Attack:
			CKSN D 4
			{
				A_Face(target);
				vel.xy = RotateVector((1, 0), angle);
				bSolid = true;
				A_PlaySound("ckeen/wormmouth/attack");
				SetDamage(15);
			}
			CKSN E 4;
			CKSN F 8;
			CKSN ED 4;
			CKLC F 0
			{
				if (target && Distance2D(target) < 16) { SetState(AttackState); return; }
				bSolid = false;
				SetDamage(0);
			}
			Goto See;
	}

	void CK_WormMove()
	{
		LookforPlayers(true);

		double dist = target ? Distance2D(target) - target.radius * 1.4 : 0;

		if (target && dist < 128 && Random() < 6) // Range is ~48 in original code
		{
			vel.xy *= 0;
			SetStateLabel("LookAround");
			return;
		}

		if (target && dist < 16)
		{
			SetState(AttackState);
			return;
		}

		bool blocked = BlockingLine || BlockingMobj;

		if (!TryMove(pos.xy + RotateVector((Speed, 0), angle), false)) { blocked = true; }

		if (blocked) { angle = Random(0, 359); }
	}

	void CK_Look(int angleoffset = 0, int anglerange = 30)
	{
		if (!target) { return; }

		if (absangle(angle + angleoffset, AngleTo(target)) < anglerange)
		{
			A_Face(target);
			SetState(SeeState);
		}
	}
}