class InvisibleBridgeBlocking : InvisibleBridge replaces InvisibleBridge
{
	Default
	{
		+DONTTHRUST
		+NOBLOOD
		+NODAMAGE
		+NOTAUTOAIMED
		+SHOOTABLE
	}
}

class ModelOpelTruckWindows : Actor
{
	Default
	{	+NOINTERACTION
		Height 56;
		DistanceCheck "scenelod";
		RenderStyle "Shaded";
		StencilColor "CC CC CC";
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
	}

	override void BeginPlay()
	{
		// STATNUM values set the order in which an actor is Ticked by the game loop.
		//  This change causes this actor to Tick *after* the pathfollower moves and
		//  the rail script has adjusted the truck model, instead of before the
		//  script runs, as would be the default behavior.
		ChangeStatNum(STAT_SCRIPTS + 1);
	}

	override void Tick()
	{
		if (master)
		{
			A_Warp(AAPTR_MASTER, flags:WARPF_COPYPITCH | WARPF_COPYINTERPOLATION | WARPF_NOCHECKPOSITION);
		}
		Super.Tick();
	}
}

class CrankModel : Actor
{
	int init, amt;

	Default
	{
		+NOGRAVITY
		Height 0;
		Radius 0;
	}

	States
	{
		Spawn:
			MDLA A 35;
		SpawnLoop:
			MDLA B 1 A_DoCrank();
			Loop;
	}

	void A_DoCrank()
	{
		if (!init) { init = amt; }
		roll = amt - init;
	}
}

class TextPaper : Actor
{
	int displaytime;

	Default
	{
		//$Category Props (Wolf3D)/Bureau
		//$Title Textpaper (usable)
		//$Color 3

		//$Arg0 "Text ID"
		//$Arg0Tooltip "Predefined texts from the LANGUAGE lump, e.g. 2 is PAPERTEXT02"
		//$Arg0Default 0
		//$Arg1 "Paper style"
		//$Arg1Tooltip "Various paper styles:\n1. White empty paper\n2. Tan empty paper\n3. White with nazi head paper\n4. Tan with nazi head paper\n5. Old used paper"
		//$Arg1Default 1
		//$Arg2 "Font style"
		//$Arg2Tooltip "Various font styles:\n1. Typewriter clean\n2. Typewriter broken\n3. Occult glyphs\n4. Handwritten"
		//$Arg2Default 1

		Radius 16;
		Height 32;
		Scale 0.25;
		RenderStyle 'Translucent';
		-SOLID
		+FLATSPRITE
		+NOGRAVITY
	}

	States
	{
		Spawn:
			TEXT A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		if (special == 80) { frame = args[3]; }
		else { frame = args[1]; }

		Super.PostBeginPlay();
	}

	override bool Used(Actor user)
	{
		if (special == 80 || (!special && args[0]))
		{
			if (displaytime < level.time) // Only run this when first pressed
			{
				if (special == 80) { Level.ExecuteSpecial(80, user, null, false, args[0], args[1], args[2], args[3], args[4]); } // Run it the old way if that's how it's set up (also allows setting other actions to run when you use the paper, still)
				else {  Level.ExecuteSpecial(80, user, null, false, -int(Name("TextPaper")), 0, args[0], args[1], args[2]); } // Otherwise pass the args as defined
			} 
			
			displaytime = level.time + 1;
			user.player.usedown = false; // Set the internal logic to think that use was not held down so that this code block will be called again
			return true; // Return true so that the usefail sound doesn't play over and over and over again
		}

		return false;
	}

	override void Tick()
	{
		if (displaytime > level.time)
		{
			alpha = max(alpha - 0.06, 0);
		}
		else
		{
			alpha = min(alpha + 0.02, 1.0);
		}

		Super.Tick();
	}
}

class US_ShermanCannon : Actor
{
	Default
	{
		+DONTSPLASH
		+FLOORCLIP
		+NOGRAVITY
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
	}
}

class US_ShermanDead : Actor
{
	Default
	{
		Radius 88;
		Height 96;
		Mass 0x7ffffff;
		+FLOORCLIP
		+NOBLOOD
		+NOBLOODDECALS
		+NODAMAGE
		+NOTAUTOAIMED
		+SHOOTABLE
		+SOLID
		BloodType "TankSpark";
	}
	
	States
	{
	Spawn:
		MDLA A 12 A_SpawnProjectile("TankSmoke",58,0,random(0,360),2,random(70,130));
		Loop;
	}
}

class US_ShermanTurret : Actor
{
	Actor gun;

	Default
	{
		Height 32;
		+CANPASS
		+DONTSPLASH
		+FLOORCLIP
		+NOGRAVITY
		+SOLID
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		bool sp = false;

		while (!gun) { [sp, gun] = A_SpawnItemEx("US_ShermanCannon", 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (gun)
		{
			gun.angle = angle;
			gun.SetOrigin(self.pos + (RotateVector((32, 0), angle), 18.0), true);

			gun.bSolid = bSolid;
			gun.bInvisible = bInvisible;
		}
	}

	override void OnDestroy()
	{
		if (gun) { gun.Destroy(); }
	}
}

class US_Sherman : Actor
{
	Actor turret;
	int savedhealth;

	Default
	{
		//$Category Models (Wolf3D)/Vehicles
		//$Title Driveable US M4 Sherman Tank
		//$Color 3
		DistanceCheck "scenelod";
		Radius 64;
		Height 64;
		Mass 0x7ffffff;
		+SOLID
		+CANPASS
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
		Death:
			TNT1 A 1 DoDeath();
			Stop;
	}

	override void PostBeginPlay()
	{
		bool sp = false;

		while (!turret) { [sp, turret] = A_SpawnItemEx("US_ShermanTurret", 16.5 * cos(angle), 16.5 * sin(angle), Height, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (master && master.player)
		{
			double moving = master.player.cmd.forwardmove;

			if (moving != 0)
			{
				double movespeed = master.vel.length();

				int dir = moving > 0 ? 1 : -1; // Trample both forward and backwards, depending on which direction you're moving
				double dmg = movespeed * 0.625; // Top speed gives ~100 damage

				bool sp;
				Actor t;

				[sp, t] = A_SpawnItemEx("Trample", scale.x * 128 * dir, 0, height / 2 - 16, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE);

				if (t)
				{
					t.target = master; // Set the player as the Trample actor's target, because it uses A_Explode, which defaults to treating the actor's target as the originator (and doesn't damage it)
					Trample(t).dmg = int(dmg);
				}
			}
		}

		if (turret)
		{
			turret.bSolid = bSolid;
			turret.bInvisible = bInvisible;
		}

		Super.Tick();
	}

	override bool Used(Actor user)
	{
		if (bDormant || (master && master.player)) { return false; }

		let p = user.player;

		if (p)
		{
			bSolid = False;

			p.mo.SetOrigin(pos, false);

			if (turret) { p.mo.angle = turret.angle; }
			else { p.mo.angle = angle; }

			p.mo.tracer = self;

			user.GiveInventory("Sherman", 1);
			return true;
		}
		return false;
	}

	void DoDeath()
	{
		if (turret) { turret.Destroy(); }

		A_PlaySound("weapons/explode", CHAN_AUTO, 1.0, FALSE, ATTN_IDLE);

		for (int i = 0; i < 20; i++)
		{
			A_SpawnItemEx("Debris_Tank2", random(88, 96), random(88, 96), random(88, 112), random(1, 3), random(1, 3), random(1, 3), random(0, 360), SXF_CLIENTSIDE);
			A_SpawnItemEx("Debris_GlassShard_Large", random(88, 96), random(88, 96), random(96, 128), random(1, 3), random(1, 3), random(1, 3), random(0, 360), SXF_CLIENTSIDE);
		}
		
		A_SpawnItemEx("Nuke", 0, 0, 5, 0, 0, 0, 0, SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
		A_SpawnItemEx("KaBoomer", 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERPOINTERS);
		A_SpawnItemEx("GeneralExplosion_Large", 56, 0, 32);

		Actor dead = Spawn("US_ShermanDead", pos);

		dead.angle = angle;
		dead.pitch = pitch;
		dead.roll = roll;
	}
}

class Nothing : Actor
{
	Default
	{
		+NOBLOCKMAP
	}

	States
	{
		Spawn:
			TNT1 A 1;
			Stop;
	}
}

class Sherman : PowerMorph
{
	Default
	{
		PowerMorph.MorphStyle MRF_LOSEACTUALWEAPON | MRF_NEWTIDBEHAVIOUR | MRF_UNDOBYDEATHSAVES;
		PowerMorph.MorphFlash "Nothing"; // Why isn't there an option to NOT spawn fog at all?
		PowerMorph.UnMorphFlash "Nothing";
		PowerMorph.PlayerClass "ShermanPlayer";
		Powerup.Duration 0x7FFFFFFF;
	}

	override void EndEffect()
	{
		if (MorphedPlayer)
		{
			let tank = ShermanPlayer(MorphedPlayer.mo);

			if (tank)
			{
				if  (tank.treads)
				{
					tank.treads.bSolid = true;
					tank.treads.master = null;
					if (US_Sherman(tank.treads)) { US_Sherman(tank.treads).savedhealth = tank.health; }
				}
				if  (tank.turretcamera) { tank.turretcamera.Destroy(); }

				// Restore pitch clamping, since this doesn't get reset otherwise
				MorphedPlayer.MinPitch = -90;
				MorphedPlayer.MaxPitch = 90;

				if (tank.health <= 0) { tank.treads.SetStateLabel("Death"); }

				if (tank.turret) { MorphedPlayer.mo.SetOrigin(tank.turret.pos + (0, 0, tank.turret.height), false); } // Dump the player on top of the turret
				else { MorphedPlayer.mo.SetOrigin(tank.pos + (0, 0, tank.height), false); } // Dump the player on top of the body of the tank
			}
		}

		Super.EndEffect();
	}
}

class Trample : BlastEffect
{
	int dmg;
	int flags;

	Default
	{
		DamageType 'Trample';
		Damage 5;
		Height 56;
		Radius 56;
		+NOGRAVITY
	}

	States
	{
		Spawn:
			TNT1 A 0;
		Death:
			"####" # 20 A_Explode(dmg == 0 ? damage : dmg, int(Radius), flags, FALSE, int(Radius));
			Stop;
	}
}