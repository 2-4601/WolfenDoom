class InvisibleBridgeBlocking : InvisibleBridge replaces InvisibleBridge
{
	Default
	{
		+DONTTHRUST
		+NOBLOOD
		+NODAMAGE
		+NOTAUTOAIMED
		+SHOOTABLE
	}
}

class ModelOpelTruckWindows : Actor
{
	Default
	{
		Height 56;
		DistanceCheck "scenelod";	
		+NOINTERACTION
		RenderStyle "Shaded";
		StencilColor "CC CC CC";
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
	}

	override void BeginPlay()
	{
		// STATNUM values set the order in which an actor is Ticked by the game loop.
		//  This change causes this actor to Tick *after* the pathfollower moves and
		//  the rail script has adjusted the truck model, instead of before the
		//  script runs, as would be the default behavior.
		ChangeStatNum(STAT_SCRIPTS + 1);
	}

	override void Tick()
	{
		if (master)
		{
			A_Warp(AAPTR_MASTER, flags:WARPF_COPYPITCH | WARPF_COPYINTERPOLATION | WARPF_NOCHECKPOSITION);
		}
		Super.Tick();
	}
}

class CrankModel : Actor
{
	int init, amt;

	Default
	{
		+NOGRAVITY
		Height 0;
		Radius 0;
	}

	States
	{
		Spawn:
			MDLA A 35;
		SpawnLoop:
			MDLA B 1 A_DoCrank();
			Loop;
	}

	void A_DoCrank()
	{
		if (!init) { init = amt; }
		roll = amt - init;
	}
}

class TextPaper : Actor
{
	int displaytime;

	Default
	{
		//$Category Props (Wolf3D)/Bureau
		//$Title Textpaper (usable)
		//$Color 3

		//$Arg0 "Text ID"
		//$Arg0Tooltip "Predefined texts from the LANGUAGE lump, e.g. 2 is PAPERTEXT02"
		//$Arg0Default 0
		//$Arg1 "Paper style"
		//$Arg1Tooltip "Various paper styles:\n1. White empty paper\n2. Tan empty paper\n3. White with nazi head paper\n4. Tan with nazi head paper\n5. Old used paper"
		//$Arg1Default 1
		//$Arg2 "Font style"
		//$Arg2Tooltip "Various font styles:\n1. Typewriter clean\n2. Typewriter broken\n3. Occult glyphs\n4. Handwritten"
		//$Arg2Default 1

		Radius 16;
		Height 32;
		Scale 0.25;
		RenderStyle 'Translucent';
		-SOLID
		+FLATSPRITE
		+NOGRAVITY
	}

	States
	{
		Spawn:
			TEXT A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		if (special == 80) { frame = args[3]; }
		else { frame = args[1]; }

		Super.PostBeginPlay();
	}

	override bool Used(Actor user)
	{
		if (special == 80 || (!special && args[0]))
		{
			if (displaytime < level.time) // Only run this when first pressed
			{
				if (special == 80) { Level.ExecuteSpecial(80, user, null, false, args[0], args[1], args[2], args[3], args[4]); } // Run it the old way if that's how it's set up (also allows setting other actions to run when you use the paper, still)
				else {  Level.ExecuteSpecial(80, user, null, false, -int(Name("TextPaper")), 0, args[0], args[1], args[2]); } // Otherwise pass the args as defined
			} 
			
			displaytime = level.time + 1;
			user.player.usedown = false; // Set the internal logic to think that use was not held down so that this code block will be called again
			return true; // Return true so that the usefail sound doesn't play over and over and over again
		}

		return false;
	}

	override void Tick()
	{
		if (displaytime > level.time)
		{
			alpha = max(alpha - 0.06, 0);
		}
		else
		{
			alpha = min(alpha + 0.02, 1.0);
		}

		Super.Tick();
	}
}

class FlattenableProp : Actor // Tall grass/rye, etc. that can be trampled down
{
	int touchtime;
	int fallpitch;

	Default
	{
		+NOBLOOD
		+NODAMAGE
		+NOTAUTOAIMED
		+SHOOTABLE
		+SOLID
		+SPECIAL
	}

	override void PostBeginPlay()
	{
		A_SetSize(Radius, 1);

		Super.PostBeginPlay();
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		Touch(inflictor);

		return 0; // No actual damage to the actor
	}

	override void Touch(Actor toucher)
	{
		if (!toucher) { return; }

		touchtime++;
		bFlatSprite = true;

		if (touchtime < 5) { angle = AngleTo(toucher) + 180; }
		if (!fallpitch) { fallpitch = Random(70, 85); }

		pitch = clamp(-fallpitch + touchtime * 15, -fallpitch, 0);

		if (pitch == -fallpitch)
		{
			bSpecial = false;
			bSolid = false;
			bShootable = false;
		}
	}
}

class ActorPositionable : Actor
{
	enum RotationFlags
	{
		ROT_MatchAngle,
		ROT_MatchPitch,
		ROT_MatchRoll
	};

	Vector3 spawnoffset;
	Vector3 offset;

	override void PostBeginPlay()
	{
		spawnoffset = pos - master.pos;

		Vector2 temp = RotateVector((spawnoffset.x, spawnoffset.y), -master.angle);
		spawnoffset = (temp.x, temp.y, spawnoffset.z);

		Super.PostBeginPlay();
	}

	void RotateWithMaster(int flags = ROT_MatchAngle | ROT_MatchPitch | ROT_MatchRoll)
	{
		Vector2 temp;

		// Keep the actor in the correct position, regardless of pitch/roll of the master actor
		if (master)
		{
			if (spawnoffset != (0, 0, 0))
			{
				temp = RotateVector((spawnoffset.y, spawnoffset.z), master.roll);
				offset = (spawnoffset.x, temp.x, temp.y);

				temp = RotateVector((offset.x, offset.z), 360 - master.pitch);
				offset = (temp.x, offset.y, temp.y);

				temp = RotateVector((offset.x, offset.y), master.angle);
				offset = (temp.x, temp.y, offset.z);

				SetOrigin(master.pos + offset, true);
			}

			if (flags & ROT_MATCHANGLE) { angle = master.angle; }

			double delta = deltaangle(master.angle, angle);

			if (flags & ROT_MATCHPITCH) { pitch = master.roll * sin(-delta) + master.pitch * cos(delta); }
			if (flags & ROT_MATCHROLL) { roll = master.roll * cos(-delta) + master.pitch * sin(delta); }
		}
	}

	override void Tick()
	{
		RotateWithMaster();

		Super.Tick();
	}
}

class Debris : Actor
{
	Default
	{
		Height 32;
		Radius 64;
		+SOLID
		+INVISIBLE
	}

	override void PostBeginPlay()
	{
		scale.x = scale.x * Radius / 24;
		scale.y = scale.y * Height / 40;

		Actor mound = Spawn("DebrisMound", pos);
		if (mound)
		{
			mound.master = self;
		}

		SpawnRandom("DebrisGirder", Random(2, 4));
		SpawnRandom("DebrisPipe", Random(2, 10), Radius * 1.25, Radius * 0.75);
		SpawnRandom("DebrisBeam", Random(10, 15), Radius, Radius * 0.75);
		SpawnRandom("DebrisBrick", Random(10, 15), Radius * 1.5, Radius);
		SpawnRandom("DebrisChunk", Random(10, 15), Radius * 1.5, Radius);
		SpawnRandom("DebrisBottle", Random(0, 2), Radius * 1.5, Radius);
		SpawnRandom("DebrisBottle2", Random(0, 2), Radius * 1.5, Radius);

		Super.PostBeginPlay();
	}

	void SpawnRandom(Class<Actor> debrisclass, int amt = 1, float distance = -1, float mindistance = 0, bool rescale = true)
	{
		if (amt <= 0) { return; }

		if (distance < 0) { distance = Radius; }

		distance *= 2;
		amt = max(amt, int(amt * scale.x));

		for (int c = 0; c < amt; c++)
		{
			double spawnangle = Random(0, 359);
			double spawndist = mindistance + FRandom(0, distance - mindistance);
			
			Vector2 spawnpos = AngleToVector(spawnangle, spawndist);

			Actor mo = Spawn(debrisclass, pos + (spawnpos, height));
			if (mo)
			{
				mo.master = self;
				if (rescale) { mo.scale = FRandom(0.25, 1.75) * mo.scale; } 

				if (!(mo is "DebrisBase"))
				{
					mo.pitch = FRandom(-15, -atan(Height / Radius)); // Match the average height of the spawned items to the height of the pile
					mo.roll = Random(-30, 30);
					mo.angle = mo.AngleTo(self) + Random(-45, 45);

					if (mo.FindState("Death")) { mo.SetStateLabel("Death"); }
				}
			}
		}
	}
}

class DebrisBase : Actor
{
	int variants;

	Property VariantCount:variants;

	Default
	{
		Height 4;
		Radius 2;
		Mass 50;
		DebrisBase.VariantCount 1;
		DistanceCheck "scenelod";
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		frame = Random(0, variants - 1);

		pitch = Random(0, -45);
		roll = Random(-30, 30);
		angle = master ? AngleTo(master) + Random(-45, 45) : Random(0, 259);

		Super.PostBeginPlay();
	}
}

class DebrisMound : Actor
{
	Default
	{
		Radius 32;
		DistanceCheck "scenelod";
	}

	States
	{
		Spawn:
			MDLA A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		if (
			floorpic == TexMan.CheckForTexture("DEBR_G01", TexMan.Type_Any) ||
			floorpic == TexMan.CheckForTexture("textures/DEBR_G01.png", TexMan.Type_Any) ||
			floorpic == TexMan.CheckForTexture("DEBR_G02", TexMan.Type_Any) ||
			floorpic == TexMan.CheckForTexture("textures/DEBR_G02.png", TexMan.Type_Any)
		)
		{  // Only spawn the mound if we're not on a debris pile texture already
			Destroy();
			return;
		}

		if (master) { scale = master.scale; }

		MaxStepHeight = 24 * scale.x;

		double zoffset = VehicleBase.SetPitchRoll(self, Radius * (scale.x - 1), Radius * (scale.x - 1), 60, true);
		SetOrigin((pos.xy, floorz - zoffset), false);

		Super.PostBeginPlay();
	}
}

class DebrisChunk : DebrisBase
{
	Default
	{
		DebrisBase.VariantCount 3;
		DistanceCheck "scenelod";
	}

	override void PostBeginPlay()
	{
		bNoGravity = true;
		SetOrigin((pos.xy, floorz + 8 * cos(pitch) * cos(roll)), false);

		Super.PostBeginPlay();
	}
}

class DebrisPipe : DebrisBase
{
	Default
	{
		Mass 100;
		DebrisBase.VariantCount 6;
		DistanceCheck "scenelod";
	}

	override void PostBeginPlay()
	{
		scale *= FRandom(0.5, 1.0);

		Super.PostBeginPlay();
	}
}

class DebrisBeam : DebrisBase
{
	Default
	{
		Mass 150;
		DistanceCheck "scenelod";
	}

	override void PostBeginPlay()
	{
		double dist = 32;

		if (master) { dist = Distance2D(master); }

		scale.x = scale.x * FRandom(0.75, dist * 2 / 64);
		scale.y = scale.y * FRandom(0.5, 1.5);

		Super.PostBeginPlay();
	}
}

class DebrisGirder : DebrisBase
{
	Default
	{
		Mass 300;
		DistanceCheck "scenelod";
	}

	override void PostBeginPlay()
	{
		scale.x = scale.x * FRandom(0.5, 1.5);

		Super.PostBeginPlay();
	}
}

class DebrisBrick : DebrisBase 
{
	Default
	{
		DistanceCheck "scenelod";
	}
}

class DebrisBottle : DebrisChunk
{
	Default
	{
		DebrisBase.VariantCount 2;
		DistanceCheck "scenelod";
		RenderStyle "Translucent";
		Alpha 0.95;
	}
}

class DebrisBottle2 : DebrisBottle
{
	Default
	{
		DistanceCheck "scenelod";
	}
}

class JunkPile1 : Debris
{
	Default
	{
		//$Category Props (Wolf3D)/Street
		//$Title Junk Pile (middle)
		//$Color 3
	
		Radius 25;
		Height 20;
		+SOLID
	}
}

class JunkPile2 : JunkPile1
{
	Default
	{
		//$Title Junk Pile (large)
		
		Radius 28;
		Height 28;
	}
}