class EffectInfo // Should just be a struct, but we can't use structs in dynamic arrays...
{
	Actor effect;
	Class<actor> type;
	Vector3 position;
	double angle, pitch, roll;
	Vector2 scale;
	Actor master, target, tracer;
	int SpawnFlags;
	int args[5];
	int tid;
	bool dormant;
	double range;
}

// Effects get tracked in a dynamic array and culled when not in range of a player, then respawned when needed
class EffectsManager : Thinker
{
	Array<EffectInfo> effects;
	int interval;

	const cycletime = 35;

	static void Add(Actor effect, double range = -1)
	{
		if (!effect) { return; }
		if (effect.tid) { return; } // Don't add effects with a tid, because we can't guarantee they'll be spawned back in when they are activated/deactivated
		if (effect.bSolid && !effect.bNoInteraction) { return; } // Only add non-solid or non-interactive objects

		ThinkerIterator it = ThinkerIterator.Create("EffectsManager", Thinker.STAT_Default);
		EffectsManager manager = EffectsManager(it.Next());

		if (!manager) { manager = new("EffectsManager"); }
		if (!manager) { return; }

		manager.AddEffect(effect, range);
	}

	static void Remove(Actor effect)
	{
		if (!effect) { return; }

		ThinkerIterator it = ThinkerIterator.Create("EffectsManager", Thinker.STAT_Default);
		EffectsManager manager = EffectsManager(it.Next());

		if (!manager) { manager = new("EffectsManager"); }

		if (!manager) { return; }

		manager.RemoveEffect(effect);
	}

	uint FindEffect(Actor effect)
	{
		for (int i = 0; i < effects.Size(); i++)
		{
			if (effects[i] && effects[i].effect && effects[i].effect == effect) { return i; }
		}
		return effects.Size();
	}

	void AddEffect(Actor effect, double range = -1)
	{
		if (!effect) { return; }

		int i = FindEffect(effect);
		if (i == effects.Size()) // Only add it if it's not already there somehow.
		{
			EffectInfo this = New("EffectInfo");
			this.effect = effect;
			this.type = effect.GetClass();
			this.position = effect.pos;
			this.angle = effect.angle;
			this.pitch = effect.pitch;
			this.roll = effect.roll;
			this.scale = effect.scale;
			this.master = effect.master;
			this.target = effect.target;
			this.tracer = effect.tracer;
			this.SpawnFlags = effect.SpawnFlags;

			for (int i = 0; i < 5; i++)
			{
				this.args[i] = effect.args[i];
			}

			this.tid = effect.tid;
			this.dormant = effect.bDormant;
			this.range = range;

			effects.Push(this);
		}
		else // Otherwise just update what's there...
		{
			effects[i].position = effect.pos;
			effects[i].angle = effect.angle;
			effects[i].pitch = effect.pitch;
			effects[i].roll = effect.roll;
			effects[i].scale = effect.scale;
			effects[i].master = effect.master;
			effects[i].target = effect.target;
			effects[i].tracer = effect.tracer;
			effects[i].SpawnFlags = effect.SpawnFlags;

			for (int i = 0; i < 5; i++)
			{
				effects[i].args[i] = effect.args[i];
			}

			effects[i].tid = effect.tid;
			effects[i].dormant = effect.bDormant;
			effects[i].range = range;
		}
	}

	void RemoveEffect(Actor effect)
	{
		if (!effect) { return; }

		int i = FindEffect(effect);
		if (i == effects.Size()) { return; }

		effects.Delete(i);
		effect.Destroy();
	}

	override void Tick()
	{
		// Split up processing of the array across ticks to minimize single-tick think time
		interval = (interval + 1) % cycletime;
		double step = effects.Size() / double(cycletime);
		if (int(step) < step) { step = int(step) + 1; } 
		int start = interval * int(step);
		int end = min(effects.Size(), start + int(step));

		for (int i = start; i < end; i++)
		{
			if (i >= effects.Size()) { return; }
			if (!effects[i]) { continue; }

			if (effects[i].master && effects[i].master.bDormant)
			{
				effects.Delete(i); // If the master is deactivated, don't remember this effect anymore
				continue;
			}

			bool inrange = false;

			for (int p = 0; p < MAXPLAYERS && !inrange; p++)
			{
				if (!playeringame[p]) { continue; }

				Actor check = players[p].camera;
				if (!check) { check = players[p].mo; }
				if (!check) { continue; }

				double range = effects[i].range <= 0 ? sfxlod : effects[i].range;

				if ((level.Vec3Diff(check.pos, effects[i].position)).length() < range) { inrange = true; }
			}

			if (inrange && !effects[i].effect)
			{
				Actor effect = Actor.Spawn(effects[i].type, effects[i].position);
				if (effect)
				{
					effect.angle = effects[i].angle;
					effect.pitch = effects[i].pitch;
					effect.roll = effects[i].roll;
					effect.scale = effects[i].scale;
					effect.master = effects[i].master;
					effect.target = effects[i].target;
					effect.tracer = effects[i].tracer;
					effect.SpawnFlags = effects[i].SpawnFlags;	

					for (int a = 0; a < 5; a++)
					{
						effect.args[a] = effects[i].args[a];
					}

					effect.ChangeTID(effects[i].tid);
					if (effect.SpawnFlags & MTF_DORMANT || effects[i].dormant) { effect.SetStateLabel("Inactive"); }

					effects[i].effect = effect;
				}
			}
			else if (!inrange && effects[i].effect && !effects[i].effect.bDormant)
			{
				effects[i].effect.Destroy();
			}
		}
	}
}

class EffectSpawner : SwitchableDecoration
{
	int range;

	Property Range:range;

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, range > 0 ? range : sfxlod);
	}

	// Used directly in place of A_SpawnItemEx in DECORATE actors so that we don't have to re-write a bunch of code.
	bool, Actor SpawnParticleActor(class<Actor> missile, double xofs = 0, double yofs = 0, double zofs = 0, double xvel = 0, double yvel = 0, double zvel = 0, double angle = 0, int flags = 0, int failchance = 0, int tid = 0)
	{
		if (CheckRange(sfxlod, true)) { return false, null; }

		return A_SpawnItemEx(missile, xofs, yofs, zofs, xvel, yvel, zvel, angle, flags, failchance, tid);
	}
}

class EffectBase : SimpleActor // Rarely used; only for infinitely looping effects actors that are placed directly in-editor (e.g., PollenAir)
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, sfxlod);
	}
}

class GrassBase : SimpleActor
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, grasslod);
	}
}

class SceneryBase : Actor
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, scenelod);
	}

	// Used directly in place of A_SpawnItemEx in DECORATE actors so that we don't have to re-write a bunch of code.
	bool, Actor SpawnParticleActor(class<Actor> missile, double xofs = 0, double yofs = 0, double zofs = 0, double xvel = 0, double yvel = 0, double zvel = 0, double angle = 0, int flags = 0, int failchance = 0, int tid = 0)
	{
		if (CheckRange(sfxlod, true)) { return false, null; }

		return A_SpawnItemEx(missile, xofs, yofs, zofs, xvel, yvel, zvel, angle, flags, failchance, tid);
	}
}

class TreesBase : Actor
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		EffectsManager.Add(self, treeslod);
	}
}

class ParticleBase : SimpleActor
{
	int checktimer;

	States
	{
		Death:
			"####" "#" 1 A_FadeOut(0.05, FTF_REMOVE);
			Loop;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		// Set the initial check at a random tick so they don't all check at once...
		checktimer = Random(0, 35);
	}

	override void Tick()
	{
		Super.Tick();

		if (checktimer-- <= 0)
		{
			if (!level.IsPointInLevel(pos) || CheckRange(sfxlod, true)) // If it's outside the level or is out of range to be spawned, remove it
			{
				tics = 0;
				SetStateLabel("Death");
			}

			checktimer = 35; // Check once every second.
		}
	}
}

class CloudSpawner : EffectSpawner
{
	class<Actor> cloud;
	double minspeed, maxspeed;

	Default
	{
		//$Category Special Effects (BoA)
		//$Title Cloudstorm Spawner (arg1 xRadius, arg2 zRadius, arg3 Chance, arg4 Size, arg5 Color; Renderstyle, Stencilcolor and Scale are taken into account)
		//$Color 12
		//$Arg0 "Radius(x/y)"
		//$Arg0Tooltip "Radius of spawn area in map units"
		//$Arg1 "Height(z)"
		//$Arg1Tooltip "Height of spawn area in map units"
		//$Arg2 "Frequency"
		//$Arg2Tooltip "0 is always, 255 is never at a 30-tic basis"
		//$Arg3 "Size"
		//$Arg3Type 11
		//$Arg3Enum { 0 = "Small"; 1 = "Medium"; 2 = "Large"; }
		//$Arg4 "Color"
		//$Arg4Type 11
		//$Arg4Enum { 0 = "Grey (slow)"; 1 = "Tan (slow)"; 2 = "Dark (fast)"; }

		+CLIENTSIDEONLY
		+NOBLOCKMAP
		+NOCLIP
		+NOGRAVITY
		+NOINTERACTION
		+NOSECTOR
	}

	States
	{
		Spawn:
			TNT1 A 30 A_SpawnClouds();
			Loop;
		Death:
			"####" "#" 5 A_FadeOut(0.05, FTF_REMOVE);
			Loop;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		String cloudtype = "Cloud";

		Switch(args[3])
		{
			case 0:
				cloudtype = "Small" .. cloudtype;
				break;
			case 1:
				cloudtype = "Medium" .. cloudtype;
				break;
			default:
			case 2:
				cloudtype = "Large" .. cloudtype;
				break;
		}


		Switch(args[4])
		{
			default:
				cloudtype = cloudtype .. "Grey";
				minspeed = 5.0;
				maxspeed = 8.0;
				break;
			case 1:
				cloudtype = cloudtype .. "Tan";
				minspeed = 5.0;
				maxspeed = 8.0;
				break;
			case 2:
				cloudtype = cloudtype .. "Dark";
				minspeed = 40.0;
				maxspeed = 70.0;
				break;
		}

		cloud = cloudtype;
	}

	void A_SpawnClouds()
	{
		SpawnParticleActor(cloud, random(Args[0]*2, -Args[0]*2), random(Args[0]*2, -Args[0]*2), random(0, Args[1]), frandom(minspeed, maxspeed), 0, 0, random(6, -6), SXF_CLIENTSIDE | SXF_TRANSFERSCALE | SXF_TRANSFERRENDERSTYLE | SXF_TRANSFERSTENCILCOL, Args[2]);
	}
}

class SteamSpawner : EffectSpawner
{
	int zoffset;
	double velx, velz;
	int ang;
	int freq;
	String snd;
	int sndflags;
	Class<Actor> particle;

	Property Particle:particle;

	Default
	{
		//$Category Special Effects (BoA)
		//$Title Steam Spawner
		//$Color 12
		//$Sprite STEMA0
		//$Arg0 "Direction"
		//$Arg0Tooltip "0 is up, 1 is down, 2 is forward (downfacing spawners should be placed 4 map units below the ceiling)"
		//$Arg0Type 11
		//$Arg0Enum { 0 = "Up"; 1 = "Down"; 2 = "Forward"; }
		//$Arg1 "Type"
		//$Arg1Tooltip "Second argument chooses if it's a constant spawner, or spawns in bursts. Burst spawners use the third argument and play a different sound."
		//$Arg1Type 11
		//$Arg1Enum { 0 = "Constant"; 1 = "Bursts"; }
		//$Arg2 "Frequency"
		//$Arg2Tooltip "Third argument controls the frequency of the bursts (divided by 16. I.e, 128 will end up as 8). This is only used by the second argument."
		//$Arg3 "Sound"
		//$Arg3Type 11
		//$Arg3Enum { 0 = "Yes"; 1 = "No"; }
		Height 2;
		Radius 1;
		Mass 0;
		+CLIENTSIDEONLY
		+NOBLOCKMAP
		+NOGRAVITY
		+NOINTERACTION
		SteamSpawner.Particle "SteamParticle";
	}

	States
	{
		Active:
			TNT1 A 0 { bDormant = FALSE; } //mxd. DORMANT flag must be updated manually
		Spawn:
			TNT1 A 0;
			TNT1 A 1 { if (!args[1] && !args[3]) { A_StartSound(snd, 10, sndflags, 1.0); } } // Constant plays a looped sound once
		SpawnLoop:
			TNT1 A 1 {
				if (!args[1] || Random(0, 255) < freq)
				{
					velx = args[0] < 2 ? 0.1 * Random(0, 4) : 0.1 * Random(35, 40);
					velz = args[0] < 2 ? (args[0] == 1 ? -1 : 1) * 0.1 * Random(35, 40) : 0.1 * Random(-5, 5);
					ang = args[0] < 2 ? Random(0, 360) : Random(-8, 8);

					if (args[1] && !args[3]) { A_StartSound(snd, 10, sndflags, 1.0); } // Each burst plays a sound on spawn
					SpawnParticleActor(particle, 0, 0, zoffset, velx, 0, velz, ang, 128);
				}
			}
		Loop;
		Inactive:
			TNT1 A -1 {
				A_StopSound(10);
				bDormant = true;
			}
		Stop;
	}

	override void PostBeginPlay()
	{
		if (!CallACS("SteamSwitch")) { Destroy(); }
	
		snd = args[1] > 0 && args[2] < 128 ? "STEAM_BURST" : "STEAM_SMALL";
		sndflags = args[1] > 0 ? CHANF_OVERLAP : CHANF_LOOPING;

		zoffset = args[0] == 0 ? 1 : 0;
		freq = args[2] + 1 / 16; // This math is incorrect, based on the description in the args above, but is how it was originally. *shrug* Order of operations matter!

		Super.PostBeginPlay();
	}
}

class Bubble : ParticleBase
{
	int ticker;

	Default
	{
		Radius 2;
		Height 2;
		Speed 1;
		Scale 0.05;
		Alpha 0.25;
		RenderStyle "Add";
		Projectile;
		+CLIENTSIDEONLY
		+FORCEXYBILLBOARD
		+NOBLOCKMAP
		+NOCLIP
	}

	States
	{
		Spawn:
			SBUB A 1;
			Loop;
	}

	override void Tick()
	{
		if (!waterlevel) { Destroy(); }
		else if (pos.z + height == ceilingz)
		{
			ticker++;

			if (ticker > 70)
			{
				alpha -= 0.01;
				if (alpha <= 0) { Destroy(); }
			}
		}

		if (Random() < 32)
		{
			angle = Random(0, 360);
			vel.xy = RotateVector((-0.1, 0), angle);
		}

		Super.Tick();
	}
}