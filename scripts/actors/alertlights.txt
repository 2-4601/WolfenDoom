/*

  Version of standard dynamic light that spawns a helper actor that sets the
  visibility variable of any player in proximity to the light, based on the
  distance that the payer is from the center of the light

  These lights automatically replace all point lights.

*/
class AlertPointLight : PointLight replaces PointLight
{
	bool sneakables;

	override void PostBeginPlay()
	{
		sneakables = SneakableActors();

		if (!bDormant) { SpawnLight(); }

		Super.PostBeginPlay();
	}

	override void Activate(Actor activator)
	{
		Super.Activate(activator);

		if (bDormant) { DestroyLight(); }
		else { SpawnLight(); }
	}

	override void Deactivate(Actor activator)
	{
		Super.Deactivate(activator);

		if (bDormant) { DestroyLight(); }
		else { SpawnLight(); }
	}

	void SpawnLight()
	{
		if (sneakables) { A_SpawnItemEx("AlertLight", flags:SXF_SETMASTER); } // Only spawn AlertLight if there are sneakables in the level

		bDormant = false;
	}

	void DestroyLight()
	{
		A_RemoveChildren(TRUE, RMVF_MISC);

		bDormant = true;
	}

	bool SneakableActors() // Are there sneakable actors in the level?
	{
		ThinkerIterator it = ThinkerIterator.Create("StealthBase", Thinker.STAT_DEFAULT - 2); // Just iterate over the sneakable eyes - faster than all Nazi actors
		StealthBase mo;
		while (mo = StealthBase(it.Next(true)))
		{
			return true;
		}

		return false;
	}
}

/*

  Helper actor that handles changing the player's visibility value based on
  how close the player is to the center of the light.

  By default, when spawned by the point light replacement above, which sets
  itself as master to the AlertLight, this actor automatically scales itself
  to match the dynamic light's radius, and uses the brightness of the dynamic
  light to scale the visibility value that it sets for the player.

  If placed directly in-editor, argument 0 is used to set the radius of the
  visibility increase (with a fall-back to 64 units if no value is provided),
  and the brightness of the light is assumed to be 100%.

  If spawned by an actor that sets itself as the AlertLight's tracer, the
  brightness of the light is scaled based on the alpha value of the tracer
  actor.  This is used in-game by the Volumetric Light actor.

*/
class AlertLight : Actor
{
	double checkRadius;
	double oldVisibility;

	Default
	{
		//$Category Misc (Wolf3D)
		//$Title Alert Light (stealth)
		//$Color 1
		DistanceCheck "zscriptlod";
		+INVISIBLE
		+NOGRAVITY
	}

	States
	{
		Spawn:
			UNKN A 1;
		CheckForPlayer:
			UNKN A 1 A_LookEx(LOF_NOSOUNDCHECK | LOF_DONTCHASEGOAL | LOF_NOSEESOUND, 0, checkRadius * 2, 0, 360, "Illuminate");
			Loop;
		Illuminate:
			UNKN A 1 A_AddVisibility();
			Goto CheckForPlayer;
	}

	override void PostBeginPlay()
	{
		if (master) {
			checkRadius = master.args[3]; // If spawned and master is set, use parent's arg[3] as check radius
		} else {
			checkRadius = args[0]; // Otherwise, use the actor's arg[0]
		}
		if (!checkRadius) { checkRadius = 64; } // If nothing was set, use 64 map unit radius
	}

	void A_AddVisibility(int minlight = 0)
	{
		if (target)
		{
			Inventory vis = target.FindInventory("BoAVisibility");
			if (vis)
			{
				double brightness = 1;
				if (tracer) { brightness = min(tracer.alpha * 1.5, 1.0); }
				if (master) { brightness = (master.args[0] + master.args[1] + master.args[2]) / (255. * 3) * 1.25; } // Calculate the light's overall brightness

				double amount = checkRadius * 2 - Distance3d(target) + 8 + minlight; // Calculate visibility based on how close the player is to the light

				amount *= brightness; // Adjust based on brightness level

				oldVisibility = BoAVisibility(vis).extravisibility;
				BoAVisibility(vis).extravisibility  = int(oldvisibility + Max(amount - oldVisibility, 0)); // Set the new visibility - use delta in value instad of overriding so that multiple lights can be additive in visibility
			}
		}
	}
}

class SpotlightGlow : AlertLight
{
	Default
	{
		-RANDOMIZE
		+ALWAYSPUFF
		+BLOODLESSIMPACT
		+DONTSPLASH
		+INVISIBLE
		+NOBLOCKMAP
		+NOGRAVITY
		+PAINLESS
		+PUFFGETSOWNER
		+PUFFONACTORS
		DistanceCheck "sfxlod";
		Height 16;
		Radius 16;
	}

	States
	{
		Spawn:
			TNT1 A 0;
			"####" # 1 {
				A_SpawnitemEx("MeasurePuffTemp", 0, 0, 0, 0, 0, 0, 0, SXF_ISTRACER | SXF_SETMASTER | SXF_NOCHECKPOSITION);
				A_TransferPointer(AAPTR_TRACER, AAPTR_TARGET, AAPTR_MASTER, AAPTR_MASTER);
			}
			"####" # 25 Light("SpotLight");
			"####" # 0 A_LookEx(LOF_NOSOUNDCHECK | LOF_DONTCHASEGOAL | LOF_NOSEESOUND, 0, 256, 0, 360, "Illuminate");
			Stop;
		Illuminate:
			"####" # 1 A_AddVisibility(100);
			Stop;
		XDeath:
		Crash:
		Melee:
			TNT1 A 0 A_Jump(256, "Spawn");
	}

	override void PostBeginPlay()
	{
		checkRadius = 60;
	}

}

class SpotlightMount : Actor
{
	int user_minAngle;
	int user_maxAngle;
	int user_position;
	int user_sightRange;
	int user_holdTime;
	int user_direction;

	Default
	{
		//$Category Hazards (Wolf3D)
		//$Title Spotlight
		//$Color 3
		//$Arg0 "Left Swing Amount"
		//$Arg0Tooltip "Radius of turn to the left in degrees\nDefault: 0"
		//$Arg1 "Right Swing Amount"
		//$Arg1Tooltip "Radius of turn to the right in degrees\nDefault: 0"
		//$Arg2 "Script Number"
		//$Arg2Tooltip "Script to run when player enters range of spotlight\nDefault: 0"
		//$Arg3 "Script Argument 1"
		//$Arg3Tooltip "Argument to pass to script as argument 1\nDefault: 0"
		//$Arg4 "Script Argument 2"
		//$Arg4Tooltip "Argument to pass to script as argument 2\nDefault: 0"
		+DONTFALL
		+DONTTHRUST
		+NOBLOOD
		+SHOOTABLE
		+FLOORCLIP
		+DONTSPLASH
		+NOGRAVITY
		Health 100;
		Height 56;
		DistanceCheck "scenelod";
	}

	States
	{
		Spawn:
			MDLA A random(1, 35);
			"####" # 0 {
				if (pitch == 0 && args[0] == 0 && args[1] == 0) {
					A_SetPitch(90);
					A_SetArg(0, 45);
					A_SetArg(1, 45);
				}
			}
			"####" # 0 {
				user_minAngle = -args[1];
				user_maxAngle = args[0];
				user_position = 0;
				user_sightRange = 1024;
				user_direction = RandomPick(-1, 1);
				A_SpawnItemEx("SpotlightFlare", 5.0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
				A_SpawnItemEx("SpotlightBeam", 0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER | SXF_NOCHECKPOSITION | SXF_TRANSFERPITCH);
			}
			Goto Pan;
		Pan:
			"####" # 0 A_CheckRange(2048, "Pan.NoLight");
			"####" # 0 {
				CallACS("SpotLightCast", int(angle), -int(pitch), user_sightRange); //Spawns "SpotlightGlow" actor that also sets itself as spotlight's master
			}
		Pan.NoLight:
			"####" # 1 {
				if (CountProximity("PlayerPawn", 272.0, CPXF_ANCESTOR, AAPTR_MASTER)) { //Radius of 272 is based off of effective radius of the spotlight glow
					if (args[2]) {
						ACS_ExecuteAlways(args[2], 0, args[3], args[4]);
					} else {
						A_AlertMonsters(1280); //Still fall back to alerting monsters if no script number supplied.
					}
				}
				if (args[0] != 0 && args[1] != 0) {
					if (user_position >= user_maxAngle || user_position <= user_minAngle) {
						user_holdTime++;
						if (user_holdTime >= 70) {
							user_holdTime = Random(0, 35);
							user_direction = -user_direction;
							user_position = user_position + user_direction;
							A_SetAngle(angle + user_direction);
						}
					} else {
						user_position = user_position + user_direction;
						A_SetAngle(angle + user_direction);
					}
				}
			}
			Goto Pan;
		Death:
			"####" B 0 {
				A_RemoveChildren(TRUE, RMVF_EVERYTHING);
				A_SpawnItemEx("Debris_GlassShard_Medium", 0, 0, 0, random(1,3), random(1,3), random(1,3), random(0,360), SXF_CLIENTSIDE);
				A_PlaySound("GLASS5");
				A_SpawnProjectile("Spark_B1", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_W2", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_W3", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_O4", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_O5", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_O6", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_O7", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_Y8", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_Y9", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_Y10", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_Y11", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_Y12", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_Y13", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_Y14", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_Y15", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
				A_SpawnProjectile("Spark_Y16", 0, 0, random(0,360), CMF_AIMDIRECTION|CMF_BADPITCH, random(-67,-113));
			}
			"####" B -1;
			Stop;
	}
}

class SpotlightFlare : SwitchableDecoration
{
	Default
	{
		+NOBLOCKMAP
		+NOCLIP
		+NOGRAVITY
		+NOINTERACTION
		Height 16;
		Radius 16;
		Scale 0.5;
		RenderStyle "Add";
		DistanceCheck "sfxlod";
	}

	States
	{
		Spawn:
			TNT1 A 0 NoDelay A_SetScale(2.0);
		Active:
			FLAR A 1 BRIGHT;
			TNT1 A 0 A_Warp(AAPTR_MASTER, cos(pitch) * 5.0, 0, sin(pitch) * 5.0, 0, WARPF_COPYPITCH);
			Loop;
		Inactive:
			TNT1 A -1;
			Loop;
	}
}

class SpotlightBeam : Actor
{
	Default
	{
		+BRIGHT
		+NOBLOCKMAP
		+NOGRAVITY
		DistanceCheck "sfxlod";
		RenderStyle "Add";
		Alpha 0.4;
//		DynamicLight.SpotInnerAngle 15;
//		DynamicLight.SpotOuterAngle 20;
	}

	States
	{
		Spawn:
			MDLA A 1 /*Light("Spotlight")*/ {
				angle = master.angle;
				pitch = master.pitch;
				SetOrigin(master.pos, true);
			}
			Loop;
	}

}