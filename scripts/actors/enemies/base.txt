/*

  Base class that allows for handling of Boss Icons, Always-drawn health bars, 
  and for "indiscriminate" enemies to be able to see through player disguises.

  Nazi class inherits from the Base class, so includes the same functionality,
  but also adds properties to configure "sneakability" and "perception".  It 
  also includes handling for Stealth/one-hit knife attacks, and the code for 
  alerting and setting idle sneakable enemies.

  Custom Properties
	Base.BossIcon
	- String property that is used to look up the icon image that is displayed 
	  with the enemy's health bar	
	- Must be used in combination with the +BOSS flag (which enables the boss 
	  health bar to be drawn) or the Base.AlwaysDrawHealthBar property below.
	- Has no effect if the enemy is not flagged to have health bar drawn.

	Base.AlwaysDrawHealthBar
	- Boolean value that is used to tell the game if the enemy's health bar should
	  always be drawn.  
	- Does not require the +BOSS flag to be set, and can alternatively be 
	  controlled via ACS or in-editor by setting the user_DrawHealthBar variable
	- Developer note: This sets the statnum to STAT_DEFAULT - 3
	  (used to limit ThinkerIterator performance hit)

	Nazi.Sneakable
	- Boolean that controls if the enemy is a sneakable enemy or not.
	- Can also be set in-editor on a per-actor basis by setting the user_sneakable
	  variable.
	- Can be set in-game (e.g., after a cutscene using normal actors) by setting
	  the actor's state to "MakeSneakable" via ACS.

	Nazi.PerceptionTime
	- Integer value that controls how many tics a disguised player must remain in 
	  sight of this enemy before the player's disguise fails.
	- Default value is 0, meaning "can't see through disguises"
	- Used by SneakableEyesIdle actor (as seen on sneakable Gestapo)

	Nazi.PerceptionFOV
	- Integer value that controls the FOV of the enemy when trying to see through 
	  player disguises.
	- Used by SneakableEyesIdle actor (as seen on sneakable Gestapo)

  New Functions (Base class)
	A_LookThroughDisguise(int flags = 0, float minseedist = 0, float Range = 0, float maxheardist = 0, double fov = 0, statelabel label = "See")
	- Allows enemies to always and immediately "see through" player disguises, 
	  essentially by having those enemies ignore the NOTARGET flag when looking 
	  for their target.
	- Parameters are the same as for A_LookEx (https://zdoom.org/wiki/A_LookEx)
	- Should be used in place of A_Look or A_LookEx for "indiscriminate" enemies,
	  that wouldn't be fooled by a disguise, like rats, spiders, and possibly 
	  paranormal creatures.

  New Functions (Nazi class)
	A_NaziPain(int alertrange = 0, bool playsound = True)	
	- Consolidated function intended for use in Nazi class Pain states to 
	  eliminate code duplication across actors.
	- Spawns pain overlay, alerts actors within the passed range, and calls A_Pain
	  if playsound is true.

	BecomeAlerted(Actor newtarget = null)
	- Sets an idle sneakable actor to alerted, spawns alerted helper actor to 
	  continue checking the player's visibility and to manage the return-to-idle 
	  timout counters.
	- Takes one parameter - the new actor to target.
	- Used internally by SneakableEyesIdle actor

	BecomeIdle()
	- Sets an alerted sneakable actor to idle, spawns idle helper actor to look
	  for players and play idle sounds.
	- Also sets actor back to patrolling/goal chasing if a goal had been set 
	  before the actor was alerted
	- Used internally by SneakableEyesAlerted actor

	SneakableActors()
	- Returns true/false if there are actors flagged as "sneakable" in the current
	  map (Actually just counts StealthBase actors to avoid iterating over all
	  Base or Nazi class descendants and causing huge slowdown).
	- Used internally to set up sneakable handling

*/
// Base class to add ability to see through notarget to actors (e.g., mice, sharks)
class Base : Actor
{
	LookExParams SearchParams;
	String BossIcon;
	bool user_DrawHealthBar;

	Property BossIcon:BossIcon;
	Property AlwaysDrawHealthBar:user_DrawHealthBar;

	state A_LookThroughDisguise(int flags = 0, float minseedist = 0, float Range = 0, float maxheardist = 0, double fov = 0, statelabel label = "See")
	{
		// Try a normal look first!
		A_LookEx(flags, minseedist, Range, maxheardist, fov, label);

		if (!target)
		{
			// Set up view parameters for this search
			SearchParams.fov = bLookAllAround ? 360 : fov;
			SearchParams.minDist = minseedist;
			SearchParams.maxDist = Range;
			SearchParams.maxHearDist = Range;

			for (int p = 0; p < MAXPLAYERS; p++) // Iterate through all of the players and find one that's in range, ignoring NOTARGET
			{
				Actor mo = players[p].mo;

				if (mo) {
					if (!mo.bShootable || mo.health <= 0) { continue; }
					if (isFriend(mo)) { continue; }
					if (Range && Distance3d(mo) > Range) { continue; }
					if (!IsVisible(mo, false, SearchParams)) { continue; }

					let disguise = mo.FindInventory("DisguiseToken", True);
					if (!disguise) { continue; }

					target = mo;
					return ResolveState(label);
				}
			}
		}

		return ResolveState(null);
	}

	override void Tick()
	{
		if (user_DrawHealthBar) { ChangeStatNum(Thinker.STAT_DEFAULT - 3); } // Change the statnum of these actors so that ThinkerIterators can look at just this statnum and be more efficient
		Super.Tick();
	}

	// After initilization, handle skill level health alterations
	//   For each each skill level below 'normal', reduce enemy health by specified percentage
	//     So, for an enemy with 25 health normally, at the second skill level, it would have 16,
	//     and at the first skill level it would have 10 (~66% of 16) (assuming the multiplier is 2/3)
	//     This effectively takes a doberman from 3 hits with the knife to 2 on skill 1, to 1 on skill 0.
	override void PostBeginPlay()
	{
		double multiplier = 2. / 3; // Cut the health down to 2/3 its value for each skill level below normal

		if (skill < 2) { // If skill 0 or 1
			int newhealth = health;

			// Reduce the health by 1/3 for each skill level below normal
			for (int i = 0; i < 2 - skill; i++) { newhealth = int(newhealth * multiplier); }

			// Set the actor's health - cap minimum at 1 so that they don't die, just in case
			A_SetHealth(max(newhealth, 1));
		}
	}
}

// Base class for almost all enemy actors.
// Adds handling for 'sneakable' actors and stealth/critical hit kills
class Nazi : Base
{
	int user_incombat;
	int perceptionthreshold;
	int perceptionfov;
	int user_chasegoal;
	bool user_sneakable;
	Actor patrolgoal;
	String DeathDamageType;

	Property Sneakable:user_sneakable;
	Property PerceptionTime:perceptionthreshold; // How many tics the player has to be in sight before NOTARGET fails - 0 means never see through NoTarget
	Property PerceptionFOV:perceptionfov; // FOV used for NOTARGET sight checks (i.e., Gestapo and others who can see through scientist/gestapo uniforms)

	Default
	{
		Monster;
		+BOSSDEATH
		+CANBLAST //needed for kicks - ozy81
		+DONTGIB
		+DONTHARMSPECIES
		+FLOORCLIP
		+NOINFIGHTSPECIES
		+WINDTHRUST
		DamageFactor "Frag", 1.2; //increased damage from grenades & clusterbombs for Nazi related enemies - this fix TurretSoldiers [ozy81]
		Scale 0.65;
		Height 56;
		Mass 100;
		PainChance 200;
		Speed 2;
		Species "Nazi";

		Nazi.Sneakable False;
		Nazi.PerceptionTime 0;
		Nazi.PerceptionFOV 120;
	}

	States
	{
		Look:
			"####" "#" 10 A_Look();
			Loop;
		See:
			"####" "#" 0 { user_incombat = True; } //mxd
			"####" A 1 A_Chase;
			"####" AAA 1 A_Chase(null,null);
			"####" A 1 A_Chase;
			"####" AAA 1 A_Chase(null,null);
			"####" B 1 A_Chase;
			"####" B 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" BBB 1 A_Chase(null,null);
			"####" B 1 A_Chase;
			"####" BBB 1 A_Chase(null,null);
			"####" C 1 A_Chase;
			"####" CCC 1 A_Chase(null,null);
			"####" C 1 A_Chase;
			"####" CCC 1 A_Chase(null,null);
			"####" D 1 A_Chase;
			"####" D 0 A_SpawnItemEx("EnemyStep", 0, 0, 14, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			"####" DDD 1 A_Chase(null,null);
			"####" D 1 A_Chase;
			"####" DDD 1 A_Chase(null,null);
			Loop;
		Idle:
			"####" AAAAAAAA 1 A_Wander;
			"####" A 0 A_Look;
			"####" BBBBBBBB 1 A_Wander;
			"####" A 0 A_Look;
			"####" CCCCCCCC 1 A_Wander;
			"####" A 0 A_Look;
			"####" DDDDDDDD 1 A_Wander;
			"####" A 0 A_Look;
			Loop;
		Pain:
			"####" H 6 A_NaziPain(256);
			"####" H 0 A_Jump(256,"See");
		MakeSneakable:
			"####" # 0 {
				if (health <= 0 || !bShootable) { return ResolveState('null'); } // If it's dead, don't make a zombie, just remove it and hope no one notices...

				user_sneakable = true;
				BeginPlay();

				return ResolveState("Spawn");
			}
	}

	// Function to consolidate default pain state actions.  See use above - can be used to eliminate a lot of existing copy/paste.
	void A_NaziPain(int alertrange = 0, bool playsound = True)
	{
		A_SpawnItemEx("Pain_Overlay", scale.x + 3, 0, height - 8, 0, 0, 0, 0, SXF_NOCHECKPOSITION | SXF_USEBLOODCOLOR); // Spawn pain overlay blood spurt
		if (alertrange) { A_AlertMonsters(alertrange); } // Alert monsters in given range
		if (playsound) { A_Pain(); } // Play pain sound unless passed 'false'

		if (user_sneakable && bFriendly) // If we attacked a sneakable actor who wasn't alerted...
		{
			BecomeAlerted(target); // Alert that actor
		}
	}

	// Initialize actor
	override void BeginPlay()
	{
		// If it's sneakable, spawn a set of the sneakeable eyes and mark it as friendly (and make the actor never infight)
		if (user_sneakable) {
			bFriendly = True;
			bNeverTarget = True; // A bit of a hack, but it works...  Will cause issues if FRIENDLY actors ever need to interact with sneakable actors
			A_SpawnItemEx("SneakableGuardEyesIdle", 0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER | SXF_NOCHECKPOSITION, 0, tid);
			ChangeStatNum(Thinker.STAT_DEFAULT - 5); // Make these tic before the alert lights for checking logic purposes
		}
		else if (SneakableActors()) // If there are sneakable actors in the level, no Nazi actors will be targetable - fixes targeting of non-sneakables by idle (friendly) sneakables
		{ // This will break normal expected friendly monster behavior!
			bNeverTarget = True;
		}
	}

	// Hijack the damage calls in order to implement stealth kills and critical hits
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags = 0, double angle = 0)
	{
		if (user_sneakable && bDormant) { bDormant = False; } // Pain wakes up a dormant sneakable actors

		String currentDamage = (inflictor && inflictor.paintype) ? inflictor.paintype : mod; // Get the damage type
		int damageamt = Super.DamageMobj(inflictor, source, damage, mod, flags, angle); // Get the damage amount from the real DamageMobj function

		if (currentDamage ~== "SilentKnifeAttack") // If the attack was with the knife
		{
			if (user_sneakable && bFriendly) // If this is a sneakable actor who isn't active yet
			{ // Stealth kill, remove the sneakable eyes, alert a medium radius, and kill the actor
				A_Log(StringTable.Localize("$STEALTH"));
				A_RemoveChildren(TRUE, RMVF_EVERYTHING);
				bFriendly = False; // Force to not friendly so that they will count as a kill.
				SoundAlert(inflictor, false, 192);
				A_Die();
			}
			else if (user_incombat) // If the actor has already been in its See state
			{
				A_PlaySound("Nazi1/Pain", CHAN_AUTO, FRandom(0.2, 0.4), FALSE, ATTN_NORM); // Play quiet pain sound
				SoundAlert(inflictor, false, 64); //ozy - only if near // Alert small radius
			}
			else // Otherwise, this attack was the equivalent of Stealth Kill for non-sneakable enemies
			{
				user_incombat = True;
				A_Log(StringTable.Localize("$CRITICAL"));
				SoundAlert(inflictor, false, 192);
				A_Die();
			}
		}

		ACS_NamedExecuteAlways("AddExtraVisibility", 0, 200, 1); // Attacking always makes visibility increase significantly

		if (user_sneakable && bFriendly) // If we attacked a sneakable actor who wasn't alerted...
		{
			BecomeAlerted(inflictor); // Alert that actor
		}

		if (damageamt >= health) // If we killed the actor...
		{
			if (user_sneakable) // and it was a sneakable actor...
			{
				A_RemoveChildren(TRUE, RMVF_EVERYTHING); // Remove the sneakable eyes
			}

			if (perceptionthreshold > 0) // or if it was a perceptive actor...
			{
				if (BoAPlayer(source)) { BoAPlayer(source).suspicion = 0; } // Reset suspicion level to zero
			}

			DeathDamageType = currentDamage;
		}

		return damageamt; // Function returns amount of damage received by the actor
	}

	// Handling for alerting sneakable actors
	void BecomeAlerted(Actor newtarget = null)
	{
		if (health <= 0 || !bShootable) { return; } // If it's dead, don't do anything

		A_SpawnItemEx("AlertMarker", 0, 0, 64, 0, 0, 0, 0, SXF_SETMASTER);
		if (!bBoss) { A_PlaySound("axis1/sighted", CHAN_BODY); }
		else { A_PlaySound(SeeSound, CHAN_BODY); }

		A_RemoveChildren(TRUE, RMVF_EVERYTHING, "None", "Eyes"); // Get rid of the passive guard eyes
		bFriendly = False; // Set unfriendly

		if (goal)
		{
			patrolgoal = goal; // Save the navigation goal if one was set
		}

		if (!patrolgoal) // Otherwise, make a new navgoal at the actor's origin so that it can come back.
		{
			patrolgoal = Spawn("PatrolPoint", pos);
			patrolgoal.args[0] = -1;
			patrolgoal.args[1] = 0x7FFFFFFF;
			patrolgoal.angle = angle;
		}

		target = newtarget; // Set target to the player the eyes saw
		reactiontime = 0; // Make the enemy respond to seeing the player right away
		A_AlertMonsters(512); // Alert an extra-large radius
		A_SpawnItemEx("SneakableGuardEyesAlerted", 0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER | SXF_NOCHECKPOSITION, 0, tid); // Spawn active guard eyes
		if (target && target.GetSpecies() == GetSpecies()) { target = null; SetStateLabel("Spawn"); } // Don't go after same-species targets
		SetStateLabel("See"); // Go to See state and start chasing the player (or wandering if target wasn't set for some reason)
	}

	void BecomeIdle()
	{
		if (health <= 0 || !bShootable) { return; }

		A_RemoveChildren(TRUE, RMVF_EVERYTHING, "None", "Eyes"); // Get rid of the active guard eyes
		bFriendly = True;

		goal = patrolgoal; // Restore any navigation goal if there was one set
		target = patrolgoal;

		A_SpawnItemEx("SneakableGuardEyesIdle", 0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER | SXF_NOCHECKPOSITION, 0, tid);

		if (goal && target) { SetStateLabel("See"); }
		else { SetStateLabel("Spawn"); }
	}

	bool SneakableActors() // Are there sneakable actors in the level?
	{
		ThinkerIterator it = ThinkerIterator.Create("StealthBase", Thinker.STAT_DEFAULT - 2); // Just iterate over the sneakable eyes - faster than all Nazi actors
		StealthBase mo;
		while (mo = StealthBase(it.Next(true)))
		{
			return true;
		}

		return false;
	}

	override void Tick()
	{
		// If the enemy is sneakable and idle (and not patrolling), and isn't in its original location, keep it moving toward that location.
		//  NOTE: This doesn't work properly when the player has NOTARGET enabled (or is wearing a disguise and has no weapon raised).
		if (user_sneakable && bFriendly && patrolgoal && patrolgoal.args[0] == -1 && health > 0 && bShootable)
		{
			if (Distance3D(patrolgoal) <= Radius) // If at goal, clear target and goal and go to Spawn state
			{
				goal = null;
				A_ClearTarget();
				SetStateLabel("Spawn");
			}
			else // Otherwise, keep trying to get there (necessary because A_Chase clears goal and target when within MeleeRange of goal)
			{
				goal = patrolgoal;
				target = patrolgoal;
				if (!InStateSequence(CurState, SeeState)) { SetStateLabel("See"); }
			}
		}

		Super.Tick();
	}
}

//Standard Nazi enemy defaults.  
//  Handles burning and disintegration states, which shouldn't be inherited by NaziBoss class.
class NaziStandard : Nazi
{
	Default
	{
		GibHealth 30;
		SeeSound "Nazi1/Sighted";
		PainSound "Nazi1/Pain";
		DeathSound "Nazi1/Death";
	}

	States
	{
		Death.Fire:
			"####" # 0 A_SetScale(0.55);
		Death.Fire.Random: // Jump to here if you have an actor that needs a different scale set (See WereWaffenSS)
			"####" # 0 {
				DeathDamageType = "Fire"; // Because the flamethrower guards are set to this state via jump, not damage
				sprite = GetSpriteIndex(Random() < 128 ? "BURN" : "NRUB");
			}
			"####" A 5 Bright Light("ITBURNS1") { A_Wander(); }
			"####" BC 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); }
			"####" D 5 Bright Light("ITBURNS1") { A_Wander(); A_PlaySound("death/burning"); }
			"####" E 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); }
			"####" FABCD 5 Bright Light("ITBURNS2") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); }
			"####" EFAG 5 Bright Light("ITBURNS3") A_Wander();
			"####" H 5 Bright Light("ITBURNS3") A_NoBlocking(!user_sneakable);
			"####" IJK 5 Bright Light("ITBURNS2") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,16), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
			"####" LMN 5 Bright Light("ITBURNS1") A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,8), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160);
			"####" O -1;
			Stop;
		Raise:
			"####" # 35 { A_SetTics(Default.Health > 25 ? min(Default.Health / 25, 3) * 35 : 35); } // To match the medic's healing state duration
			"####" M 35;
			"####" LKJ 5;
			"####" I 5 A_Jump(256,"See");
			Stop;
		XDeath:
			SLOP A 5 {
				A_SpawnItemEx("NashGore_FlyingBlood", 0, 0, 8, random(-4, 4), random(-4, 4), random(2, 5), 0, 143, 176);
				A_SetScale(0.65);
				bCorpse = False; // So that an exploded enemy can't be resurrected
			}
			"####" BCDE 5;
			"####" F 5 A_NoBlocking(!user_sneakable);
			"####" G -1;
			Stop;
		Disintegrate:
			"####" H 5 {
				A_Scream();
				A_Playsound("astrostein/guard_death");
				A_NoBlocking(!user_sneakable);
				A_SpawnItemEx("BaseLine", random(16, -16), random(16, -16), random(0, 8), 0, 0, random(1,3), 0, 129, 0);
			}
		Disintegrate.FadeLoop:
			"####" H 1 A_FadeOut(0.02);
			Loop;
		SpriteLookups:
			BURN A 0;
			NRUB A 0;
	}
}