/*

  New Functions:
	GetLineTarget()
	- Saves reference to whatever actor is under the player's crosshair to the CrossHairTarget variable
	- Used by Status Bar code to draw boss health bars

	GetClosestForcedHealthBar()
	- Finds the closest Nazi class descendant with the user_DrawHealthBar variable set to true and saves
	  a reference to that actor to the ForcedHealthBar variable
	- Used by Status Bar code to draw always-present health bar (e.g., Nebelwerfer in Paris)

	CountAlertedSneakables()
	- Stores the number of sneakable actors that are currently alerted
	- Used internally by the status bar code to display the count of alerted sneakables

	DoTokenChecks()
	- Parent function where various inventory checks should be performed

	CheckSpriteToken(token name, standing sprite, [crouching sprite])
	- Handles sprite changing for Disguise Tokens:

		CheckSpriteToken("ScientistUniformToken", "PLSC", "PLYS")

	  This checks the player's inventory for the "ScientistUniformToken" token, and, if found, sets the
	  base sprite to PLSC if the player is standing and PLYS if the player is crouching.  Also cancels
	  out the sprite squishing if you specify a crouch sprite
	- If you don't specify a crouching sprite, the standing sprite is used and default squishing applies

	SpawnEffect(class<PlayerEffect>)
	RemoveEffect(class<PlayerEffect>)
	- Used to spawn/remove an effect actor that follows the player around (e.g., glow for FireBrand)
	- See PlayerEffect class information below
	- Checks should be performed in DoTokenChecks:

		// If current weapon is BFG9000, spawn swirlysparkles that follow the player
		if (player && player.ReadyWeapon is "BFG9000") { SpawnEffect("SwirlySparkles"); }
		else { RemoveEffect("SwirlySparkles"); }

  New Base Classes:
	PlayerEffect
	- Base class for player effects, to be spawned/removed with SpawnEffect/RemoveEffect as shown above
	- Literally just a simple actor that constantly warps to the position of its master (the player)
	- Developer note: These actors have their statnum set to STAT_DEFAULT - 4
	  (used to limit ThinkerIterator performance hit)

*/

class BoAPlayer : PlayerPawn
{
	double user_crouch;
	double user_ScaleY;
	double leveltilt, oldtilt, leveltiltangle;
	Actor CrosshairTarget;
	Actor ForcedHealthBar;
	Actor DragTarget;
	SpriteID baseSprite;
	Weapon LastWeapon;
	Line UseTarget;
	int crosshair;
	Class<Inventory> crosshairstring;

	Default
	{
		+DONTBLAST // avoid kick's blast effect while kicking at walls
		+THRUSPECIES // Needed for swimming through SharkBlockers.
		Species "Player";
		Player.MaxHealth 100; // Needed for improved vitality serum
		Player.InvulnerabilityMode "reflective";
		Player.StartItem "AstroChaingunLoaded",30;
		Player.StartItem "AstroRocketLauncherLoaded",5;
		Player.StartItem "AstroShotgunLoaded",8;
		Player.StartItem "Browning5Loaded",4;
		Player.StartItem "G43Loaded",10;
		Player.StartItem "Kar98kLoaded",5;
		Player.StartItem "Luger9mmLoaded",8;
		Player.StartItem "MP40Loaded",32;
		Player.StartItem "PanzerschreckLoaded";
		Player.StartItem "PyrolightLoaded",25;
		Player.StartItem "StenLoaded",32;
		Player.StartItem "TeslaLoaded",50;
		Player.StartItem "TrenchShotgunLoaded",8;
		Player.StartItem "Walther9mmLoaded",8;
		Player.StartItem "Stamina", 100;
		Player.StartItem "NullWeapon", 1;
		Player.StartItem "KnifeSilent";
		Player.ViewHeight 56;
		Player.AttackZOffset 24;
		Player.DisplayName "William Blazkowicz";
		Player.CrouchSprite "PLYC";
		Player.SideMove 1.0,0.5;
		Player.ForwardMove 1.0,0.5;
		Player.ViewBob 0.44;
		Player.WeaponSlot 1, "KnifeSilent", "Shovel", "Firebrand", "AstrosteinMelee";
		Player.WeaponSlot 2, "Luger9mm", "Walther9mm", "AstroLuger";
		Player.WeaponSlot 3, "TrenchShotgun", "Browning5", "AstroShotgun";
		Player.WeaponSlot 4, "MP40", "Sten", "AstroChaingun";
		Player.WeaponSlot 5, "Kar98k", "G43", "UMG43";
		Player.WeaponSlot 6, "Pyrolight", "Nebelwerfer", "AstroRocketlauncher";
		Player.WeaponSlot 7, "Panzerschreck";
		Player.WeaponSlot 8, "TeslaCannon";
		Player.WeaponSlot 0, "NullWeapon";
		Player.DamageScreenColor "ff ff ff", 1, "IceWater";
		Player.DamageScreenColor "64 00 C8", 1, "MutantPoison";
		Player.DamageScreenColor "00 5A 40", 1, "UndeadPoison";
		DamageFactor "Creepy", 0.0;
		DamageFactor "FriendlyFrag", 0.5;
		Scale 0.65;
	}

	States
	{
	Spawn:
		PLAY A 0 DoTokenChecks(); // Must run the check once here because it can miss a frame somehow otherwise.  All other states are taken care of in the Tick function.
	SpawnLoop:
		"####" A 1;
		Loop;
	See:
		PLAY ABCD 8 {   // Urgh.  So that player menu preview will show up properly...
			// The menu code looks for the See state frames and duration, but doesn't process code - It also doesn't handle "####" frames.
			// Since this return is processed before the frame is rendered, the actor will jump to the proper See state in-game without
			// screwing up the handling for disguises or ever showing the wrong sprites.
			return ResolveState("See.InGame");
		}
		Loop;
	See.InGame:
		"####" AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDD 1;
		Goto SpawnLoop;
	Pain.Electric:
		"####" G 0 {
			A_SetBlend("White", FRandom(3.25, 7.25), Random(1, 4));
			A_GiveInventory("BlurShaderControl", Random(5, 10));
		}
	Pain:
		"####" G 0 ACS_NamedExecuteWithResult("PlayerFlinch", 0);
		"####" G 4 A_Pain();
		"####" # 0 A_Jump(256, "SpawnLoop");
	Missile:
		"####" E 12;
		"####" # 0 A_Jump(256, "SpawnLoop");
	Melee:
		"####" F 6;
		"####" # 0 A_Jump(256, "Missile");
	Disintegrate: //here in order to transfer properly frames if needed - ozy81
		"####" G 0 A_Playsound("astrostein/guard_death");
		"####" G 5 A_PlayerScream();
		"####" G 0 A_NoBlocking;
		"####" G 0 A_SpawnItemEx("BaseLineSpawner", random(16, -16), random(16, -16), random(0, 8), 0, 0, random(1,3), 0, 129, 0);
		"####" GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG 1 A_FadeOut(0.02,0);
		TNT1 A -1 A_SetTranslucent(1);
		Stop;
	Death:
		"####" H 5 A_PlayerScream();
		"####" I 8;
		"####" I 1 A_PlaySound("death/bjfall");
		"####" J 5 A_NoBlocking;
		"####" K 5;
		"####" LM 2;
		"####" N -1;
		Stop;
	Death.Fire:
		"####" # 0 {sprite = GetSpriteIndex(Random() < 128 ? "BURN" : "NRUB");}
		"####" A 5 Bright Light("ITBURNS1") { A_Wander(); }
		"####" BC 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
		"####" D 5 Bright Light("ITBURNS1") { A_Wander(); A_PlaySound("death/burning"); }
		"####" E 5 Bright Light("ITBURNS1") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
		"####" FABCD 5 Bright Light("ITBURNS2") { A_Wander(); A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,32), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
		"####" EFAG 5 Bright Light("ITBURNS3") A_Wander();
		"####" H 5 Bright Light("ITBURNS3") A_Wander();
		"####" IJK 5 Bright Light("ITBURNS2") { A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,16), 1, 0, random (1, 3), random (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
		"####" LMN 5 Bright Light("ITBURNS1") { A_SpawnItemEx("FloatingCinder", random(-8,8), random(-8,8), random(0,8), 1, 0, random (1, 3), frandom (0, 360), SXF_TRANSFERPITCH | SXF_CLIENTSIDE, 160); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
	Death.Fire.Smoke:
		"####" O 0 A_Jump(32,"Death.Fire.End");
		"####" O 2 Light("ITBURNS4") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
		"####" O 4 Light("ITBURNS5") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
		"####" O 3 Light("ITBURNS6") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
		"####" O 5 Light("ITBURNS5") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
		Loop;
	Death.Fire.End:
		"####" O -1;
		Stop;
	Death.Electric:
		"####" # 0 {sprite = GetSpriteIndex(Random() < 128 ? "FIZZ" : "ZZIF");}
		"####" # 0 A_RadiusGive("BlurShaderControl", 192, RGF_PLAYERS | RGF_GIVESELF, 80);
		"####" A 5 Bright Light("TPortNormal");
		"####" BA 5 Bright Light("TPortNormal") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0));
		"####" B 5 Bright Light("TPortNormal") { A_PlaySound("death/burning"); A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0)); }
		"####" AABAB 5 Bright Light("TPortNormal") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0));
		"####" C 7 Light("TPortNormal");
		"####" DE 6 Light("TPortNormal") A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0));
		"####" FG 5 A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), random(0,56), 0, 0, frandom(0.2,1.0));
	Death.Electric.Smoke:
		"####" H 0 A_Jump(32,"Death.Electric.End");
		"####" H 2 A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
		"####" H 4 A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
		"####" H 3 A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
		"####" H 5 A_SpawnItemEx("BodySmoke", random(-3,3), random(-3,3), 0, 0, 0, frandom(0.2,1.0));
		Loop;
	Death.Electric.End:
		"####" H -1;
		Stop;
	SpriteList:
		// Any sprite not used above that is switched to by a token check must be listed here or the game will not find it!
		PLSC A 0;
		PLYS A 0;
		PLCP A 0; //camp
		PLYP A 0;
		SSOF A 0; //still not yet used nor implemented - ozy81
		Stop;
	SpriteLookups:
		BURN A 0;
		NRUB A 0;
		FIZZ A 0;
		ZZIF A 0;
	}

	override void Tick()
	{
		if (player && !player.morphtics)
		{
			if (Level.time % (35 * 5) == 0) { ForcedHealthBar = GetClosestForcedHealthBar(); } // Only run this check occasionally

			CrosshairTarget = GetLineTarget();

			DoGravity();

			DoTokenChecks();

			DoInteractions();
		}

		Super.Tick();
	}

	override void MovePlayer ()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;

		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks)
		{
			player.turnticks--;
			Angle += (180. / TURN180_TICKS);
		}
		else
		{
			if (DragTarget) { cmd.yaw = int(cmd.yaw * 0.15); }
			Angle += cmd.yaw * (360./65536.);
		}

		player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);

		// killough 10/98:
		//
		// We must apply thrust to the player and bobbing separately, to avoid
		// anomalies. The thrust applied to bobbing is always the same strength on
		// ice, because the player still "works just as hard" to move, while the
		// thrust applied to the movement varies with 'movefactor'.

		if (cmd.forwardmove | cmd.sidemove)
		{
			double forwardmove, sidemove;
			double bobfactor;
			double friction, movefactor;
			double fm, sm;

			[friction, movefactor] = GetFriction();
			bobfactor = friction < ORIG_FRICTION ? movefactor : ORIG_FRICTION_FACTOR;

			if (!player.onground && !bNoGravity && !waterlevel && !leveltilt)
			{
				// [RH] allow very limited movement if not on ground.
				movefactor *= level.aircontrol;
				bobfactor*= level.aircontrol;
			}

			fm = cmd.forwardmove;
			sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds (fm, sm);
			fm *= Speed / 256;
			sm *= Speed / 256;

			// When crouching, speed and bobbing have to be reduced
			if (CanCrouch() && player.crouchfactor != 1)
			{
				fm *= player.crouchfactor;
				sm *= player.crouchfactor;
				bobfactor *= player.crouchfactor;
			}

			forwardmove = fm * movefactor * (35 / TICRATE);
			sidemove = sm * movefactor * (35 / TICRATE);

			if (forwardmove)
			{
				if (leveltilt <= 30) { Bob(Angle, cmd.forwardmove * bobfactor / 256., true); }
				if (leveltilt)
				{
					vel.x += forwardmove * cos(angle) * cos(leveltilt) * speed * 1.5;
					vel.y += forwardmove * sin(angle) * speed;
					vel.z -= forwardmove * cos(angle - leveltiltangle) * sin(leveltilt) * speed * 1.5;
				}
				else
				{
					ForwardThrust(forwardmove, Angle);
				}
			}
			if (sidemove)
			{
				let a = Angle - 90;
				if (leveltilt <= 30) { Bob(a, cmd.sidemove * bobfactor / 256., false); }

				if (leveltilt)
				{
					vel.x += sidemove * sin(angle) * cos(leveltilt) * speed * 1.75;
					vel.y += -sidemove * cos(angle) * speed * 1.75;
					vel.z -= sidemove * sin(angle - leveltiltangle) * sin(leveltilt) * speed * 1.75;
				}
				else
				{
					Thrust(sidemove, a);
				}
			}

			if (!(player.cheats & CF_PREDICTING) && (forwardmove != 0 || sidemove != 0))
			{
				PlayRunning ();
			}

			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
		}
	}

	override void CheckJump()
	{
		let player = self.player;
		// [RH] check for jump
		if (player.cmd.buttons & BT_JUMP)
		{
			if (player.crouchoffset != 0)
			{
				// Jumping while crouching will force an un-crouch but not jump
				player.crouching = 1;
			}
			else if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
			}
			else if (bNoGravity && !leveltilt)
			{
				Vel.Z = 3.;
			}
			else if (level.IsJumpingAllowed() && (player.onground || leveltilt != 0) && player.jumpTics == 0)
			{
				double jumpvelz = JumpZ * 35 / TICRATE;
				double jumpfac = 0;

				// [BC] If the player has the high jump power, double his jump velocity.
				// (actually, pick the best factors from all active items.)
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;

				Vel.X += jumpvelz * sin(leveltilt) * cos(leveltiltangle);
				Vel.Y += jumpvelz * sin(leveltilt) * sin(leveltiltangle);
				Vel.Z += jumpvelz * cos(leveltilt);
				bOnMobj = false;
				player.jumpTics = -1;
				if (!(player.cheats & CF_PREDICTING)) A_PlaySound("*jump", CHAN_BODY);
			}
		}
	}

	override void CheckUndoMorph()
	{
		if (player) { Super.CheckUndoMorph(); }
	}

	Actor GetLineTarget()
	{
		FTranslatedLineTarget t;
		AimLineAttack(angle, 1024, t, 0.5);

		return t.linetarget;
	}

	Actor GetClosestForcedHealthBar()
	{
		ThinkerIterator Finder = ThinkerIterator.Create("Base", Thinker.STAT_DEFAULT - 3);
		Base it;
		Actor mo;

		while ( it = Base(Finder.Next()) )
		{
			if (!it.user_DrawHealthBar == True) { continue; } // Only process actors with the AlwaysDrawHealthBar flag set
			if (
				it.health <= 0 ||
				!it.bShootable ||
				it.bDormant
			) { continue; }
			if (mo && Distance3D(it) > Distance3D(mo)) { continue; } // Only draw health bar for the closest one

			mo = it;
		}

		return mo;
	}

	// Helper function for sprite index lookups to avoid hard engine crash
	SpriteID LookupSprite(Name spritecheck)
	{
		SpriteID temp = GetSpriteIndex(spritecheck);
		if (temp > -1) { return temp; }

		console.printf("\cgERROR: \cjThe sprite name index for '\cf%s\cj' could not be found.  Did you forget to add it to one of the actor's states?", spritecheck);
		return sprite;
	}

	// Function to do the actual token checking and sprite setting
	bool CheckSpriteToken(String token, Name standsprite, Name crouchsprite = "")
	{
		user_crouch = GetCrouchFactor(AAPTR_DEFAULT);

		if (CountInv(token) > 0)
		{
			if (!(crouchsprite == "") && user_crouch < 0.75)
			{
				sprite = LookupSprite(crouchsprite);
				Scale.Y = user_ScaleY / user_crouch; //Negate crouch sprite scaling
			}
			else
			{
				sprite = LookupSprite(standsprite);
				Scale.Y = user_ScaleY;
			}
			return true;
		}
		return false;
	}

	void DoTokenChecks()
	{
		if (health <= 0) { return; } // Don't change sprites if the player is dead

		if (user_ScaleY == 0) { user_ScaleY = Scale.Y; }
		if (!baseSprite) { baseSprite = sprite; }

		// Firebrand effect handling
		if (player && player.ReadyWeapon is "FireBrand" && CountInv("PowerWeaponLevel2") > 0) { SpawnEffect("FireBrandEffect"); }
		else { RemoveEffect("FireBrandEffect"); }
		
		// Lantern effect handling
		LanternPickup lantern = LanternPickup(FindInventory("LanternPickup"));

		if (player && lantern && lantern.active) { SpawnEffect("LanternEffect"); }
		else { RemoveEffect("LanternEffect"); }

		// New uniform or other sprite-changing tokens should be set up here.  See CheckSpriteToken function above.
		//  These should be listed in order of precedence - The ones at the top will take priority.
		//  All new sprites need to be added to the 'SpriteList' state above or the engine won't be able to use them.
		if (
			CheckSpriteToken("CCBJUniformToken", "PLCP", "PLYP") ||
			CheckSpriteToken("ScientistUniformToken", "PLSC", "PLYS") ||
			CheckSpriteToken("SSBJUniformToken", "SSOF") // Temporarily using the SS Officer Sprites (and just squishing them for crouch)
		) { return; }

		// If no tokens found, restore the base sprite and original scale
		sprite = baseSprite;
		Scale.Y = user_ScaleY;
	}

	// Function to spawn no more than a single copy of an effect actor as a child of the player
	void SpawnEffect(class<PlayerEffect> effect)
	{
		ThinkerIterator it = ThinkerIterator.Create("PlayerEffect", Thinker.STAT_DEFAULT - 4);
		PlayerEffect mo;

		while (mo = PlayerEffect(it.Next(true)))
		{
			if (mo.master && mo.master != self) { continue; } // Only look at effects that belong to this player actor
			if (mo is effect) { return; } // The effect already exists, so abort so we don't spawn it again
		}

		// If it wasn't already there, spawn this effect
		Actor new = Spawn(effect);
		if (new) { new.master = self; }
	}

	// Function to remove any spawned copy of an effect that is a child of the player
	void RemoveEffect(class<PlayerEffect> effect)
	{
		ThinkerIterator it = ThinkerIterator.Create("PlayerEffect", Thinker.STAT_DEFAULT - 4);
		PlayerEffect mo;

		while (mo = PlayerEffect(it.Next(true)))
		{
			if (mo.master && mo.master != self) { continue; } // Only look at effects that belong to this player actor
			if (mo is effect) { mo.SetStateLabel('null'); } // Remove the effect, if found
		}
	}

	// Function to handle leveltilt-induced "gravity" effects.
	void DoGravity()
	{
		// If the player isn't using NOCLIP and they are at the "tipping point" for their mass, make them slide to the new "down"
		if (abs(leveltilt) >= min(mass, 1000) / 1000.0 * 45 && !(player.cheats & (CF_NOCLIP | CF_NOCLIP2)))
		{
			bNoGravity = leveltilt != 0;

			double grav = level.gravity * CurSector.gravity * Gravity * 0.00125;

			vel.z -= grav * cos(leveltilt);
			vel.x -= grav * sin(leveltilt) * cos(leveltiltangle);
			vel.y -= grav * sin(leveltilt) * sin(leveltiltangle);

			if (leveltilt != oldtilt)
			{
				if (leveltilt == 0)
				{
					A_SetSize(Default.Radius, Default.Height);
				}
				else
				{
					double abstilt = abs(leveltilt);
					double newradius = Default.radius * cos(abstilt) + Default.height / 2 * sin(abstilt);
					double newheight = Default.radius * sin(abstilt) + Default.height / 2 * cos(abstilt);

					if (height != newheight || radius != newradius) { A_SetSize(newradius, newheight, true); }
				}

				oldtilt = leveltilt;
			}
		}
	}

	void DoInteractions()
	{
		bool dodragging = false; // Set true to enable dragging of corpses and pushable actors (crouch and use)

		FLineTraceData trace;
		LineTrace(angle, UseRange, pitch, TRF_THRUACTORS, player.viewheight, 0.0, 0.0, trace);
		Line AimLine = trace.HitLine;

		Actor AimActor;
		if (dodragging)
		{
			FLineTraceData actortrace;
			LineTrace(angle, UseRange, pitch, TRF_ALLACTORS, player.viewheight, 0.0, 0.0, actortrace); // Corpse dragging needs to trace without TRF_THRUACTORS flag
			AimActor = actortrace.HitActor;
		}

		if (AimLine && !crosshair)
		{
			// Only show custom crosshair if the line is running a script, is a locked door or puzzle item use line, or has a UDMF lock number
			//  Otherwise - Why?  It's not an activation line, so what's the point of showing a hint?
			if ( 	
				AimLine.special == 13 || // Door_LockedRaise
				AimLine.special == 80 || // ACS_Execute 
				(AimLine.special >= 83 && AimLine.special <= 85) || // ACS_LockedExecute, ACS_ExecuteWithResult, ACS_LockedExecuteDoor
				Aimline.special == 129 || // UsePuzzleItem
				AimLine.special == 226 || // ACS_ExecuteAlways
				Aimline.locknumber
			)
			{
				crosshair = AimLine.GetUDMFInt("user_crosshair"); // Use the line's user_crosshair property if it has a value
				crosshairstring = AimLine.GetUDMFString("user_crosshair"); // Or try looking for a class name as a string value
			}
			else
			{
				crosshair = 0;
				crosshairstring = "";
			}
		}

		if (AimLine && !AimLine.special) { AimLine = null; }

		// If line is set to block hitscans only, do some special handling
		if (AimLine && AimLine.flags & Line.ML_BLOCKHITSCAN && !(AimLine.flags & Line.ML_BLOCKEVERYTHING) && !(AimLine.flags & Line.ML_WRAP_MIDTEX))
		{
			if (AimLine.flags & Line.ML_3DMIDTEX) // If it's a 3D midtex, figure out if we hit the texture or not...
			{
				let side = AimLine.sidedef[trace.LineSide];

				if (side)
				{
					TextureID tex = side.GetTexture(trace.LinePart);

					if (tex)
					{
						Vector2 texsize = TexMan.GetScaledSize(tex);
						double scaley = side.GetTextureYScale(trace.LinePart);
						double sizey = texsize.y / scaley;
						double offsety = side.GetTextureYOffset(trace.LinePart) / scaley;

						double topz, bottomz;

						// Adjust things if lower unpegged is set...
						if (AimLine.flags & Line.ML_DONTPEGBOTTOM) { topz = sizey; }
						else { topz = trace.HitSector.ceilingplane.D - trace.HitSector.floorplane.D; }

						topz += offsety;
						bottomz = topz - sizey;

						double hitz = trace.HitLocation.z + trace.HitSector.floorplane.D;

						if (topz < hitz || bottomz > hitz) // You're not actually looking at the midtex!
						{
							AimLine = null; // Clear the line pointer
						}
					}
					else // No texture
					{
						AimLine = null; // Clear the line pointer
					}
				}
			}
		}

		// Handle player holding down use button while looking at a repeatable, script-executing line that's within use range
		if (AimLine) // If we are actually looking at a line within range
		{
			if (
				( // And the line is running a script
					AimLine.special == 80 || 
					(AimLine.special >= 83 && AimLine.special <= 85) || 
					AimLine.special == 226
				) &&
				( // And is flagged as repeatable and you're pressing use
					AimLine.flags & Line.ML_REPEAT_SPECIAL && 
					player.cmd.buttons & BT_USE
				) &&
				( // And we have the right UDMF-defined key if one was set on the line!
					!Aimline.locknumber || 
					CheckKeys(Aimline.locknumber, false, true)
				)
			)
			{
				player.usedown = false; // Pretend that the use button wasn't actually being held so that the use action will repeat as long as use is held

				if (!LastWeapon && crosshair >= 80 && crosshair <= 90) // Only lower weapon when there's a status display
				{
					Weapon lowered = Weapon(FindInventory("NullWeapon"));

					if (player.ReadyWeapon != lowered) { LastWeapon = player.ReadyWeapon; }
					player.PendingWeapon = lowered;
				}
			}
		}
		// Draggable corpse handling (also lets you pull pushable actors)
		//  Player must crouch within use range of a draggable actor and hold use, then move to drag the actor along
		else if (dodragging && (AimActor || DragTarget) && player.usedown && player.cmd.buttons & BT_CROUCH)
		{
			if (DragTarget)
			{
				DragTarget.Warp(self, Clamp(Distance2D(DragTarget), radius + DragTarget.radius + speed, UseRange), flags:WARPF_INTERPOLATE | WARPF_NOCHECKPOSITION);

				// Closed hand grab icon
				crosshair = 97;
			}
			else
			{
				if (
					AimActor && 
					Distance2D(AimActor) < UseRange && 
					(
						IsCorpse(AimActor) ||
						AimActor.bPushable
					)
				)
				{
					if (!LastWeapon)
					{
						Weapon lowered = Weapon(FindInventory("NullWeapon"));

						if (player.ReadyWeapon != lowered) { LastWeapon = player.ReadyWeapon; }
						player.PendingWeapon = lowered;
					}
					DragTarget = AimActor;
					Speed = Default.Speed * 0.05;
				}
			}
		}
		else
		{
			if (LastWeapon)
			{
				player.PendingWeapon = LastWeapon;
				LastWeapon = null;
			}

			crosshair = 0;
			crosshairstring = "";

			if (dodragging)
			{
				DragTarget = null;
				Speed = Default.Speed;

				if (
					player.cmd.buttons & BT_CROUCH &&
					AimActor && 
					Distance2D(AimActor) < UseRange + AimActor.Radius && 
					(
						IsCorpse(AimActor) ||
						(!AimActor.bIsMonster && AimActor.bPushable)
					)
				)
				{
					// Open hand grab icon
					crosshair = 98;
				}
			}
		}

		// Blank out the actual crosshair if a custom one is being used - 0 reverts to the player or weapon's default
		if (player.ReadyWeapon) { player.ReadyWeapon.Crosshair = (crosshair > 0 || crosshairstring) ? 99 : 0; }
	}

	bool IsCorpse(Actor mo)
	{
		if (
			!mo.bIsMonster ||
			mo.health > 0 ||
			mo.bDormant
		) { return false; }

		return true;
	}

	static void FireWeapon(Actor mo, bool alt = 0, bool onuse = 1)
	{
		if (mo.player && mo.player.ReadyWeapon && mo.player.playerstate == PST_LIVE)
		{
			let psp = mo.player.GetPSprite(PSP_WEAPON);

			State newState = alt ? mo.player.ReadyWeapon.FindState('AltFire') : mo.player.ReadyWeapon.FindState('Fire');

			if (newState) { psp.SetState(newState); }
		}
	}
}

// Base class for simple visual effects that will always follow the player until removed
class PlayerEffect : Actor
{
	Default
	{
		+NOINTERACTION
	}

	States
	{
		Spawn:
			// This state should be replaced in child classes
			UNKN A 1;
			Loop;
	}

	override void BeginPlay()
	{
		ChangeStatNum(Thinker.STAT_DEFAULT - 4);
	}

	override void Tick()
	{
		// If a master is assigned, always move to its location
		if (master) { A_Warp(AAPTR_MASTER, flags:WARPF_COPYPITCH | WARPF_COPYINTERPOLATION | WARPF_NOCHECKPOSITION); }
		Super.Tick();
	}
}

class FireBrandEffect : PlayerEffect
{
	States
	{
		Spawn:
			TNT1 A 4 NoDelay Light("ITBURNSOC1");
			TNT1 A 4 Light("ITBURNSOC2");
		SpawnLoop:
			TNT1 A 4 Light("ITBURNSOC3") A_SetTics(Random(1, 8));
			Loop;
	}
}

class LanternEffect : PlayerEffect
{
	States
	{
		Spawn:
			TNT1 A 4 NoDelay Light("LANT01");
			TNT1 A 4 Light("LANT02");
		SpawnLoop:
			TNT1 A 4 Light("LANT03") A_SetTics(Random(1, 3));
			Loop;
	}
}

// Sherman Tank Player Class
class ShermanPlayer : PlayerPawn
{
	Actor treads, turret, turretcamera, gun;
	Actor ForcedHealthBar;
	FLineTraceData cameratrace;
	BoAFindHitPointTracer hittracer;
	double sndvol;
	Vector3 cameralocation;
	int useholdtime;
	Vector3 CrosshairPos;
	Actor CrosshairActor;
	double CrosshairDist;

	Default
	{
		Health 10000; // Need to tweak, probably...
		Height 96;
		Mass 0x7ffffff;
		Radius 64;
		Speed 0.5;
		BloodType "TankSpark";
		MaxStepHeight 24;
		Species "Tank";
		Player.MorphWeapon "Cannon75mm";
		Player.StartItem "Cannon75mm";
		Player.UseRange 0;
		Player.WeaponSlot 1, "Cannon75mm";
		Renderstyle 'None'; // Ensure that the actual player actor stays invisible, just in case it reverts to PLAYA0 sprites
		+NOBLOOD
		-PICKUP // Don't pick up powerups while in the tank
	}

	States
	{
		Spawn:
			TNT1 A -1;
			Stop;
		Pain:
			TNT1 A 1 A_Pain;
			Goto Spawn;
		Death:
			TNT1 A 1 {
				A_Scream();
				A_StopSound(CHAN_6);
				A_StopSound(CHAN_7);
			}
			TNT1 A -1;
			Stop;
	}

	override void MovePlayer ()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;

		double moveangle = angle;

//*		cmd.yaw = clamp(cmd.yaw, -1024, 1024);

//*		if (turret && cmd.yaw) { turret.angle += cmd.yaw * (360./65536.); A_PlaySound("MACHINE_LOOP_3", CHAN_AUTO, 0.2, FALSE); }
		if (cmd.yaw) { angle += cmd.yaw * (360./65536.); } 
		if (treads) { moveangle = treads.angle; }

		player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);

		double newsndvol = 0;

		if (cmd.forwardmove | cmd.sidemove)
		{
			double forwardmove, sidemove;
			double bobfactor;
			double friction, movefactor;
			double fm, sm;

			[friction, movefactor] = GetFriction();
			bobfactor = friction < ORIG_FRICTION ? movefactor : ORIG_FRICTION_FACTOR;

			if (!player.onground && !bNoGravity && !waterlevel)
			{
				// [RH] allow very limited movement if not on ground.
				movefactor *= level.aircontrol;
				bobfactor*= level.aircontrol;
			}

			fm = cmd.forwardmove;
			sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds (fm, sm);
			fm *= Speed / 256;
			sm *= Speed / 256;

			forwardmove = fm * movefactor * (35 / TICRATE);
			sidemove = sm * movefactor * (35 / TICRATE);

			// Default to "auto-steering" the tank to wherever you are aiming
			if (forwardmove && !(cmd.buttons & BT_SPEED) && treads && turret && treads.angle != turret.angle) // If *not* holding SHIFT, auto-steer the tracks to align with the turret
			{
				double diff = deltaangle(treads.angle, angle);

				if (diff < -1)
				{
					treads.angle -= 2;
					forwardmove /= 5;
					A_PlaySound("MACHINE_LOOP_3", CHAN_AUTO, 0.2, FALSE);
				}
				else if (diff > 1)
				{
					treads.angle += 2;
					forwardmove /= 5;
					A_PlaySound("MACHINE_LOOP_3", CHAN_AUTO, 0.2, FALSE);
				}
				else
				{
					treads.angle = angle;
				}

				newsndvol += 0.5;
			}
			else if (sidemove) // Only do separate sidemove handling if not auto-steering or not moving forward
			{
				if (forwardmove >= 0) { sidemove *= -1; }

				if (!forwardmove) { sidemove *= 2.5; } // Turn faster if you're not moving forward

				angle += sidemove;

				if (treads) { treads.angle += sidemove; }
//*				if (turret) { turret.angle += sidemove; }

				A_SetInventory("ShakeShaderControl", 1 + int(sidemove));

				newsndvol += abs(sidemove);
			}

			if (forwardmove)
			{
				ForwardThrust(forwardmove, moveangle);
			}

			if (!(player.cheats & CF_PREDICTING) && (forwardmove != 0 || sidemove != 0))
			{
				PlayRunning ();
				if (treads)
				{
					if (InStateSequence(treads.CurState, treads.SpawnState) && treads.FindState("Move"))
					{
						 treads.SetStateLabel("Move");
					}
				}
			}

			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
		}

		double movespeed = vel.xy.length();
		if (movespeed)
		{
			A_SetInventory("ShakeShaderControl", 1 + int(movespeed) * 65536);
			newsndvol += movespeed;
		}

		if (sndvol > newsndvol) { sndvol = max(sndvol - 0.25, newsndvol); }
		if (sndvol < newsndvol) { sndvol = min(sndvol + 0.25, newsndvol); }

		A_SoundVolume(CHAN_7, sndvol);
	}

	override void CheckJump() {} // Tanks can't jump

	override void CheckPitch()
	{
		let player = self.player;
		// [RH] Look up/down stuff
		if (!level.IsFreelookAllowed())
		{
			Pitch = 0.;
		}
		else
		{
			// The player's view pitch is clamped between -32 and +56 degrees,
			// which translates to about half a screen height up and (more than)
			// one full screen height down from straight ahead when view panning
			// is used.
			int clook = player.cmd.pitch;
			if (clook != 0)
			{
				if (clook == -32768)
				{ // center view
					player.centering = true;
				}
				else if (!player.centering)
				{
					// no more overflows with floating point. Yay! :)
					Pitch = clamp(Pitch - clook * (360. / 65536.), (turret ? -turret.pitch : 0) + player.MinPitch, (turret ? -turret.pitch : 0) + player.MaxPitch);
				}
			}
		}
		if (player.centering)
		{
			if (abs(Pitch) > 2.)
			{
				Pitch *= (2. / 3.);
			}
			else
			{
				Pitch = 0.;
				player.centering = false;
				if (PlayerNumber() == consoleplayer)
				{
					LocalViewPitch = 0;
				}
			}
		}
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (other is "TankBlocker") { return false; }
		return true;
	}

	override void PostBeginPlay()
	{
		TakeInventory("BoATilt", 1);

		hittracer = new("BoAFindHitPointTracer");

		// Spawn everything in neutral orientation
		pitch = 0;
		roll = 0;

		bool sp = false;

		if (tracer && US_Sherman(tracer))
		{
			treads = tracer;
			tracer = null;
		}

		while (!treads) { [sp, treads] = A_SpawnItemEx("US_Sherman", 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }
		treads.master = self;
		treads.bSolid = false;

		while (!turretcamera) { [sp, turretcamera] = A_SpawnItemEx("SecurityCamera", -2.5 * radius, 0, treads.height + 128, 0, 0, 0, 0, SXF_TRANSFERPITCH | SXF_TRANSFERROLL | SXF_TRANSFERSCALE); }
		turretcamera.master = self;

		sndvol = 0.7;

		A_PlaySound("TKIDLE", CHAN_6, 0.25, TRUE);
		A_PlaySound("TNK1LOOP", CHAN_7, 0.7, TRUE);

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		Super.Tick();

		if (health == Default.Health && US_Sherman(treads).savedhealth)
		{
			A_SetHealth(US_Sherman(treads).savedhealth);
			US_Sherman(treads).savedhealth = 0;
		}

		if (!turret) // Since turret is spawned by treads actor, check for it here since it'll be spawned after PostBeginPlay is called
		{
			if (US_Sherman(treads))
			{
				turret = US_Sherman(treads).turret;

				if (turret)
				{
					turret.master = self;
					turret.angle = angle;
					turret.bSolid = false;
				}
			}
		}

		if (Level.time % (35 * 5) == 0) { ForcedHealthBar = GetClosestForcedHealthBar(); } // Only run this check occasionally

		if (player && turretcamera && treads && turret)
		{
			treads.SetOrigin(self.pos, true);
			SetPitchRoll(treads);

			double delta = deltaangle(treads.angle, turret.angle);

			Player.MinPitch = treads.pitch * cos(delta) - 25;
			Player.MaxPitch = treads.pitch * cos(delta) + 10;

			turret.SetOrigin(self.pos + (RotateVector((treads.radius * sin(treads.pitch), -treads.radius * sin(treads.roll)), treads.angle), treads.height * cos(treads.roll)), true);

			turret.pitch = treads.roll * sin(-delta) + treads.pitch * cos(delta);
			turret.roll = treads.roll * cos(-delta) + treads.pitch * sin(delta);

//*			angle = turret.angle;
			if (turret.angle > angle) { turret.angle = max(turret.angle - 1.5, angle); A_PlaySound("MACHINE_LOOP_3", CHAN_AUTO, 0.2, FALSE); }
			else if (turret.angle < angle) { turret.angle = min(turret.angle + 1.5, angle); A_PlaySound("MACHINE_LOOP_3", CHAN_AUTO, 0.2, FALSE); }

			double modifier, pitchmodifier;

			if (pitch < 0) { modifier = 48 * sin(-pitch); } // Aiming up moves the camera up so you can keep the aimpoint on screen
			else { modifier = 64 * sin(pitch * 3); } // Aiming down actually moves the camera *up*, so that you can see the aimpoint over the top of the turret

			modifier += (turret.pitch > 0 ? 96 : 128) * sin(turret.pitch); // Move the camera up/down when going up/downhill
			pitchmodifier = (turret.pitch > 0 ? -15 : 10) * sin(turret.pitch); // Pitch the camera up/down when going up/downhill

			turret.LineTrace(angle + 180, 2.5 * radius, pitchmodifier, TRF_THRUHITSCAN | TRF_THRUACTORS, turret.height + 32 + modifier, 0.0, 0.0, cameratrace);

			turretcamera.SetOrigin(cameratrace.HitLocation + AngleToVector(angle, 2), true);
			turretcamera.angle = angle;
			turretcamera.pitch = turret.pitch;

			// Force pitch clamping
			if (turret.pitch + pitch >= player.MaxPitch || turret.pitch + pitch <= player.MinPitch)
			{
				player.cmd.pitch = 0;
			}

			if (!gun) { gun = US_ShermanTurret(turret).gun; }

			if (gun)
			{
				DoTrace(gun, turret.angle, 2048, turret.pitch + pitch, 0, 0, hittracer);

				CrosshairPos = hittracer.Results.HitPos;
				CrosshairActor = hittracer.Results.HitActor;
				CrosshairDist = hittracer.Results.Distance;

				gun.pitch = turret.pitch + pitch;
				gun.roll = turret.roll;
			}

			player.camera = turretcamera;
			turretcamera.CameraFOV = player.fov;
		}
		else
		{
			player.camera = player.mo;
		}

		if (player.usedown)
		{
			useholdtime++;
			if (useholdtime == 1) { Level.ExecuteSpecial(80, self, null, false, -int(Name("TankExitMessage")), 0); }
		}
		else { useholdtime = 0; }

		if (useholdtime >= 70) { TakeInventory("Sherman", 1); }
	}

	// Handling for terrain-based pitch/roll calculations...
	void SetPitchRoll(Actor mo)
	{
		if (!mo) { mo = self; }
	
		double points[5], minz = 0x7FFFFFFF, maxz = -0x7FFFFFFF;

		points[0] = mo.floorz;

		// Get the relative z-height at the four corners of the tank
		points[1] = mo.GetZAt(Radius, Radius) - points[0];
		points[2] = mo.GetZAt(Radius, -Radius) - points[0];
		points[3] = mo.GetZAt(-Radius, Radius) - points[0];
		points[4] = mo.GetZAt(-Radius, -Radius) - points[0];

		for (int i = 1; i <= 4; i++)
		{
			if (points[i] > MaxStepHeight) { points[i] = 0; } // Ignore the point if you can't climb that high
		}

		// Use those values to calculate the pitch.roll amounts
		double pitchinput = (points[2] + points[1]) - (points[4] + points[3]);
		double rollinput = (points[2] + points[4]) - (points[1] + points[3]);

		pitchinput = atan(pitchinput / (Radius * 2));
		rollinput = atan(rollinput / (Radius * 2));

		mo.pitch = clamp(mo.pitch, -30, 30);
		mo.roll = clamp(mo.roll, -30, 30);

		// Interpolate to the new values
		if (mo.pitch > -pitchinput) { mo.pitch = max(mo.pitch - 1, -pitchinput); }
		if (mo.pitch < -pitchinput) { mo.pitch = min(mo.pitch + 1, -pitchinput); }

		if (mo.roll > rollinput) { mo.roll = max(mo.roll - 1, rollinput); }
		if (mo.roll < rollinput) { mo.roll = min(mo.roll + 1, rollinput); }
	}

	Actor GetClosestForcedHealthBar()
	{
		ThinkerIterator Finder = ThinkerIterator.Create("Base", Thinker.STAT_DEFAULT - 3);
		Base it;
		Actor mo;

		while ( it = Base(Finder.Next()) )
		{
			if (!it.user_DrawHealthBar == True) { continue; } // Only process actors with the AlwaysDrawHealthBar flag set
			if (
				it.health <= 0 ||
				!it.bShootable ||
				it.bDormant
			) { continue; }
			if (mo && Distance3D(it) > Distance3D(mo)) { continue; } // Only draw health bar for the closest one

			mo = it;
		}

		return mo;
	}

	void DoTrace(Actor origin, double angle, double dist, double pitch, int flags, double zoffset, BoAFindHitPointTracer thistracer)
	{
		if (!origin) { origin = self; }

		thistracer.skipspecies = origin.species;
		thistracer.skipactor = origin;
		Vector3 tracedir = (cos(angle) * cos(pitch), sin(angle) * cos(pitch), -sin(pitch));
		thistracer.Trace(origin.pos + (0, 0, zoffset), origin.CurSector, tracedir, dist, 0);
	}
}

Class BoAFindHitPointTracer : LineTracer
{
	Name skipspecies;
	Actor skipactor;

	override ETraceStatus TraceCallback() // Doesn't handle 3d Floors :-/
	{
		if (Results.HitType == TRACE_HitActor)
		{
			if (
				Results.HitActor != skipactor && // Skip the player
				!(Results.HitActor is "ShermanPlayer") &&
				(!Results.HitActor.master || Results.HitActor.master != skipactor) && // And any children
				Results.HitActor.species != skipspecies && // And any of the skipped species
				(Results.HitActor.bSolid || Results.HitActor.bShootable) // And only return shootable actors
			) { return TRACE_Continue; } // Fall through, but remember the actor that you hit

			return TRACE_Skip;
		}
		else if (Results.HitType == TRACE_HitFloor || Results.HitType == TRACE_HitCeiling)
		{
			return TRACE_Stop;
		}
		else if (Results.HitType == TRACE_HitWall)
		{
			if (Results.HitLine.flags & (Line.ML_BLOCKING | Line.ML_BLOCKEVERYTHING)) { return TRACE_Stop; }
			if (Results.HitTexture)
			{
				if (Results.Tier != TIER_Middle || Results.HitLine.flags & Line.ML_3DMIDTEX) // 3D Midtex check still isn't perfect...
				{
					return TRACE_Stop;
				}
				return TRACE_Skip;
			}
			return TRACE_Skip;
		}

		return TRACE_Stop;
	}
}
