/*

  ActorSpawner
    These are spawn point actors that spawn actors when active, and maintain a set
    number of those actors alive (1 by default).  Actors will not be spawned if a player
    can see the spawn point or if a player is within a defined minimum spawn distance
    from the spawner (default 512 units).

    By default, the spawner will spawn a single guard.  Once that guard is killed, the
    spawner will spawn another guard, and so on.

    Spawned actors can be given a TID and can be set to navigate to a specific
    PatrolPoint TID after spawn as well.

  Custom UDMF Properties
    arg0str
      Sets the class of actor to be spawned (default "Guard")

    user_tid
      Sets the TID that the spawned enemies are given.  By default they have no TID.

    user_goal
      Sets the goal/patrolpoint TID that the spawned enemies will walk to once they return to
      being idle.  By default, they go back to their spawn point and stand still.

    user_maxactors
      Sets how many enemies from this spawner to maintain alive at once (default 1)

    user_minspawndistance
      Distance from player inside of which the spawner will stop spawning (default 512)

*/
class ActorSpawner : SwitchableDecoration
{
	Array<Actor> Spawns;
	Class<Actor> spawntype;

	// TID to give the spawned enemy actor (default no TID)
	int user_tid;

	// TID of goal that the enemy should walk to after spawning (default no goal)
	int user_goal;

	// How many enemies from this spawner to maintain alive at once (default 1)
	int user_maxactors;

	// Distance from player inside of which the spawner will stop spawning (default 512)
	int user_minspawndistance;

	Default
	{
		//$Arg0 "Thing ID to spawn"
		//$Arg0Str "Actor class to spawn"
		//$Sprite EXCLC0
	}

	States
	{
		Spawn:
			TNT1 A 35;
		Active:
			"####" "#" 35 A_SetTics(Random[Spawn](1, 3) * 35);
			"####" "#" 0 { return ResolveState("Active.Spawn"); }
		Active.Spawn:
			"####" "#" 1 A_DoSpawns();
		Inactive:
			"####" "#" 35;
			Loop;
	}

	override void PostBeginPlay()
	{
		spawntype = GetSpawnableType(args[0]);
		if (!spawntype) { spawntype = "Guard"; }

		if (!user_maxactors) { user_maxactors = 1; }
		if (!user_minspawndistance) { user_minspawndistance = 512; }
	}

	bool InPlayerSightOrRange(int range = 512)
	{
		for (int p = 0; p < MAXPLAYERS; p++) // Iterate through all of the players and see if any can see the spawn point
		{
			Actor mo = players[p].mo;

			if (mo) {
				if (mo.CheckSight(self)) { return true; }
				if (Distance3d(mo) <= range) { return true; }
			}
		}

		return false;
	}

	int CountSpawns()
	{
		int spawncount = 0;

		for (int i = 0; i < Spawns.Size(); i++) {
			Actor mo = Spawns[i];

			if (mo) {
				if (!mo.bShootable || mo.health <= 0) {
					Spawns.Delete(i);
					Spawns.ShrinkToFit();
				} else {
					spawncount++;
				}
			}
		}

		return spawncount;
	}

	virtual state A_DoSpawns()
	{
		int spawncount = CountSpawns();

		if (spawncount < user_maxactors) {
			//Spawn enemies if not visible to player
			if (!InPlayerSightorRange(user_minspawndistance)) {
				Actor spawned = Spawn(spawntype, pos);
				spawned.target = target;
				spawned.angle = angle;
				spawned.ChangeTID(user_tid);
				if (user_goal > 0)
				{
					let it = ActorIterator.Create(user_goal, "PatrolPoint");
					Actor goal;
					if (it) { goal = it.Next(); }
					if (goal) { spawned.goal = goal; }

					if (Nazi(spawned))
					{
						if (Nazi(spawned).user_sneakable) { Nazi(spawned).BecomeAlerted(); }
						Nazi(spawned).activationgoal = goal;
					}

					spawned.SetStateLabel("See");
				}
				Spawns.Push(spawned);
			}
		}
		return ResolveState("Active");
	}
}