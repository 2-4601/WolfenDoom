/*

  ActorSpawner
    These are spawn point actors that spawn actors when active, and maintain a set
    number of those actors alive (1 by default).  Actors will not be spawned if a player
    can see the spawn point or if a player is within a defined minimum spawn distance
    from the spawner (default 512 units).

    By default, the spawner will spawn a single guard.  Once that guard is killed, the
    spawner will spawn another guard, and so on.

    Spawned actors can be given a TID and can be set to navigate to a specific
    PatrolPoint TID after spawn as well.

  Custom UDMF Properties
    arg0str
      Sets the class of actor to be spawned (default "Guard")

    user_tid
      Sets the TID that the spawned enemies are given.  By default they have no TID.

    user_goal
      Sets the goal/patrolpoint TID that the spawned enemies will walk to once they return to
      being idle.  By default, they go back to their spawn point and stand still.

    user_maxactors
      Sets how many enemies from this spawner to maintain alive at once (default 1) - use negative numbers to set total number spawned instead of number to keep alive

    user_minspawndistance
      Distance from player inside of which the spawner will stop spawning (default 512)

*/
class ActorSpawner : SwitchableDecoration
{
	Array<Actor> Spawns;
	Class<Actor> user_spawntype;
	int totalspawncount;

	// TID to give the spawned enemy actor (default no TID)
	int user_tid;

	// TID of goal that the enemy should walk to after spawning (default no goal)
	int user_goal;

	// How many enemies from this spawner to maintain alive at once (default 1)
	int user_maxactors;

	// How many enemies from this spawner to spawn in total (defaults to infinite)
	int user_maxspawns;

	// Distance from player inside of which the spawner will stop spawning (default 512)
	int user_minspawndistance;

	Default
	{
		//$Arg0 "Thing ID to spawn"
		//$Arg0Str "Actor class to spawn"
		//$Arg0ToolTip "What actor to spawn.  Numeric values set Thing ID, and string values set spawn class."
		//$Arg1 "Maximum number alive"
		//$Arg1ToolTip "Determines the number of actors to keep alive at once (e.g., '5' will spawn a new actor every time you kill one, keeping 5 alive at all times)."
		//$Arg2 "TID to give actor"
		//$Arg2ToolTip "TID that will be given to the spawned actor(s).  Default is 0 (no TID)."
		//$Arg3 "Minimum player distance"
		//$Arg3ToolTip "Distance that the player must be away from this actor in order for spawns to take place.  A value of '0' defaults to 512."
		//$Arg3Default 512
		//$Arg4 "Maximum number to spawn, total"
		//$Arg4ToolTip "Determines the number of actors to spawn in total, regardless of how many are killed. Zero means unlimited."
		//$Sprite EXCLC0
	}

	States
	{
		Spawn:
			UNKN A 35;
		Active:
			"####" "#" 35 A_SetTics(Random[Spawn](1, 3) * 35);
			"####" "#" 0 { return ResolveState("Active.Spawn"); }
		Active.Spawn:
			"####" "#" 1 A_DoSpawns();
		Inactive:
			"####" "#" 35;
			Loop;
	}

	override void PostBeginPlay()
	{
		user_spawntype = GetSpawnableType(args[0]);
		user_maxactors = args[1];
		user_tid = args[2];
		user_minspawndistance = args[3];
		user_maxspawns = args[4];

		if (!user_spawntype) { user_spawntype = "Guard"; }
		if (user_maxactors == 0) { user_maxactors = 1; }
		if (user_minspawndistance == 0) { user_minspawndistance = 512; }
	}

	bool InPlayerSightOrRange(int range = 512)
	{
		for (int p = 0; p < MAXPLAYERS; p++) // Iterate through all of the players and see if any can see the spawn point
		{
			Actor mo = players[p].mo;

			if (mo) {
				if (mo.CheckSight(self)) { return true; }
				if (Distance3d(mo) <= range) { return true; }
			}
		}

		return false;
	}

	int CountSpawns(Class<Actor> spawntype = "")
	{
		int spawncount = 0;
		if (spawntype = "") { spawntype = user_spawntype; }

		for (int i = 0; i < Spawns.Size(); i++) {
			Actor mo = Spawns[i];

			if (mo) {
				if (!mo.bShootable || mo.health <= 0) {
					Spawns.Delete(i);
					Spawns.ShrinkToFit();
				} else if (mo.GetClass() == spawntype) {
					spawncount++;
				}
			}
		}

		return spawncount;
	}

	int TotalSpawns()
	{
		int total = CountSpawns();

		if (tid == 0) { return total; }

		ActorIterator it = ActorIterator.Create(tid, "ActorSpawner");
		Actor spot;

		while (spot = it.Next())
		{
			total += ActorSpawner(spot).CountSpawns(user_spawntype);
		}

		return total;
	}

	virtual state A_DoSpawns()
	{
		int spawncount = TotalSpawns();

		if (spawncount <= user_maxactors && (totalspawncount < user_maxspawns || user_maxspawns == 0)) {
			//Spawn enemies if not visible to player
			if (!InPlayerSightorRange(user_minspawndistance)) {
				Actor spawned = Spawn(user_spawntype, pos);
				if (spawned)
				{
					totalspawncount++;
					spawned.master = self;
					spawned.target = target;
					spawned.angle = angle;
					spawned.ChangeTID(user_tid);
					if (user_goal > 0)
					{
						let it = ActorIterator.Create(user_goal, "PatrolPoint");
						Actor goal;
						if (it) { goal = it.Next(); }
						if (goal) { spawned.goal = goal; }
	
						if (Nazi(spawned))
						{
							if (Nazi(spawned).user_sneakable) { Nazi(spawned).BecomeAlerted(); }
							Nazi(spawned).activationgoal = goal;
						}	

						spawned.SetStateLabel("See");
					}
					Spawns.Push(spawned);
				}
			}
		}
		return ResolveState("Active");
	}
}