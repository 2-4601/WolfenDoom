/*
  Base ladder class that allows any actor touching it to climb up and down
  until the climbing actor leaves the ladder actor's radius or z-height.

  The actor is placed at the *top* of the climbable area.

  The base actor here is "stackable" in that you can place one above the 
  other and make a longer ladder.  This allows for 3D model ladders that
  you can place in the map that will "just work" with no extra settings
  (This is what the actor was originally designed for).


  Alternatively, the ClimbableZone actor defined below is intended for use
  with texture-based ladders (walls or 3D midtex).  With this ladder variant,
  you can set the Y scale of the actor as appropriate to define the height
  of the climbable zone that you want to set up.  

  The ClimbableZone actor is invisible in game, but shows up in-editor as 
  a transparent orange box, which represents the boundaries of the zone; 
  this allows you to easily see the zone boundary in 3D view,


  PlayerFollowers can use ladders by default; other +ISMONSTER actors cannot.

  The ladder plays sounds while an actor is climbing it.  Which sound set is
  used is controlled by the user_soundtype variable.

	0 - (Default) Ladder climbing sounds
	1 - Rope climbing sounds
	2 - Rock step sounds
	3 - Quiet metal step sounds

  RopeSpawner spawns a climbable/walkable rope from the actor along whatever
  pitch you give the actor (so, 90 for a rope that hangs straight down). 
  These actors can use the same user_soundtype property as above, and the
  user_maxlength property to specify a maximum length of the rope (default 
  maximum is 1024 units).

  CableSpawner is the same, but uses a smaller diameter grey model, so it
  looks like a cable instead.
*/

class LadderBase : Actor
{
	Array<Actor> Climbers;
	double ladderheight;
	double climbradius;
	double friction;
	bool passive;
	bool nomonsters;
	int soundtimeout;
	int user_soundtype;
	int activetimeout;

	Property LadderHeight:ladderheight; // Height of climbable area
	Property DisallowMonsters:nomonsters; // Can monsters climb the ladder?
	Property ClimbRadius:climbradius; // Detection radius for the ladder.  Defaults to same as actor radius
	Property Friction:friction;

	Default
	{
		+NOGRAVITY
		-SOLID
		+NODAMAGE
		+DONTTHRUST
		Height 8;
		Radius 24;
		LadderBase.LadderHeight 132; // Uses custom property vice actual actor height so that the ladder model can be submerged in the ground to make shorter ladders 
		LadderBase.DisallowMonsters True; // Sets variable determining if monsters should be disallowed from using the ladder
		LadderBase.Friction 0.95; // Only slow down a little when climbing ladders, by default
	}

	States
	{
		Spawn:
			MDLA A 1;
			Loop;
	}

	override void PostBeginPlay()
	{
		if (!climbradius) { climbradius = Radius; }

		DoStackCheck();

		Super.PostBeginPlay();
	}

	void DoStackCheck()
	{
		BlockThingsIterator it = BlockThingsIterator.Create(self, 1);

		while (it.Next())
		{
			if (it.thing == self) { continue; } // Ignore itself

			if (it.thing is "LadderBase")
			{ // If there are other ladders immediately above or below, handle setting up transfer logic so that players don't get dropped mid-ladder if there are multiple stacked ladders
				if (Distance2d(it.thing) > 0) { continue; } // Only check ladders that are directly above/below this one

				if (it.thing.pos.z >= pos.z && pos.z - ladderheight <= it.thing.pos.z) { passive = true; } // This ladder is not the top, so make it decorative only
				else if (it.thing.pos.z < pos.z && pos.z - ladderheight > it.thing.pos.z) // This ladder is the top, so make its height check logic handle the entire stack
				{
					double heightcheck = pos.z - it.thing.pos.z + LadderBase(it.thing).ladderheight;
					ladderheight = heightcheck > ladderheight ? heightcheck : ladderheight;
				}
			}
		}
	}

	override void Tick()
	{
		Super.Tick();

		if (passive) { return; }

		if (self is "RopeSegment" && abs(pitch) != 90 && !activetimeout && CheckRange(48.0, true)) { return; } // Short circuit the function if there are no players within reasonable range (cuts down on processing time, especially for horizontal ropes)

		BlockThingsIterator it = BlockThingsIterator.Create(self, climbradius + 16);

		while (it.Next())
		{
			if ((nomonsters || !it.thing.bIsMonster) && !(it.thing is "PlayerPawn") && !(it.thing is "PlayerFollower")) { continue; } // Ignore everything except players and monsters

			activetimeout = 350; // Set a timer so that the actor will stay active for 10 seconds after a player uses it to give playerfollowers a chance to use it...

			if (
				(Distance2D(it.thing) > climbradius + it.thing.radius || !CheckSight(it.thing)) || // Check if the actor can reach the ladder (horizontal radius check)
				(it.thing.pos.z + it.thing.height < pos.z - ladderheight) || // Z-height check (player below ladder)
				(it.thing.pos.z > pos.z + height) // Z-height check (player above ladder)
			)
			{
				ResetActor(it.thing);
				continue;
			}

			if (self is "RopeSegment" && (pitch < 70 || pitch > 290)) // Handle horizontal rope segments separately so they don't get the nogravity effect
			{
				/* No special handling right now */
			}
			else if (!it.thing.bFly && !it.thing.bFloat) // Only affect things that aren't already flying
			{
				if (Climbers.Find(it.thing) == Climbers.Size()) { Climbers.Push(it.thing); } // Add the actor to the list of climbers if it's not already there

				if (it.thing.bIsMonster && !(it.thing is "PlayerFollower")) { it.thing.bFloat = True; } // If it's a monster set +FLOAT
				else
				{
					if (it.thing is "BoAPlayer") { BoAPlayer(it.thing).climbing = true; }
					else if (it.thing is "PlayerFollower") { PlayerFollower(it.thing).climbing = true; }
					else { it.thing.bFly = True; } // If it's some other class of player, use the fly cheat/powerup
				}
				it.thing.bNoGravity = True;
			}

			if (Climbers.Find(it.thing) < Climbers.Size()) // If the actor is in the climbers list, apply speed/velocity changes
			{
				it.thing.vel *= friction;
			}

			if (target && target is "RopeSpawner") { soundtimeout = RopeSpawner(target).soundtimeout; }

			if (soundtimeout <= 0 && abs(it.thing.vel.length()) >= 1.0)
			{
				if (user_soundtype == 1) { it.thing.A_PlaySound("world/rope", CHAN_BODY, 0.35); }
				else if (user_soundtype == 2) { it.thing.A_PlaySound("floor/rock", CHAN_BODY, 0.3); }
				else if (user_soundtype == 3) { it.thing.A_PlaySound("floor/metal", CHAN_BODY, 0.1); }
				else { it.thing.A_PlaySound("world/ladder", CHAN_BODY, 0.4); }
				soundtimeout = 15;
			}
		}

		soundtimeout--;
		activetimeout = max(activetimeout - 1, 0);
	}

	// Restores the default values of the various flags if the actor was on this ladder
	void ResetActor(Actor mo)
	{
		if (Climbers.Find(mo) != Climbers.Size()) //If the actor was on the list of climbers for this ladder...
		{
			mo.Speed = mo.Default.Speed; // Reset the default values...
			mo.bNoGravity = mo.Default.bNoGravity;
			mo.bFly = mo.Default.bFly;
			mo.bFloat = mo.Default.bFloat;

			if (mo is "BoAPlayer") { BoAPlayer(mo).climbing = false; }
			else if (mo is "PlayerFollower") { PlayerFollower(mo).climbing = false; }

			Climbers.Delete(Climbers.Find(mo)); // ...and delete if from the climbers list.  
			Climbers.ShrinkToFit(); // Re-shrink the array
		}
	}

	override bool Used(Actor user)
	{
		if (user.player && user.pos.z <= pos.z + 16 && user.pos.z >= pos.z - ladderheight - user.height)
		{
			user.vel.z += user.speed / 2 * friction;
			user.player.usedown = false;

			return true;
		}
		else { return false; }
	}
}

class ClimbableZone : LadderBase
{
	Default
	{
		RenderStyle "Stencil";
		StencilColor "Orange";
		Alpha 0.5;
	}

	override void PostBeginPlay()
	{
		bInvisible = True;

		ladderheight *= scale.y;

		Super.PostBeginPlay();
	}
}

class RopeSegment : LadderBase
{
	Vector3 SpawnPos;
	RopeSegment next, prev;
	double position, shotpitch, shotdist, offset, sag, period;
	int time;

	Property Sag:sag;

	Default
	{
		+NOGRAVITY
		+SOLID
		Radius 2;
		Height 2;
		RenderStyle "Translucent";
		Alpha 1.0;
		LadderBase.LadderHeight 2;
		LadderBase.DisallowMonsters False;
		LadderBase.ClimbRadius 12;
		LadderBase.Friction 0.85; // Slower than a ladder
		RopeSegment.Sag 1.0;
	}

	States
	{
		Spawn:
			ROPE A 1;
			Loop;
		Knot:
			ROPE B 1;
			Loop;
	}

	override void PostBeginPlay()
	{
		SpawnPos = pos;

		if (target && target is "RopeSpawner")
		{
			user_soundtype = RopeSpawner(target).user_soundtype;
			if (RopeSpawner(target).user_sag > 0) { sag = RopeSpawner(target).user_sag; }

			shotdist = RopeSpawner(target).HitDistance;

			if (!shotdist) // Shouldn't ever happen, but just in case...
			{
				if (developer) { console.printf("\cgERROR: \cjRope failed to draw at \cf%i, %i, %i\cj.", pos.x, pos.y, pos.z); }
				Destroy();

				return;
			} 

			shotpitch = pitch;
			position = Distance3D(target) / shotdist;

			RopeSpawner(target).Segments.Push(self);

			scale.x *= target.scale.x;
			scale.y *= target.scale.y;

			Reposition();
		}

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (globalfreeze || level.Frozen) { return; }

		if (shotdist) { Super.Tick(); }
	}

	void Reposition()
	{
		offset = (shotdist * 0.018 * sag) * -sin(position * 180) * cos(-shotpitch);
		SetOrigin((SpawnPos.x, SpawnPos.y, SpawnPos.z + offset), false);

		pitch = shotpitch + (shotdist * 0.0036 * sag) * cos(position * 180) * cos(-shotpitch);
	}
}

class RopeSpawner : Actor
{
	double HitDistance;
	int soundtimeout;
	int user_soundtype;
	int user_maxlength;
	double user_sag;
	Class<RopeSegment> seg;
	Array<RopeSegment> Segments;
	bool initialized;
	int timeout;
	double zoffset;
	double spacing;

	Property SegmentActor:seg;
	Property SoundSet:user_soundtype;
	Property ZOffset:zoffset;
	Property Spacing:spacing;

	Default
	{
		Height 0;
		Radius 4;

		RopeSpawner.SegmentActor "RopeSegment";
		RopeSpawner.SoundSet 1;
		RopeSpawner.Spacing 3.0;
	}

	States
	{
		Spawn:
			UNKN A 1;
			Loop;
	}

	override void PostBeginPlay()
	{
		if (!user_maxlength) { user_maxlength = 1024; }
		if (!user_sag) { user_sag = -1.0; } // Defaults to whatever is set in the segment, but can be overriden by anything over 0;

		bInvisible = true;

		if (tid)
		{
			target = FindTarget();
			if (target) { A_Face(target, 0, 0); }
		}

		FLineTraceData trace;
		LineTrace(angle, user_maxlength, pitch, TRF_THRUACTORS, 0.0, 0.0, 0.0, trace);
		HitDistance = trace.Distance;

		A_CustomRailgun(0, 0, "", "", RGF_CENTERZ | RGF_NOPIERCING | RGF_SILENT, 0, 0, "", 0, 0, trace.Distance, 1, spacing * scale.x, 0, seg, zoffset * scale.y);

		timeout = level.time + 35;

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		Super.Tick();

		if (!initialized && level.time > timeout)
		{
			if (Segments.Size())
			{
				RopeSegment first = Segments[0];
				RopeSegment last = Segments[Segments.Size() - 1];

				if (pitch == 90 || abs(pitch != 90))
				{
					first.SetStateLabel("Knot");
				}

				if (pitch == -90 || abs(pitch != 90))
				{
					last.SetStateLabel("Knot");
					last.pitch += 180;
				}

				initialized = true;	
			}
		}

		soundtimeout = soundtimeout <= 0 ? 15 : soundtimeout - 1;
	}

	Actor FindTarget()
	{
		ThinkerIterator it = ThinkerIterator.Create("RopeSpawnerTarget", Thinker.STAT_DEFAULT - 7);
		Actor mo;

		while (mo = Actor(it.Next(true)))
		{
			if (mo.tid == tid)
			{
				return mo;
			}
		}

		return null;
	}
}

class RopeSpawnerTarget : MapSpot
{
	override void BeginPlay()
	{
		ChangeStatNum(Thinker.STAT_DEFAULT - 7);
	}
}

class CableSegment : RopeSegment
{
	Default
	{
		RopeSegment.Sag 0.0;
	}
}

class CableSpawner : RopeSpawner
{
	Default
	{
		RopeSpawner.SegmentActor "CableSegment";
		RopeSpawner.SoundSet 3;
	}
}

class BridgeSegment : RopeSegment
{
	Default
	{
		+ROLLSPRITE
		+FLATSPRITE
		Radius 32;
		Scale 0.75;
		LadderBase.Friction 1.0;
	}

	States
	{
		Spawn:
			BBRD A 1;
		Knot:
			BBRD # 1;
			Loop;
	}

	override void PostBeginPlay()
	{
		Roll = Random(-5, 5);

		frame = Random(0, 7);
		Scale.X *= RandomPick(-1, 1);

		Super.PostBeginPlay();
	}
}

class BridgeSpawner : RopeSpawner
{
	Default
	{
		RopeSpawner.SegmentActor "BridgeSegment";
		RopeSpawner.SoundSet 1;
		RopeSpawner.Spacing 30.0;
		RopeSpawner.ZOffset 2;
	}

	override void Tick()
	{
		initialized = true; // Skip knot placement for these

		Super.Tick();
	}
}