// Parent class that holds functions and logic
class PlayerFollower : Actor //Default version - for actors like prisoner with A as standing frame and B-E walking, FGH firing, I pain, JKLMN Death 
{
	enum FollowerWeapons
	{
		PWEAP_None,
		PWEAP_Luger,
		PWEAP_MP40,
		PWEAP_Rifle
	};

	Array<PathMarker> Markers;
	Actor playerToChase, currentGoal;
	Vector3 oldPlayerPos;
	int index;

	bool oldFriendly;
	int weapon;
	int shots, totalshots;
	double faceangle;
	double startSpeed;
	bool forgettarget; // If true, actor will forget its target if the player moves out of range.  Behavior and following is more predictable, but more realistic for an escaping prisoner (vice a soldier on combat)

	Default
	{
		MONSTER;
		-COUNTKILL
		+DONTHARMSPECIES
		+FLOORCLIP
		+JUMPDOWN
		+NOBLOCKMONST
		+NODAMAGE
		+NOTAUTOAIMED
		+PUSHABLE
		+SLIDESONWALLS
		+AVOIDMELEE
		+WINDTHRUST
		Health 100;
		Height 52;
		Radius 6;
		Mass 100;
		Speed 5;
		PainChance 128;
		MaxStepHeight 56; //Matches max player jump height with standard JumpZ of 8 and MaxStepHeight of 24
		MaxDropOffHeight 512;
		MaxTargetRange 1024;
	}

	States
	{
		Spawn:
			ARH2 A 1;
			Goto Initialize;
		Initialize:
			"####" A 0 {
				startSpeed = Speed;
				oldFriendly = bFriendly; // Force unfriendly, otherwise the LookForPlayers call fails, but save old value for later
				bFriendly = False;
				return ResolveState("Stand"); // For inheritance reasons
			}
		Stand: // Initial setup of actor and identification of what player we want to follow
			"####" A 1;
			"####" A 0 A_FindPlayer();
		Chase.Back: // Used to push actor back when touching player
			"####" EEEEE 1;
			"####" DDDDDCCCCC 1 {
				double pushAngle = AngleTo(playerToChase) + 180;
				Thrust(1, pushAngle);
			}
			"####" BBBBB 1;
		Chase: // Standard goal chasing
			"####" BBBBBCCCCCDDDDDEEEEE 1 A_ChaseGoal();
			"####" A 0 A_SpawnStep();
			Loop;
		Chase.Near: // Near the player, take up defensive position (if armed), otherwise stand stupidly
			"####" AAAAA 1 A_Defend();
			Loop;
		Pain:
			"####" I 4 A_Pain();
			Goto Chase;
		Luger: // Emulates the standard guard pistol - relatively standard
			"####" FG 10 A_FaceTarget();
			Luger.Refire:
				"####" H 8 LIGHT("NaziFire") A_FollowerFire("LugerTracer", "9MMCasing", "nazi/pistol", 54, 1);
				"####" G 8 A_FaceTarget();
 				"####" G 0 A_RefireReload("Luger.Refire", "Luger.Reload");
			Luger.Reload: // More emulation of the guard pistol - 8 shots, then reload
				"####" G 0 { bNoPain = True; }
				"####" G 30 {
					A_PlaySound("luger/reload", CHAN_ITEM, FRandom (0.3, 0.6), FALSE, ATTN_NORM);
					shots = 0;
				}
				"####" G 0 {
					bNoPain = False;
					return ResolveState("Chase.Near");
				}
		MP40: // Emulates the MP40.  Firing pattern similar to the original Wolf3D SS, just because...
			"####" FG 10 {
				A_FaceTarget();
				shots = 0;
			}
			MP40.Refire:
				"####" G 5 A_FaceTarget();
				"####" H 5 LIGHT("NaziFire") A_FollowerFire("MP40Tracer", "9MMCasing", "nazi/mp40", 50, 4);
 				"####" G 0 A_RefireReload("MP40.Refire", "MP40.Reload", 0, 4, 32);
			MP40.Reload: 
				"####" F 0 { bNoPain = True; }
				"####" F 30 {
					A_PlaySound("MP40/reload", CHAN_WEAPON);
					totalshots = 0;
				}
				"####" F 0 {
					bNoPain = False;
					return ResolveState("Chase.Near");
				}
		Rifle:
			"####" FG 6 {
				A_FaceTarget();
				shots = 0;
			}
			Rifle.Refire:
				"####" H 5 LIGHT("NaziFire") A_FollowerFire("ThompsonTracer", "MauserRifleCasing", "nazi/stg44", 38, 4);
				"####" G 5 A_FaceTarget();
 				"####" G 0 A_RefireReload("Rifle.Refire", "Rifle.Reload", 0, 10, 40);
			Rifle.Reload: 
				"####" F 0 { bNoPain = True; }
				"####" F 30 {
					A_PlaySound("sten/reload", CHAN_WEAPON);
					totalshots = 0;
				}
				"####" F 0 {
					bNoPain = False;
					return ResolveState("Chase.Near");
				}
		Death: // Standard Death - unused, since he's invulnerable, but here just in case needed in future
			"####" J 8;
			"####" K 8 A_Scream;
			"####" L 8 A_NoBlocking;
			"####" M 8;
			"####" N -1;
			Stop;
	}

	state A_FindPlayer()
	{
		if (!target)
		{
			LookExParams SearchParams;

			SearchParams.fov = 360;
			SearchParams.minDist = 0;
			SearchParams.maxDist = 1024;
			SearchParams.maxHearDist = 0; //Deaf!

			LookForPlayers(true, SearchParams); // Search (visual only) for a player (pointer assigned as target)
		}

		if (target)
		{
			playerToChase = target; // Save the player that was targeted as who we want to follow
			target = null; // Clear target pointer
			bChaseGoal = True; // Always chase goal, even when firing
			return ResolveState("Chase");
		}
		return ResolveState("Stand");
	}

	void A_SpawnStep()
	{
		Spawn("PlayerStep", (pos.x, pos.y, pos.z + 14));
	}

	state A_ChaseGoal()
	{
		if (!playerToChase) { return ResolveState("Stand"); } // Make sure a player was targeted as who to chase

		bFriendly = oldFriendly; // Restore original friendliness once we're sure we have a player to follow

		if (waterlevel > 1) { // Make him able to "swim" - No proper animation, but he can at least get move up and down in (and get out of) deep water now
			bFloat = True;
			bNoGravity = True;
			Speed == startSpeed / 2;
		} else {
			bFloat = False;
			bNoGravity = False;
			Speed == startSpeed;
		}

		if (playerToChase.health && Distance3d(playerToChase) > 128) { // Run away from danger, but not *too* far away
			bFrightened = False;
		} else {
			bFrightened = True;
		}

		if (Level.time % 5 == 0) { // Spawn a waypoint at the player's position every 5 tics if the player has moved and push it into an array
			if (playerToChase.pos != oldPlayerPos) {
				Actor mo = Spawn("PathMarker", (playerToChase.pos.x + Random[Offset](-12, 12), playerToChase.pos.y, playerToChase.pos.z));
				Markers.Push(mo);
				oldPlayerPos = playerToChase.pos;
			}
		}

		if (Markers.Size() - index >= 100) { // If he's far, far behind, warp halfway along the trail *if* the destination spot isn't in sight of the player.
			if (Markers[index + 50]) {
				if (!Markers[index + 50].IsVisible(playerToChase, True)) {
					SetOrigin(Markers[index + 50].pos, true); // Clean up the now unused markers and array entries
					DestroyMarkers(index, index + 50);
					index += 50;
					weapon = PWEAP_Luger; //Pretend he picked up a pistol and some ammo, somewhere and he will act like a friendly Guard
				}
			}
		}

		if (index < Markers.Size()) { currentGoal = Markers[index]; } // If there's a marker spawned, set it as the goal

		goal = currentGoal;

		A_Chase(null, null); // Use default chase logic to go after our goal without trying to fire

		if (currentGoal && Distance2d(currentGoal) <= 48) { // If within 48 units of goal, good enough - destroy that waypoint, get ready to iterate to the next
			Markers[index].Destroy();
			Markers.Delete(index);
			index++;
		}

		if (currentGoal && Distance3d(playerToChase) < Distance3d(currentGoal)) { // If closer to player than to goal, destroy the old waypoints and start again fresh
			DestroyMarkers();
			return ResolveState(null);
		} else if (playerToChase.health && Distance3d(playerToChase) <= 64) { // If within 64 units of the player, destroy the old waypoints and jump to "Close" state
			DestroyMarkers();
			return ResolveState("Chase.Near");
		}

		return ResolveState(null);
	}

	state A_Defend()
	{
		if (CheckInventory("Luger9mm", 1)) { weapon = PWEAP_Luger; } // Or give him a weapon via script and he will act like a friendly Guard
		if (CheckInventory("MP40", 1)) { weapon = PWEAP_MP40; }

		vel = (0, 0, 0);

		if (weapon) { // If armed, stand in place and fire at enemies
			bFrightened = False;

			LookForEnemies(true);

			if (target && !target.bDormant && CheckSight(target)) { // If you have a target and it's in line of sight...
				A_Chase(null, GetWeaponStateLabel(), CHF_DONTMOVE); // No melee state so he's not quite so mind-numbingly stupid
			} 

			faceangle = playerToChase.angle + 135 + Random[FaceAngle](-15, 15); // Make him look like he might be able to cover your back

			if (abs(angle - faceangle) > 45) { angle = faceangle; }
		}

		if (playerToChase) {
			if (Distance2d(playerToChase) > radius + 128 + playerToChase.radius) { // If player moves too far away, go back to following (and forget the target if forgettarget = True)
				if (forgettarget) { target = null; }
				return ResolveState("Chase");
			} else if (Distance2d(playerToChase) < radius + 16 + playerToChase.radius) { // If too close to player, push away
				return ResolveState("Chase.Back");
			}
			return ResolveState(null);			
		}

		return ResolveState(null);
	}

	void A_FollowerFire(class<Actor> weapontracer, class<Actor> casing, sound weaponsound = "nazi/pistol", int speed = 54, int damage = 1)
	{
		vel = (0, 0, 0);

		A_PlaySound(weaponsound, CHAN_WEAPON);
		A_SpawnProjectile(weapontracer, speed, damage, Random(-8,8), CMF_BADPITCH);
		A_SpawnItemEx(casing, 1, 0, 56, Random(1, 2), Random(-1, 1), Random(1, 2), Random(-55, -80), SXF_NOCHECKPOSITION);
		shots++;
		totalshots++;
	}

	state A_RefireReload(statelabel Refire, statelabel Reload, int chance = 128, int refireshots = 0, int reloadshots = 8)
	{
		if (reloadshots && totalshots >= reloadshots) {
			shots = 0;
			totalshots = 0;
			return ResolveState(Reload);
		}

		if (target && target.health > 0 && CheckSight(target) && (refireshots && shots < refireshots)) {
			A_MonsterRefire(chance, "Chase.Near"); // Re-fires half the time - more than the standard guard does
			return ResolveState(Refire);
		}
		return ResolveState("Chase.Near");
	} 

	statelabel GetWeaponStateLabel()
	{
		static const statelabel MissileStateNames[] = 
		{
			null, "Luger", "MP40", "Rifle"
		};

		return MissileStateNames[weapon];
	}

	// Destroys array-linked actors in the range of the specified indices.  Default is to destroy all of the markers and clear the array.
	void DestroyMarkers(int start = 0, int end = 0)
	{
		if (!end) { end = Markers.Size(); }

		for (int i = start; i < end; i++)
		{
			Actor mo = Markers[i];
			if (mo) { mo.Destroy(); }
			Markers[i] = null;
		}
		if (start == 0 && end == Markers.Size()) {
			Markers.Clear();
			Markers.ShrinkToFit();
			index = 0;
		}
	}
}

class PlayerFollower2 : PlayerFollower // Alternate frames versions - for almost all actors except prisoner, with N as standing frame and A-D walking, EFG firing, H pain, IJKLM Death 
{
	States
	{
		Spawn:
			DARR N 1;
			Goto Initialize;
		Stand:
			"####" N 1;
			"####" N 0 A_FindPlayer();
		Chase.Back:
			"####" DDDDD 1;
			"####" CCCCCBBBBB 1 {
				double pushAngle = AngleTo(playerToChase) + 180;
				Thrust(1, pushAngle);
			}
		Chase:
			"####" AAAAABBBBBCCCCCDDDDD 1 A_ChaseGoal();
			"####" A 0 A_SpawnStep();
			Loop;
		Chase.Near:
			"####" NNNNN 1 A_Defend();
			Loop;
		Pain:
			"####" H 4 A_Pain();
			Goto Chase;
		Luger:
			"####" EF 10 A_FaceTarget();
			Luger.Refire:
				"####" G 8 LIGHT("NaziFire") A_FollowerFire("LugerTracer", "9MMCasing", "nazi/pistol", 54, 1);
				"####" H 8;
 				"####" H 0 A_RefireReload("Luger.Refire", "Luger.Reload");
			Luger.Reload: // More emulation of the guard pistol - 8 shots, then reload
				"####" H 0 { bNoPain = True; }
				"####" H 30 {
					A_PlaySound("luger/reload", CHAN_ITEM, FRandom (0.3, 0.6), FALSE, ATTN_NORM);
					A_SpawnItemEx("9MMCasing", 1, 0, 56, Random(3, 4), Random(-1, 1), Random(2, 4), Random(-55,-80), SXF_NOCHECKPOSITION);
					shots = 0;
				}
				"####" F 0 {
					bNoPain = False;
					return ResolveState("Chase.Near");
				}
		MP40:
			"####" EF 10 {
				A_FaceTarget();
				shots = 0;
			}
			MP40.Refire:
				"####" F 5 A_FaceTarget();
				"####" G 5 LIGHT("NaziFire") A_FollowerFire("MP40Tracer", "9MMCasing", "nazi/mp40", 50, 4);
 				"####" F 0 A_RefireReload("MP40.Refire", "MP40.Reload", 0, 4, 32);
			MP40.Reload: 
				"####" E 0 { bNoPain = True; }
				"####" E 30 {
					A_PlaySound("MP40/reload", CHAN_WEAPON);
					A_SpawnItemEx("9MMCasing", 8, 0, 40, Random(3, 4), Random(-1, 1), Random(2, 4), Random(-55, -80),SXF_NOCHECKPOSITION);
					totalshots = 0;
				}
				"####" E 0 {
					bNoPain = False;
					return ResolveState("Chase.Near");
				}
		Rifle:
			"####" EF 6 {
				A_FaceTarget();
				shots = 0;
			}
			Rifle.Refire:
				"####" G 5 LIGHT("NaziFire") A_FollowerFire("ThompsonTracer", "MauserRifleCasing", "nazi/stg44", 38, 4);
				"####" F 5 A_FaceTarget();
 				"####" F 0 A_RefireReload("MP40.Refire", "MP40.Reload", 0, 10, 40);
			Rifle.Reload: 
				"####" E 0 { bNoPain = True; }
				"####" E 30 {
					A_PlaySound("sten/reload", CHAN_WEAPON);
					totalshots = 0;
				}
				"####" E 0 {
					bNoPain = False;
					return ResolveState("Chase.Near");
				}
		Death:
			"####" I 8;
			"####" J 8 A_Scream;
			"####" K 8 A_NoBlocking;
			"####" L 8;
			"####" M -1;
			Stop;
	}
}

// Minimal actor to use as waypoints
class PathMarker : Actor
{
	Default
	{
		+NOINTERACTION
		+NOTONAUTOMAP 
		Height 0;
		Radius 0;
	}
	
	States
	{
		Spawn:
			TNT1 A -1;
			Stop;
	}
}

// Original Prisoner follower
// Actual Prisoner Agent inherits everything from PlayerFollower
class PrisonerAgent : PlayerFollower
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs
		//$Title Cpt. James Ryan (Friendly Follower - Prisoner)
		//$Color 4

		+FRIENDLY
		+NOINFIGHTING
		Speed 6; // He can't run as fast as you can, so will usually lag behind
		Mass 50; // He's a lightweight so that if he annoyingly boxes you in, he's easy to shove out of the way
		Scale 1.3;
		Obituary "$PRISONER"; 
		Species "PlayerFollower";
	}

	States
	{
		Spawn:
			TORT A 1;
			TORT A 0 { forgettarget = True; }
			Goto Initialize;
	}
}

//Ryan Armed followers
class AgentArmed : PrisonerAgent
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs
		//$Title Cpt. James Ryan (Friendly Follower - Luger)
		//$Color 4

		Radius 16; // Match player radius
		Speed 8; // A bit faster than the beat up prisoner version
		Mass 100;
		PainChance 64;
		Obituary "$AGENT";
	}

	States
	{
		Spawn:
			FREE A 1;
			FREE A 1 { weapon = PWEAP_Luger; } // Armed with Luger
			Goto Initialize;
	}
}

class AgentArmedMP40 : AgentArmed
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs
		//$Title Cpt. James Ryan (Friendly Follower - MP40)
		//$Color 4
	}

	States
	{
		Spawn:
			FREE A 1;
			FREE A 1 { weapon = PWEAP_MP40; } // Armed with MP40 (Sprites dont' match, right now, though, just like the boss version)
			Goto Initialize;
	}
}

//Not-Darren follower
class DouglasArmed : PlayerFollower2
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs
		//$Title Dirty Douglas (Friendly Follower - Pistol)
		//$Color 4

		+FRIENDLY
		+NOINFIGHTING
		Radius 16;
		Speed 7;
		Mass 100;
		PainChance 64;
		Obituary "$AGENT";
		Translation 1;
		Scale 1.23;
		Species "PlayerFollower";
	}

	States
	{
		Spawn:
			DARR A 1;
			DARR A 1 { weapon = PWEAP_Luger; }
			Goto Initialize;
	}
}

// Armed soldier followers
class SoldierArmed : PlayerFollower
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs
		//$Title Soldier (Friendly Follower - Pistol)
		//$Color 4

		+FRIENDLY
		+NOINFIGHTING
		Radius 16;
		Speed 7;
		Mass 100;
		PainChance 64;
		Obituary "$AGENT";
		Translation 1;
		Scale 1.3;
		Species "PlayerFollower";
	}

	States
	{
		Spawn:
			ARH2 A 1;
			ARH2 A 1 { weapon = PWEAP_Luger; }
			Goto Initialize;
	}
}

class SoldierArmedRifle : SoldierArmed
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs
		//$Title Soldier (Friendly Follower - Machine Gun)
		//$Color 4
	}

	States
	{
		Spawn:
			ARMH A 1;
			ARMH A 1 { weapon = PWEAP_Rifle; }
			Goto Initialize;
	}
}