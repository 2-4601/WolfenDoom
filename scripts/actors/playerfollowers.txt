/*

  An actor that will stand dormant until it sees a player, then will follow that player.
  The actor can be set to carry a specific weapon.

  Custom Properties:
	PlayerFollower.Weapon
	- Weapon that the PlayerFollower will spawn with, set based on FollowerWeapons Enum
	  below (e.g., PWEAP_None, PWEAP, Luger, etc.)

	PlayerFollower.CloseFollow
	- If true, actor will immediately forget its target if the player moves out of range.
	- This has the effect of making the actor follow the player more closely
	- Behavior and following is more predictable, but more realistic for an escaping
	  prisoner (vice a soldier in combat)

	PlayerFollower.ChaseAttackChance
	- Chance that the actor will stop while chasing to attack enemies - because of how
	  often this check is performed, values will need to be *very* low (e.g., 2-4) to see
	  any change in actor behavior.

	PlayerFollower.FOV
	- FOV used for look/search/sight calls

	PlayerFollower.GrenadeChance
	- Chance of using grenades.  By default, the actor has an infinite supply of grenades.
	- Alternatively, if you give the actor a specific number of grenades via a script,
	  then the PlayerFollower will throw up to that many grenades, then no more.

	PlayerFollower.CanBeCommanded
	- Determines if you can make the NPC follow/stop following you by pressing 'use' on them
	- Defaults to false.

  Useful Variables:
	These are intended to be set via ACS using 'SetUserVariable(tid, "variable", value);'

	nocatchup (default is 0)
	- Normally, if a PlayerFollower falls 100 pathmarkers behind the player, the actor
	  will be warped ahead to the 50th pathmarker (if the player can't see the marker)
	- Setting this boolean to 1 disables that behavior.  This is useful if you want to
	  force a PlayerFollower along a certain route in the map, and don't want him skipping
	  ahead.
	- Be cautious!  If the PlayerFollower gets stuck somwhere in the level geometry while
	  this is set, then the PlayerFollower will never be able to become un-stuck.

	user_nonmoving (default is 0)
	- Setting this boolean to 1 causes the PlayerFollower to stand in place and not
	  follow the player anymore.
	- This differs from being dormant/Deactivated in that the PlayerFollower will still
	  look for players, look for enemies, and open fire on enemies.

  Editing Tricks:
	Block the PlayerFollower
	- Normally the PlayerFollowers are not blocked by Monster-Blocking lines.  If you want
	  to limit where a PlayerFollower can go, just remove the NOBLOCKMONST flag in ACS:

		SetActorFlag(tid, "NOBLOCKMONST", 0);

	  Then place monster blocking lines in the map, and the PlayerFollower won't be able to
	  cross them.

	Change PlayerFollower Weapon
	- You can change the weapon that a PlayerFollower is carrying by giving them a new weapon
	  via ACS.  Note that the weapon must be one of those that is coded below...
	- Valid weapons are: Luger9mm, MP40, Sten, KnifeSilent (and GrenadePickup, as discussed in
	  the PlayerFollower.GrenadeChance property section above)

*/

// Parent class that holds functions and logic
class PlayerFollower : Actor //Default version - for actors like prisoner with A as standing frame and B-E walking, FGH firing, I pain, JKLMN Death
{
	enum FollowerWeapons
	{
		PWEAP_None, // 0
		PWEAP_Melee, // 1
		PWEAP_Luger, // 2
		PWEAP_MP40, // 3
		PWEAP_Rifle, // 4
		PWEAP_Grenade // 5
	};

	Array<PathMarker> Markers;
	Actor playerToChase, currentGoal;
	Vector3 oldPlayerPos;
	int index;

	int weapon;
	int shots, totalshots;
	double faceangle;
	double startSpeed;
	bool forgettarget;
	int chaseattackchance;
	LookExParams SearchParams;
	int fov;
	int grenadechance;
	bool countgrenades;
	bool nocatchup;
	bool nonmoving, user_nonmoving;
	bool allowinteraction;
	int oldwaterlevel;
	int activationcount;
	String head;

	Property Weapon:weapon; // Weapon set based on FollowerWeapons Enum
	Property CloseFollow:forgettarget; // If true, actor will immediately forget its target if the player moves out of range.  Behavior and following is more predictable, but more realistic for an escaping prisoner (vice a soldier in combat)
	Property ChaseAttackChance:chaseattackchance; // Chance that the actor will stop while chasing to attack
	Property FOV:fov; // FOV used for look/search/sight calls
	Property GrenadeChance:grenadechance; // Chance of using grenades (and gives him grenades, so anything over 0 will throw grenades at some point)
	Property CanBeCommanded:allowinteraction;
	Property Head:head;

	Default
	{
		MONSTER;
		-COUNTKILL
		+AVOIDMELEE
		+DONTHARMSPECIES
		+FLOORCLIP
		+JUMPDOWN
		+NOBLOCKMONST
		+NODAMAGE
		+NOTAUTOAIMED
		+PUSHABLE
		+SLIDESONWALLS
		+WINDTHRUST
		Health 100;
		Height 52;
		Radius 16;
		Mass 100;
		Speed 5;
		PainChance 128;
		MaxStepHeight 56; //Matches max player jump height with standard JumpZ of 8 and MaxStepHeight of 24
		MaxDropOffHeight 512;
		MaxTargetRange 2048;
		PlayerFollower.Weapon PWEAP_None;
		PlayerFollower.CloseFollow False;
		PlayerFollower.ChaseAttackChance 32;
		PlayerFollower.FOV 100;
		PlayerFollower.GrenadeChance 0;
		PlayerFollower.CanBeCommanded False;
		PlayerFollower.Head "MS_SOLD";
	}

	States
	{
		Spawn:
			ARH2 A 1;
			Goto Initialize;
		Initialize:
			"####" A 0 {
				startSpeed = Speed;
				A_SetTics(Random[Startup](0, 15));
				return ResolveState("Stand"); // Jump via ResolveState versus Goto for inheritance reasons
			}
		Stand: // Initial setup of actor and identification of what player we want to follow
			"####" A 1;
			"####" A 0 A_FindPlayer();
		Chase.Back: // Used to push actor back when touching player
			"####" EEEEE 1;
			"####" DDDDDCCCCC 1 {
				double pushAngle = AngleTo(playerToChase) + 180;
				Thrust(1, pushAngle);
			}
			"####" BBBBB 1;
		Chase: // Standard goal chasing
			"####" BBBBBCCCCC 1 A_ChaseGoal();
			"####" C 0 A_SpawnStep();
			"####" DDDDDEEEEE 1 A_ChaseGoal();
			"####" E 0 A_SpawnStep();
			Loop;
		Chase.Near: // Near the player, take up defensive position (if armed), otherwise stand stupidly
			"####" AAAAA 1 A_Defend();
			Loop;
		Chase.Stand: // Wherever standing, take up defensive position (if armed), otherwise stand stupidly
			"####" AAAAA 1 A_Defend(false);
			"####" A 0 { if (!nonmoving) { return ResolveState("Chase"); } return ResolveState(null); }
			Loop;
		Pain:
			"####" I 1 A_SpawnItemEx("Pain_Overlay", Scale.X+3, 0, Height-8, 0, 0, 0, 0, SXF_NOCHECKPOSITION | SXF_USEBLOODCOLOR);
			"####" I 3 {
				A_Pain();
				bFrightened = True;
			}
			Goto Chase;
		Luger: // Emulates the standard guard pistol - relatively standard
			"####" FG 10 A_FaceTarget();
			Luger.Refire:
				"####" H 8 LIGHT("NaziFire") A_FollowerFire("LugerTracer", "9MMCasing", "nazi/pistol", 54, 1);
				"####" G 8 A_FaceTarget();
 				"####" G 0 A_RefireReload("Luger.Refire", "Luger.Reload");
			Luger.Reload: // More emulation of the guard pistol - 8 shots, then reload
				"####" G 0 { bNoPain = True; }
				"####" G 30 {
					A_PlaySound("luger/reload", CHAN_ITEM, FRandom (0.3, 0.6), FALSE, ATTN_NORM);
					shots = 0;
				}
				"####" G 0 {
					bNoPain = False;
					return ResolveState("Chase");
				}
		MP40: // Emulates the MP40.  Firing pattern similar to the original Wolf3D SS, just because...
			"####" FG 10 {
				A_FaceTarget();
				shots = 0;
			}
			MP40.Refire:
				"####" G 5 A_FaceTarget();
				"####" H 5 LIGHT("NaziFire") A_FollowerFire("MP40Tracer", "9MMCasing", "nazi/mp40", 50, 4);
 				"####" G 0 A_RefireReload("MP40.Refire", "MP40.Reload", 128, 4, 32);
			MP40.Reload:
				"####" F 0 { bNoPain = True; }
				"####" F 30 {
					A_PlaySound("MP40/reload", CHAN_WEAPON);
					totalshots = 0;
				}
				"####" F 0 {
					bNoPain = False;
					return ResolveState("Chase");
				}
		Rifle:
			"####" FG 6 {
				A_FaceTarget();
				shots = 0;
			}
			Rifle.Refire:
				"####" H 5 LIGHT("NaziFire") A_FollowerFire("ThompsonTracer", "MauserRifleCasing", "nazi/stg44", 38, 4);
				"####" G 5 A_FaceTarget();
 				"####" G 0 A_RefireReload("Rifle.Refire", "Rifle.Reload", 128, 10, 40);
			Rifle.Reload:
				"####" F 0 { bNoPain = True; }
				"####" F 30 {
					A_PlaySound("sten/reload", CHAN_WEAPON);
					totalshots = 0;
				}
				"####" F 0 {
					bNoPain = False;
					return ResolveState("Chase");
				}
		Grenade:
			"####" F 16 A_FaceTarget();
			"####" F 10 A_ThrowGrenade();
		Melee:
			"####" FG 2;
			"####" H 8 A_CustomMeleeAttack(Random[Punch](1, 8) * 3, "knife/swing", "knife/swing");
			Goto Chase;
		Death: // Standard Death - unused, since he's invulnerable, but here just in case needed in future
			"####" J 8;
			"####" K 8 A_Scream;
			"####" L 8 A_NoBlocking;
			"####" M 8;
			"####" N -1;
			Stop;
		Heal:
			"####" F 0 {
				A_Playsound("misc/health_pkup");
				A_GiveInventory("Health", 25);
			}
			"####" FFFFFFFFFF 2 {
				String HealParticle = "HealingParticle"; // Use variable to delay actor validation because it's still in DECORATE
				A_SpawnItemEx(HealParticle, random(10,-10), random(10,-10), random(16,64), 0, 0, random(1, 2), 0);
			}
			"####" F 0 {
				if (nonmoving) { return ResolveState("Chase.Stand"); }
				else if (playerToChase && playerToChase.health && Distance3d(playerToChase) <= 64) { return ResolveState("Chase.Near"); }

				return ResolveState("Chase");
			}
			Goto Chase;
	}

	state A_FindPlayer() // Also sets up initial sight parameters
	{
		if (!target)
		{
			LookExParams SearchParams;

			SearchParams.fov = fov;
			SearchParams.minDist = 0;
			SearchParams.maxDist = 1024; // Far less than max distance so they don't just open fire from the other side of the map
			SearchParams.maxHearDist = 1024;

			for (int p = 0; p < MAXPLAYERS; p++) { // Iterate through all of the players and find the closest one
				Actor mo = players[p].mo;

				if (mo) {
					if (!mo.bShootable || mo.health <= 0) { continue; }
					if (players[p].cheats & CF_NOTARGET) { continue; }
					if (!IsVisible(mo, false, SearchParams)) { continue; }
					if (!isFriend(mo)) { continue; }
					if (target && Distance3d(mo) > Distance3d(target)) { continue; }

					target = mo;
				}
			}
		}

		if (target)
		{
			playerToChase = target; // Save the player that was targeted as who we want to follow
			target = null; // Clear target pointer
			bChaseGoal = True; // Always chase goal, even when firing
			return ResolveState("Chase");
		}
		return ResolveState("Stand");
	}

	void A_SpawnStep()
	{
		if (waterlevel == 0)
		{
			Spawn("PlayerStep", (pos.x, pos.y, pos.z + 14));
		}
	}

	state A_ChaseGoal()
	{
		if (!playerToChase || playerToChase.health <= 0) { return ResolveState("Stand"); } // Make sure a player was targeted as who to chase - if he's dead target another player (multiplayer support)

		if (nonmoving) { return ResolveState("Chase.Stand"); }

		if (waterlevel > 1) { // Make him able to "swim" - No proper animation, but he can at least move up and down in (and get out of) deep water now
			bFloat = True;
			bNoGravity = True;
			Speed == startSpeed / 2;
		} else {
			bFloat = False;
			bNoGravity = False;
			Speed = startSpeed;
		}

		if (health > 50 && playerToChase.health && Distance3d(playerToChase) > 128) { // Run away from danger, but not *too* far away
			bFrightened = False;
		} else {
			bFrightened = True;
		}

		if (!nocatchup && Markers.Size() - index >= 100) { // If he's far, far behind, warp halfway along the trail *if* the destination spot and the actor aren't in sight of the player.
			if (Markers[index + 50]) {
				if (!Markers[index + 50].IsVisible(playerToChase, True) && !IsVisible(playerToChase, True)) {
					SetOrigin(Markers[index + 50].pos, true); // Warp to the halfway point
					DestroyMarkers(index, index + 50); // Clean up the now unused markers and array entries
					index += 50;
					if (!weapon) { weapon = PWEAP_Luger; } //Pretend he picked up a pistol and some ammo somewhere, and he will act like a friendly Guard
				}
			}
		}

		if (index < Markers.Size()) { currentGoal = Markers[index]; } // If there's a marker spawned, set it as the goal

		goal = currentGoal;

		A_Chase(null, null); // Use default chase logic to go after our goal without trying to fire

		if (currentGoal && Distance2d(currentGoal) <= max(radius + playerToChase.Radius, 48)) { // If within 48 units of goal, good enough - destroy that waypoint, get ready to iterate to the next
			Markers[index].Destroy();
			Markers.Delete(index);
			index++;
		}

		if (currentGoal && Distance3d(playerToChase) < Distance3d(currentGoal)) { // If closer to player than to goal, destroy the old waypoints and start again fresh
			DestroyMarkers();
			return ResolveState(null);
		} else if (playerToChase.health && Distance3d(playerToChase) <= 64)
		{ // If within 64 units of the player, destroy the old waypoints and jump to "Close" state.  Has to be this close so that he can follow you into elevators
			DestroyMarkers();
			return ResolveState("Chase.Near");
		}

		if (health > 25 && weapon && Random[ShootBack]() < chaseattackchance || target && Distance2d(target) < radius + 64 + target.Radius) { // Some chance that if he's armed, he'll stop while chasing to attack
			return A_Defend(false);
		}

		if (health < 75 && Random[Heal]() < 8) { return ResolveState("Heal"); }

		return ResolveState(null);
	}

	state A_Defend(bool atPlayer = true)
	{
		bNoRadiusDmg = False;

		if (CheckInventory("KnifeSilent", 1)) { weapon = PWEAP_Melee; }
		if (CheckInventory("Luger9mm", 1)) { weapon = PWEAP_Luger; } // Or give him a weapon via script and he will act like a friendly Guard
		if (CheckInventory("MP40", 1)) { weapon = PWEAP_MP40; }
		if (CheckInventory("Sten", 1)) { weapon = PWEAP_Rifle; }

		if (CheckInventory("GrenadePickup", 1)) { countgrenades = True; grenadechance = grenadechance ? grenadechance : 16; } // If they have a grenade, use it - if they were given as inventory, count them!
		if (countgrenades && !CheckInventory("GrenadePickup", 1)) { grenadechance = 0; } // If they used all their grenades, don't throw any more

		vel = (0, 0, 0);

		if (weapon) { // If armed, stand in place and fire at enemies
			if (health > 50) { bFrightened = False; } // Keep retreating until healed if not near a player

			if (target == goal) { target = null; }

			if (!target) {
				if (playerToChase && players[playerToChase.PlayerNumber()].attacker) { target = players[playerToChase.PlayerNumber()].attacker; }
			}

			if (!target || target.health <= 0) { target = null; }

			ThinkerIterator Finder = ThinkerIterator.Create("Nazi", Thinker.STAT_DEFAULT);
			Actor mo;

			while ( (mo = Actor(Finder.Next())) )
			{
				if (
					mo.health <= 0 ||
					mo.bDormant ||
					mo.bFriendly == bFriendly ||
					mo.GetSpecies() == Species ||
					Distance3d(mo) > MaxTargetRange
				) { continue; }

				if (target && Distance3d(mo) > Distance3d(target)) { continue; }
				if (target && target.bCountKill > mo.bCountKill) { continue; }

				target = mo;
			}

			// Also look for sneakable actors, and ignore their friendliness attribute
			Finder = ThinkerIterator.Create("Nazi", Thinker.STAT_DEFAULT - 5);

			while ( (mo = Actor(Finder.Next())) )
			{
				if (
					mo.health <= 0 ||
					mo.bDormant ||
					mo.GetSpecies() == Species ||
					Distance3d(mo) > MaxTargetRange
				) { continue; }

				if (target && Distance3d(mo) > Distance3d(target)) { continue; }

				target = mo;
			}

			if (!target) {
				LookForEnemies(true); // In no Nazis around, fall back to default algorithm to find an enemy to shoot at
			}

			if (
				target &&
				target.health > 0 &&
				target != goal &&
				!target.bDormant &&
				target.GetSpecies() != Species &&
				CheckSight(target)
			)
			{ // If you have a valid target and it's in line of sight...
				if (target && Distance3d(target) < 64 + Random(0, 128)) { // ...run away from danger if it's too close...  (with some randomness so he doesn't always park himself a set distance from an enemy)
					bFrightened = True;
				}

				if (!nonmoving && (Distance2d(playerToChase) > radius + 128 + playerToChase.radius && forgettarget)) { // ...and if you weren't supposed to forget your target when the player is away...
					target = null;
					goal = playerToChase;
				} else {
					if (weapon != PWEAP_Melee || Distance3d(target) < radius + 32 + target.radius) { // ...and you are in range...
						return ResolveState(GetWeaponStateLabel()); // ...attack it
					}
				}
			}
		}

		if (playerToChase && atPlayer) {
			if (!target) {
				faceangle = playerToChase.angle + 135 + Random[FaceAngle](-15, 15); // Make him look like he might be able to cover your back
				if (abs(angle - faceangle) > 45) { angle = faceangle; }
			}

			if (Distance2d(playerToChase) > radius + 128 + playerToChase.radius) { // If player moves too far away, go back to following (and forget the target if forgettarget = True)
				if (forgettarget) { target = null; }
				return ResolveState("Chase");
			} else if (Distance2d(playerToChase) < radius + 16 + playerToChase.radius) { // If too close to player, push away
				return ResolveState("Chase.Back");
			}
		}

		if (!atPlayer && health < 75 && Random[Heal]() < 8) { return ResolveState("Heal"); }

		return ResolveState(null);
	}

	void A_FollowerFire(class<Actor> weapontracer, class<Actor> casing, sound weaponsound = "nazi/pistol", int speed = 54, int damage = 1)
	{
		vel = (0, 0, 0);

		A_PlaySound(weaponsound, CHAN_WEAPON);
		A_AlertMonsters(0, AMF_TARGETEMITTER);
		A_SpawnProjectile(weapontracer, speed, damage, Random(-8,8), CMF_BADPITCH);
		A_SpawnItemEx(casing, 1, 0, 56, Random(1, 2), Random(-1, 1), Random(1, 2), Random(-55, -80), SXF_NOCHECKPOSITION);
		shots++;
		totalshots++;
	}

	state A_RefireReload(statelabel Refire, statelabel Reload, int chance = 128, int refireshots = 0, int reloadshots = 8)
	{
		if (reloadshots && totalshots >= reloadshots) {
			shots = 0;
			totalshots = 0;
			return ResolveState(Reload);
		}

		if (target && target.health > 0 && CheckSight(target) && (refireshots && shots < refireshots)) {
			A_MonsterRefire(chance, "Chase.Near"); // Re-fires half the time - more than the standard guard does
			return ResolveState(Refire);
		}
		return ResolveState("Chase");
	}

	void A_ThrowGrenade(int variance = 5)
	{
		if (playerToChase.Distance3d(target) > 128)
		{
			bNoRadiusDmg = True;
			A_SpawnProjectile("HandGrenade", 60, 0, Random[Grenade](-variance, variance), CMF_OFFSETPITCH | CMF_SAVEPITCH | CMF_BADPITCH, FRandom[Grenade](variance, 15 * (GetZAt(0, 0, 0, GZF_CEILING) / 128.0)));
			TakeInventory("GrenadePickup", 1);
		}
	}

	statelabel GetWeaponStateLabel()
	{
		static const statelabel MissileStateNames[] =
		{
			null, "Melee", "Luger", "MP40", "Rifle", "Grenade"
		};

		if (Random[GrenadeToss]() < grenadechance) { return MissileStateNames[PWEAP_Grenade]; } // Always randomly toss grenades if he has them

		return MissileStateNames[weapon];
	}

	// Destroys array-linked actors in the range of the specified indices.  Default is to destroy all of the markers and clear the array.
	void DestroyMarkers(int start = 0, int end = 0)
	{
		if (!end) { end = Markers.Size(); }

		for (int i = start; i < end; i++)
		{
			Actor mo = Markers[i];
			if (mo) { mo.Destroy(); }
			Markers[i] = null;
		}
		if (start == 0 && end == Markers.Size()) {
			Markers.Clear();
			Markers.ShrinkToFit();
			index = 0;
		}
	}

	override void PostBeginPlay()
	{
		if (user_nonmoving) { nonmoving = user_nonmoving; } // For compatibility with old ACS scripts from before this variable was given the "user_" prefix

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		Super.Tick();

		if (waterlevel > 0) {
			// Only do this on entering the water
			if (waterlevel > oldwaterlevel && waterlevel == 1) {
				Spawn("PlayerStep", (pos.x, pos.y, pos.z + 14));
			}
		}

		oldwaterlevel = waterlevel;

		if (playerToChase && Level.time % 5 == 0) { // Spawn a waypoint at the player's position every 5 tics if the player has moved and push it into an array
			if (playerToChase.pos != oldPlayerPos) {
				Actor mo = Spawn("PathMarker", (playerToChase.pos.x + Random[Offset](-int(playerToChase.Radius), int(playerToChase.Radius)), playerToChase.pos.y + Random[Offset](-int(playerToChase.Radius), int(playerToChase.Radius)), playerToChase.pos.z));
				if (mo) { Markers.Push(mo); }
				oldPlayerPos = playerToChase.pos;
			}
		}
	}

	override bool Used(Actor user)
	{
		if (!IsFriend(user)) { return false; }

		String message = "";

		if (!Default.user_nonmoving && allowinteraction) { nonmoving = !nonmoving; } // If not set nonmoving by default or disabled, allow toggling...

		if (nonmoving)
		{
			if (allowinteraction)
			{
				ACS_NamedExecuteAlways("FollowerMessage", 0, 0, Random(0, 4)); // Pick a random 'I'll stay here' message
				activationcount = 0;
			}
			else
			{
				ACS_NamedExecuteAlways("FollowerMessage", 0, 1, activationcount); // Pick a random 'I can't move' message
				activationcount = min(activationcount + 1, 4);
			}
		}
		else
		{
			playerToChase = user;

			if (allowinteraction)
			{
				ACS_NamedExecuteAlways("FollowerMessage", 0, 2, Random(0, 4)); // Pick a random 'follow' message
				activationcount = 0;
			}
			else
			{
				ACS_NamedExecuteAlways("FollowerMessage", 0, 3, activationcount); // Pick a random 'I can't leave you' message
				activationcount = min(activationcount + 1, 4);
			}
		}

		return false;
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (
			source &&
			source.health > 0 &&
			source.bShootable &&
			!IsFriend(source) &&
			(!target || Distance3D(source) < Distance3D(target))
		) { target = source; } // If the follower is hit by an enemy that's closer than its current target, change targets to the one that shot it

		return Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}
}

class PlayerFollower2 : PlayerFollower // Alternate frames versions - for almost all actors except prisoner, with N as standing frame and A-D walking, EFG firing, H pain, IJKLM Death
{
	States
	{
		Spawn:
			ARH2 N 1;
			Goto Initialize;
		Stand:
			"####" N 1;
			"####" N 0 A_FindPlayer();
		Chase.Back:
			"####" DDDDD 1;
			"####" CCCCCBBBBB 1 {
				double pushAngle = AngleTo(playerToChase) + 180;
				Thrust(1, pushAngle);
			}
		Chase:
			"####" AAAAABBBBB 1 A_ChaseGoal();
			"####" B 0 A_SpawnStep();
			"####" CCCCCDDDDD 1 A_ChaseGoal();
			"####" D 0 A_SpawnStep();
			Loop;
		Chase.Near:
			"####" NNNNN 1 A_Defend();
			Loop;
		Chase.Stand: // Wherever standing, take up defensive position (if armed), otherwise stand stupidly
			"####" NNNNN 1 A_Defend(false);
			"####" N 0 { if (!nonmoving) { return ResolveState("Chase"); } return ResolveState(null); }
			Loop;
		Pain:
			"####" H 1 A_SpawnItemEx("Pain_Overlay", Scale.X+3, 0, Height-8, 0, 0, 0, 0, SXF_NOCHECKPOSITION | SXF_USEBLOODCOLOR);
			"####" H 3 {
				A_Pain();
				bFrightened = True;
			}
			Goto Chase;
		Luger:
			"####" EF 10 A_FaceTarget();
			Luger.Refire:
				"####" G 8 LIGHT("NaziFire") A_FollowerFire("LugerTracer", "9MMCasing", "nazi/pistol", 54, 1);
				"####" F 8;
 				"####" F 0 A_RefireReload("Luger.Refire", "Luger.Reload");
			Luger.Reload: // More emulation of the guard pistol - 8 shots, then reload
				"####" F 0 { bNoPain = True; }
				"####" F 30 {
					A_PlaySound("luger/reload", CHAN_ITEM, FRandom (0.3, 0.6), FALSE, ATTN_NORM);
					A_SpawnItemEx("9MMCasing", 1, 0, 56, Random(3, 4), Random(-1, 1), Random(2, 4), Random(-55,-80), SXF_NOCHECKPOSITION);
					shots = 0;
				}
				"####" F 0 {
					bNoPain = False;
					return ResolveState("Chase.Near");
				}
		MP40:
			"####" EF 10 {
				A_FaceTarget();
				shots = 0;
			}
			MP40.Refire:
				"####" F 5 A_FaceTarget();
				"####" G 5 LIGHT("NaziFire") A_FollowerFire("MP40Tracer", "9MMCasing", "nazi/mp40", 50, 4);
 				"####" F 0 A_RefireReload("MP40.Refire", "MP40.Reload", 128, 4, 32);
			MP40.Reload:
				"####" E 0 { bNoPain = True; }
				"####" E 30 {
					A_PlaySound("MP40/reload", CHAN_WEAPON);
					A_SpawnItemEx("9MMCasing", 8, 0, 40, Random(3, 4), Random(-1, 1), Random(2, 4), Random(-55, -80),SXF_NOCHECKPOSITION);
					totalshots = 0;
				}
				"####" E 0 {
					bNoPain = False;
					return ResolveState("Chase.Near");
				}
		Rifle:
			"####" EF 6 {
				A_FaceTarget();
				shots = 0;
			}
			Rifle.Refire:
				"####" G 5 LIGHT("NaziFire") A_FollowerFire("ThompsonTracer", "MauserRifleCasing", "nazi/stg44", 38, 4);
				"####" F 5 A_FaceTarget();
 				"####" F 0 A_RefireReload("MP40.Refire", "MP40.Reload", 128, 10, 40);
			Rifle.Reload:
				"####" E 0 { bNoPain = True; }
				"####" E 30 {
					A_PlaySound("sten/reload", CHAN_WEAPON);
					totalshots = 0;
				}
				"####" E 0 {
					bNoPain = False;
					return ResolveState("Chase.Near");
				}
		Melee:
			"####" EF 2;
			"####" G 8 A_CustomMeleeAttack(Random[Punch](1, 8) * 3, "knife/swing", "knife/swing");
			Goto Chase;
		Grenade:
			"####" E 16 A_FaceTarget();
			"####" E 10 A_ThrowGrenade();
		Death:
			"####" I 8;
			"####" J 8 A_Scream;
			"####" K 8 A_NoBlocking;
			"####" L 8;
			"####" M -1;
			Stop;
		Heal:
			"####" E 0 {
				A_Playsound("misc/health_pkup");
				A_GiveInventory("Health", 25);
			}
			"####" EEEEEEEEEE 2 {
				String HealParticle = "HealingParticle"; // Use variable to delay actor validation because it's still in DECORATE
				A_SpawnItemEx(HealParticle, random(10,-10), random(10,-10), random(16,64), 0, 0, random(1, 2), 0);
			}
			Goto Chase.Near;
	}
}

// Minimal actor to use as waypoints
class PathMarker : Actor
{
	Default
	{
		+NOINTERACTION
		+NOTONAUTOMAP
		Height 0;
		Radius 0;
	}

	States
	{
		Spawn:
			TNT1 A -1;
			Stop;
	}
}

///// Player Follower Actors /////

// Original Prisoner follower
class PrisonerAgent : PlayerFollower
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs/Followers
		//$Title Cpt. James Ryan (Friendly Follower - Prisoner)
		//$Color 4

		Radius 6; // Smaller than player radius
		Speed 6; // He can't run as fast as you can, so will usually lag behind
		Scale 0.67;
		+FRIENDLY
		+NOINFIGHTING
		Obituary "$PRISONER";
		Species "PlayerFollower";
		PlayerFollower.CloseFollow True;
		PlayerFollower.ChaseAttackChance 0;
		PlayerFollower.Head "MS_PRIB";
	}

	States
	{
		Spawn:
			TORT A 1;
			Goto Initialize;
	}
}

//Ryan Armed followers
class AgentArmed : PlayerFollower
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs/Followers
		//$Title Cpt. James Ryan (Friendly Follower - Luger)
		//$Color 4

		Speed 8; // A bit faster than the beat-up prisoner version
		PainChance 64;
		Scale 0.67;
		-NODAMAGE
		+BUDDHA
		+FRIENDLY
		+NOINFIGHTING
		Obituary "$FRIENDLY";
		Species "PlayerFollower";
		PlayerFollower.Weapon PWEAP_Luger;
		PlayerFollower.ChaseAttackChance 196;
		PlayerFollower.GrenadeChance 0;
		PlayerFollower.CanBeCommanded True;
		PlayerFollower.Head "MS_PRIS";
	}

	States
	{
		Spawn:
			FREE A 1;
			Goto Initialize;
	}
}

class AgentArmedMP40 : AgentArmed
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs/Followers
		//$Title Cpt. James Ryan (Friendly Follower - MP40)
		//$Color 4

		PlayerFollower.Weapon PWEAP_MP40;
	}
}

class AscherArmed : PlayerFollower
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs/Followers
		//$Title Sgt Ascher (Friendly Follower - Rifle)
		//$Color 4

		Speed 8;
		PainChance 64;
		Scale 0.67;
		-NODAMAGE
		+BUDDHA
		+FRIENDLY
		+NOINFIGHTING
		Obituary "$FRIENDLY";
		Species "PlayerFollower";
		PlayerFollower.Weapon PWEAP_Rifle;
		PlayerFollower.ChaseAttackChance 128;
		PlayerFollower.GrenadeChance 0;
		PlayerFollower.CanBeCommanded True;
		PlayerFollower.Head "MS_OFFC";
	}

	States
	{
		Spawn:
			PARS A 1;
			Goto Initialize;
		Pain:
			"####" J 1 A_SpawnItemEx("Pain_Overlay", Scale.X+3, 0, Height-8, 0, 0, 0, 0, SXF_NOCHECKPOSITION | SXF_USEBLOODCOLOR);
			"####" J 3 {
				A_Pain();
				bFrightened = True;
			}
			Goto Chase;
		Death:
			"####" J 8 A_Scream;
			"####" K 8 A_NoBlocking;
			"####" LMN 8;
			"####" O -1;
			Stop;
	}
}

class SSAscherArmed : PlayerFollower2
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs/Followers
		//$Title SS Sgt Ascher (Friendly Follower - Luger)
		//$Color 4

		Speed 8;
		PainChance 64;
		Scale 0.67;
		-NODAMAGE
		+BUDDHA
		+FRIENDLY
		+NOINFIGHTING
		Obituary "$FRIENDLY";
		Species "PlayerFollower";
		PlayerFollower.Weapon PWEAP_Luger;
		PlayerFollower.ChaseAttackChance 196;
		PlayerFollower.GrenadeChance 0;
		PlayerFollower.Head "MS_OFFS";
	}

	States
	{
		Spawn:
			ASC2 A 1;
			Goto Initialize;
	}
}

//Not-Darren follower
class DouglasArmed : PlayerFollower2
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs/Followers
		//$Title Dirty Douglas (Friendly Follower - Pistol)
		//$Color 4

		Speed 7;
		Obituary "$FRIENDLY";
		Scale 0.67;
		+FRIENDLY
		+NOINFIGHTING
		Translation 1;
		Species "PlayerFollower";
		PlayerFollower.Weapon PWEAP_Luger;
		PlayerFollower.ChaseAttackChance 96;
		PlayerFollower.CanBeCommanded True;
		PlayerFollower.Head "MS_DARR";
	}

	States
	{
		Spawn:
			DARR A 1;
			Goto Initialize;
	}
}

// Armed soldier followers
class SoldierArmed : PlayerFollower
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs/Followers
		//$Title Soldier (Friendly Follower - Pistol)
		//$Color 4

		Speed 7;
		PainChance 64;
		Scale 0.67;
		+FRIENDLY
		+NOINFIGHTING
		Obituary "$FRIENDLY";
		Species "PlayerFollower";
		PlayerFollower.Weapon PWEAP_Luger;
		PlayerFollower.CanBeCommanded True;
	}

	States
	{
		Spawn:
			ARH2 A 1;
			Goto Initialize;
	}
}

class SoldierArmedRifle : SoldierArmed
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs/Followers
		//$Title Soldier (Friendly Follower - Machine Gun)
		//$Color 4

		PlayerFollower.Weapon PWEAP_Rifle;
	}

	States
	{
		Spawn:
			ARMH A 1;
			Goto Initialize;
	}
}

class DogFollower : PlayerFollower2
{
	Default
	{
		//$Category Monsters (Wolf3D)/NPCs/Followers
		//$Title German Shepherd (Friendly Follower - Melee)
		//$Color 4

		Speed 4;
		Scale 0.67;
		+FRIENDLY
		+NOINFIGHTING
		PlayerFollower.ChaseAttackChance 256;
		PlayerFollower.Weapon PWEAP_Melee;
		PlayerFollower.Head "";
	}

	States
	{
		Spawn:
			DOG2 A 1;
			Goto Initialize;
		Stand:
			"####" A 1;
			"####" A 0 A_FindPlayer();
		Chase.Back:
			"####" DDDD 1;
			"####" CCCCBBBB 1 {
				double pushAngle = AngleTo(playerToChase) + 180;
				Thrust(1, pushAngle);
			}
		Heal: // Dogs can't heal themselves.
		Chase:
			"####" A 0 { Speed = 8; }
			"####" AAAABBBB 1 A_ChaseGoal();
			"####" B 0 A_SpawnStep();
			"####" CCCCDDDD 1 A_ChaseGoal();
			"####" D 0 A_SpawnStep();
			Loop;
		Chase.Near:
			"####" A 0 { Speed = 4; }
			"####" A 0 A_Defend();
			"####" AAA 1 A_Chase(null, null);
			"####" A 0 A_Defend();
			"####" BBB 1 A_ChaseGoal();
			"####" B 0 A_SpawnStep();
			"####" A 0 A_Defend();
			"####" CCC 1 A_Chase(null, null);
			"####" A 0 A_Defend();
			"####" DDD 1 A_ChaseGoal();
			"####" D 0 A_SpawnStep();
			Loop;
		Pain:
			"####" M 4 A_Pain();
			Goto Chase;
		Melee:
			"####" EF 2 Fast A_FaceTarget();
			"####" G 8 Fast A_CustomMeleeAttack(Random[Bite](1, 8) * 3, "dog/attack", "dog/attack");
			"####" G 0 A_AlertMonsters(0, AMF_TARGETEMITTER);
			"####" FE 2 Fast;
			Goto Chase;
		Death:
			"####" H 8;
			"####" I 8 A_Scream;
			"####" J 8;
			"####" K -1 A_NoBlocking;
			Stop;
	}
}