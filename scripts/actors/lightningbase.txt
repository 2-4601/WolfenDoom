// Lots of bits and pieces from D4D's Lightning Gun used originally... Significantly modified by AFADoomer.

const BEAM_FLAGS = SXF_NOCHECKPOSITION | SXF_TRANSFERSCALE | SXF_TRANSFERPITCH | SXF_TRANSFERPOINTERS;

Class LightningPuff : Actor
{
	Default 
	{
		Radius 0;
		Height 0;
		Projectile;
		+ALWAYSPUFF
		+BLOODLESSIMPACT
		+DONTSPLASH
		+NOINTERACTION
		+NOTONAUTOMAP
		+PUFFGETSOWNER
		+PUFFONACTORS
		+SKYEXPLODE
		RenderStyle "None";
		Decal "RailScorchLower";
		DamageType "Electric";
	}

	States
	{
		Spawn:
			TNT1 A 10;
			Stop;
	}
}

// Base class that spawns the actual beam segments
Class LightningBeam : Actor 
{
	Vector3 AimPoint;

	Actor closest;
	Actor origin;
	String trail;
	bool targets;
	double AngleRandom;
	double CurDistance;
	double MaxDistance;
	double MaxScale;
	double MinScale;
	double PitchRandom;
	double StepDistance;
	double faceamt;
	double splitamt;
	double stepfactor;
	int Choke;
	int ChokeMax;
	int ChokeMin;
	int child;

	Property AllowSplit:splitamt;
	Property AngleRandom:AngleRandom;
	Property ChokeMax:ChokeMax;
	Property ChokeMin:ChokeMin;
	Property FaceAmount:faceamt;
	Property MaxDistance:MaxDistance;
	Property MaxScale:MaxScale;
	Property MinScale:MinScale;
	Property PitchRandom:PitchRandom;
	Property StepFactor:stepfactor;
	Property TrailActor:trail;
	Property targets:targets;

	Default 
	{
		+NOBLOCKMAP
		+NOINTERACTION
		RenderStyle "None";

		LightningBeam.AngleRandom 5;
		LightningBeam.ChokeMax 3;
		LightningBeam.ChokeMin 1;
		LightningBeam.FaceAmount 15;
		LightningBeam.MaxDistance 1024;
		LightningBeam.MaxScale 0.03;
		LightningBeam.MinScale 0.0125;
		LightningBeam.PitchRandom 5;
		LightningBeam.StepFactor 1;
		LightningBeam.TrailActor "LightningTrailBeamArc";
	}

	States
	{
		Spawn:
			TNT1 A 1 NoDelay A_SpawnBeam();
			Stop;
	}

	override void PostBeginPlay()
	{
		if (master)
		{
			origin = master;
		}

		Choke = random(ChokeMin, ChokeMax);

		StepDistance = Random[steps](5, 7) * stepfactor;

		if (Scale.X == 1.0) { Scale.X = MaxScale; }

		Scale.Y = StepDistance;

		if (AimPoint == (0, 0, 0))
		{
			FLineTraceData trace;
			LineTrace(angle, MaxDistance, pitch, TRF_THRUHITSCAN | TRF_THRUACTORS, 0.0, 0.0, 0.0, trace);

			AimPoint = trace.HitLocation;
		}

		tracer = Spawn("TargetActor", AimPoint);

		Super.PostBeginPlay();
	}

	void A_SpawnBeam()
	{
		Actor prev;

		While (CurDistance < MaxDistance)
		{
			bool spawned;
			Actor t;

			if (targets)
			{
				closest = ClosestMonster();
				if (closest) { tracer = closest; }
			}

			A_FaceTracer(faceamt, faceamt, 0, 0, FAF_MIDDLE);

			Scale.X = MinScale + (MaxDistance - CurDistance) * (MaxScale - MinScale) / MaxDistance;

			if (
				(
					!(master is "PlayerPawn") ||
					CurDistance > Min(32, MaxDistance / 4)
				) &&
				CurDistance < (MaxDistance - StepDistance)
			)
			{
				// D4D Code
				// If we're not about to reach the end, or not hitting the 
				// Choker, randomize it. Otherwise, stay on target and go 
				// for the puff.
				if (Choke > 0)
				{
					pitch = pitch + PitchRandom * RandomPick[pitchdir](-1, 1);
					angle = angle + AngleRandom * RandomPick[angledir](-1, 1);

					Choke--;
				}
				else 
				{
					Choke = Random(ChokeMin, ChokeMax);
				}

				// Spawn a split from the main beam
				if (splitamt > 0 && scale.x > 0.001 && Random[split]() < 10 * splitamt * (child + 1) && child < ChokeMax + 2)
				{
					[spawned, t] = A_SpawnItemEx(self.GetClass(), cos(pitch), 0, -sin(pitch), 0, 0, 0, 0, BEAM_FLAGS);
					if (spawned) {
						t.master = master;
						t.pitch = FRandom(pitch - PitchRandom, pitch + PitchRandom);
						t.angle = FRandom(angle - AngleRandom, angle + AngleRandom);
						t.tracer = tracer;
						LightningBeam(t).AimPoint = AimPoint;
						LightningBeam(t).MaxDistance = 32;
						LightningBeam(t).child = child + 1;
						LightningBeam(t).StepFactor = stepfactor;
						LightningBeam(t).StepDistance = stepdistance;
						LightningBeam(t).MaxScale = scale.x;
						LightningBeam(t).closest = closest;
						t.scale.x = scale.x / (child + 1);
					}
				}
			}

			// D4D Code
			// Spawn the beam with the same angle and pitch. Note that the
			// beam is being centered so we have to take that into account
			// and spawn it FORWARD based on half the beam's length.
			// Then move forward by a beam's length and repeat until done.
			[spawned, t] = A_SpawnItemEx(trail, cos(pitch) * (StepDistance / 2.0), 0, -sin(pitch) * (StepDistance / 2.0), 0, 0, 0, 0, BEAM_FLAGS);
			if (spawned)
			{
				if (t.waterlevel > 0)
				{
					if (pitch != 0)
					{
						t.Destroy(); // Destroy this one and spawn a new one with flat pitch, so it goes along the surface of the water

						pitch = 0;
						PitchRandom = 0;
						AngleRandom = 45;

						[spawned, t] = A_SpawnItemEx(trail, cos(pitch) * (StepDistance / 2.0), 0, -sin(pitch) * (StepDistance / 2.0), 0, 0, 0, 0, BEAM_FLAGS);
					}

					if (t) { ElectrifySector(t.CurSector, t.Damage); }
				}

				t.master = master;
				t.pitch = pitch + 90;
			}

			Warp(self, cos(pitch) * StepDistance, 0, -sin(pitch) * StepDistance, flags:WARPF_NOCHECKPOSITION);

			if (
				CurDistance > 0 &&
				(
					(origin && !CheckSight(origin, 0)) ||
					(prev && !CheckSight(prev, 0))
				)
			) { CurDistance = MaxDistance; }

			prev = t;

			CurDistance += StepDistance;
		}
	}

	void ElectrifySector(Sector cur, int damage = -1)
	{
		for (Actor mo = cur.thinglist; mo != null; mo = mo.snext)
		{
			if (mo.waterlevel > 0) { mo.A_DamageSelf(damage > 0 ? damage : Random(0, 2), "Electric"); }
		}
	}

	actor ClosestMonster(void)
	{
		ThinkerIterator Finder = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
		Actor mo, closest;
		while (mo = Actor(Finder.Next()))
		{
			if (mo == self || mo == origin || !mo.bShootable || mo.bDormant || !mo.bIsMonster) { continue; }
			if (!origin.IsVisible(mo, true)) { continue; }
			if (Distance3d(mo) > 256) { continue; }
			if (closest && Distance3d(mo) > Distance3d(closest)) { continue; }

			closest = mo;
		}

		return closest;
	}
}

Class LightningBeamPri : LightningBeam
{
	Default 
	{
		LightningBeam.AngleRandom 4;
		LightningBeam.ChokeMax 3;
		LightningBeam.ChokeMin 2;
		LightningBeam.FaceAmount 5;
		LightningBeam.MaxDistance 512;
		LightningBeam.MaxScale 0.15;
		LightningBeam.MinScale 0.025;
		LightningBeam.PitchRandom 4;
		LightningBeam.StepFactor 2.5;
		LightningBeam.TrailActor "LightningTrailBeam";
	}
}

Class LightningBeamAlt : LightningBeam
{
	Default 
	{
		LightningBeam.AllowSplit 2.5;
		LightningBeam.AngleRandom 20;
		LightningBeam.ChokeMax 4;
		LightningBeam.ChokeMin 2;
		LightningBeam.FaceAmount 10;
		LightningBeam.MaxDistance 256;
		LightningBeam.MaxScale 0.15;
		LightningBeam.MinScale 0.025;
		LightningBeam.PitchRandom 15;
		LightningBeam.StepFactor 2.5;
		LightningBeam.Targets True;
		LightningBeam.TrailActor "LightningTrailBeamAlt";
	}
}

Class LightningBeamArc : LightningBeamPri
{
	Default 
	{
		LightningBeam.MaxDistance 256;
		LightningBeam.TrailActor "LightningTrailBeamArc";
	}
}

Class LightningBeamPillar : LightningBeam
{
	Default 
	{
		LightningBeam.AllowSplit 0.5;
		LightningBeam.AngleRandom 15;
		LightningBeam.ChokeMax 5;
		LightningBeam.ChokeMin 5;
		LightningBeam.FaceAmount 0;
		LightningBeam.MaxDistance 256;
		LightningBeam.MaxScale 0.10;
		LightningBeam.MinScale 0.025;
		LightningBeam.PitchRandom 15;
		LightningBeam.StepFactor 1.5;
		LightningBeam.TrailActor "LightningTrailBeamArc";
	}
}

// Base class for the beam segments
Class MovingTrailBeam : Actor 
{
	String puff;
	String trail;
	Vector3 beamoffset;
	int damage;

	Property Damage:damage;
	Property PuffActor:puff;
	Property TrailActor:trail;

	Default
	{
		Height 1;
		Radius 0;
		+NOINTERACTION
		RenderStyle "Add";
		MovingTrailBeam.Damage 0;
		MovingTrailBeam.TrailActor "MovingTrailBeam";
		MovingTrailBeam.PuffActor "LightningPuff";
	}

	States
	{
		Spawn:
			MDLA A 0;
			MDLA A 1 LIGHT("Lightning") A_FadeOut(0.2);
			Loop;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		if (master && (!(master is "PlayerPawn") || Distance3D(master) > 64))
		{
			// Used to make all individual bolt segments leave decals and cause damage
			A_CustomBulletAttack(0, 0, 1, damage, "LightningPuff", 24, CBAF_AIMFACING);
		}

		if (master) { beamoffset = pos - master.pos; }
	}

	override void Tick()
	{
		Super.Tick();

		if (globalfreeze || level.Frozen) { return; }

		if (master && master is "PlayerPawn")
		{ 
			SetOrigin(master.pos + beamoffset, true);
		}
	}

}

Class LightningTrailBeam : MovingTrailBeam
{
	Default
	{
		MovingTrailBeam.Damage 2;
		MovingTrailBeam.TrailActor "LightningTrailBeam";
	}
}

Class LightningTrailBeamAlt : MovingTrailBeam
{
	Default
	{
		MovingTrailBeam.Damage 2;
		MovingTrailBeam.TrailActor "LightningTrailBeamAlt";
	}
}

Class LightningTrailBeamArc : MovingTrailBeam
{
	Default
	{
		MovingTrailBeam.Damage 50;
		MovingTrailBeam.TrailActor "LightningTrailBeamArc";
	}
}

Class TargetActor : Actor
{
	Vector3 offset;

	Default
	{
		Height 0;
		Radius 0;
		+NOINTERACTION;
	}

	States
	{
		Spawn:
			TNT1 A 1;
			Stop;
	}

	override void PostBeginPlay()
	{
		if (master) { offset = pos - master.pos; }

		return Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (master)
		{
			Warp(master, offset.x, offset.y, offset.z, flags:WARPF_ABSOLUTEOFFSET);
		}

		Super.Tick();
	}
}