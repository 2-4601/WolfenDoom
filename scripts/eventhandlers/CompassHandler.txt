class CompassHandler : EventHandler
{
	Array<Actor> ScannableThings;
	const compassX = 85.0;
	const compassY = 162.0;
	const pointRadius = 34.0;
	const circleRadius = 41.0;
	const circleCenterX = 13.0 + circleRadius;
	const circleCenterY = 28.0 + circleRadius;
	const minTID = 4000;
	const distFactor = 0.1;

	clearscope bool compassItem(Actor thing) const
	{
		return (
			thing is "ObjectiveIcon" ||
			thing is "Akten" ||
			thing is "AktenEisenmann" ||
			thing is "SpearOfDestiny" ||
			thing is "ExclamationCompass" ||
			thing.tid >= minTID
		);
	}
	
	clearscope TextureID compassIcon(Actor thing) const
	{
		if (thing is "ObjectiveIcon")
		{
			return TexMan.CheckForTexture("GOAL3", TexMan.Type_Any);
		}
		else if (compassItem(thing))
		{
			return TexMan.CheckForTexture("GOAL1", TexMan.Type_Any);
		}
		else
		{
			return TexMan.CheckForTexture("GOAL2", TexMan.Type_Any);
		}
	}
	
	override void WorldThingSpawned(WorldEvent e)
	{
		if (
			!e.Thing ||
			e.Thing.health <= 0 ||
			!compassItem(e.Thing) ||
			ScannableThings.Find(e.Thing) < ScannableThings.Size()
		) { return; }

		ScannableThings.push(e.Thing);
	}

	override void WorldThingDestroyed(WorldEvent e)
	{
		int i = ScannableThings.Find(e.Thing);

		if (i < ScannableThings.Size())
		{
			ScannableThings.Delete(i, 1);
			ScannableThings.ShrinkToFit();
		}
	}

	override void RenderOverlay( RenderEvent e )
	{
		PlayerInfo p = players[consoleplayer];

		if (!p || !p.mo) { return; }

		BoACompass cmps = BoACompass(p.mo.FindInventory("BoACompass"));

		if (cmps && cmps.active)
		{
			// Draw compass and points
			TextureID north = TexMan.CheckForTexture("NORTH", TexMan.Type_Any);
			TextureID east = TexMan.CheckForTexture("EAST", TexMan.Type_Any);
			TextureID south = TexMan.CheckForTexture("SOUTH", TexMan.Type_Any);
			TextureID west = TexMan.CheckForTexture("WEST", TexMan.Type_Any);
			TextureID cmpsbg = TexMan.CheckForTexture("COMPASS", TexMan.Type_Any);

			screen.DrawTexture(west, false,
				-sin(p.mo.angle) * pointRadius + compassX + circleCenterX,
				cos(p.mo.angle) * pointRadius + compassY + circleCenterY,
				DTA_VirtualWidth, 1024, DTA_VirtualHeight, 768);
			screen.DrawTexture(east, false,
				sin(p.mo.angle) * pointRadius + compassX + circleCenterX,
				-cos(p.mo.angle) * pointRadius + compassY + circleCenterY,
				DTA_VirtualWidth, 1024, DTA_VirtualHeight, 768);
			screen.DrawTexture(south, false,
				cos(p.mo.angle) * pointRadius + compassX + circleCenterX,
				sin(p.mo.angle) * pointRadius + compassY + circleCenterY,
				DTA_VirtualWidth, 1024, DTA_VirtualHeight, 768);
			screen.DrawTexture(north, false,
				-cos(p.mo.angle) * pointRadius + compassX + circleCenterX,
				-sin(p.mo.angle) * pointRadius + compassY + circleCenterY,
				DTA_VirtualWidth, 1024, DTA_VirtualHeight, 768);
			screen.DrawTexture(cmpsbg, false, compassX, compassY,
				DTA_VirtualWidth, 1024, DTA_VirtualHeight, 768);

			// Draw icons
			for (int i = 0; i < ScannableThings.Size(); i++)
			{
				Actor mo = ScannableThings[i];
				if (!mo) continue;
				if (mo is "Inventory" && Inventory(mo).Owner) continue;

				TextureID icon = compassIcon(mo);
				Vector2 relativeLocation = LevelLocals.Vec2Diff(p.mo.pos.xy, mo.pos.xy);
				relativeLocation.Y *= -1;

				relativeLocation = Actor.RotateVector(relativeLocation, p.mo.angle - 90);
				//Console.Printf("Relative location of %s: %.3f %.3f", mo.GetClassName(), relativeLocation);
				
				if (relativeLocation.Length() * distFactor > pointRadius)
				{
					relativeLocation = relativeLocation.Unit() * pointRadius / distFactor;
				}
				
				double iconX = compassX + circleCenterX + relativeLocation.X * distFactor;
				double iconY = compassY + circleCenterY + relativeLocation.Y * distFactor;
				screen.DrawTexture(icon, false, iconX, iconY,
					DTA_VirtualWidth, 1024, DTA_VirtualHeight, 768);
			}
		}
	}
}