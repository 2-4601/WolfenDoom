class BoAMenu : GenericMenu
{
	static void SetMenu(Actor caller, Name mnu, int param = 0)
	{
		if (players[consoleplayer].mo != caller) { return; }

		Menu.SetMenu(mnu, param);
	}
}

class CombinationSafe : BoAMenu
{
	TextureID spinner, spinnerfront, spinnerback, background, turn;
	Vector2 location, size, bgsize, screendimensions;
	double scale, bgscale;
	int angle, destangle, dir, olddir, set, count;
	int keyactive;
	int combo[3], solution[3];
	int speed, steps;
	Safe s;
	int initial;
	int ticcount;

	override void Init(Menu parent)
	{
		Super.Init(parent);

		spinner = TexMan.CheckForTexture("DIAL", TexMan.Type_Any);
		spinnerfront = TexMan.CheckForTexture("DIAL_F", TexMan.Type_Any);
		spinnerback = TexMan.CheckForTexture("DIAL_B", TexMan.Type_Any);
		background = TexMan.CheckForTexture("SAFEBKG", TexMan.Type_Any);
		turn = TexMan.CheckForTexture("DIAL_DIR", TexMan.Type_Any);

		location = (427, 240);
		[location, screendimensions] = Screen.VirtualToRealCoords(location, (screen.GetWidth(), screen.GetHeight()), (640, 480));

		size = TexMan.GetScaledSize(spinner);
		bgsize = TexMan.GetScaledSize(background);
		scale = 0.4 * screen.GetHeight() / size.y;
		bgscale = scale * 1.75;

		s = Safe(players[consoleplayer].ConversationNPC);

		steps = 24;
		speed = (360 / steps) / 6;

		if (s && !s.special)
		{
			solution[0] = s.args[1];
			solution[1] = s.args[2];
			solution[2] = s.args[3];
		}

		// If no combination set, use the object's coordinates to derive a combination
		if (solution[0] == 0 && solution[1] == 0 && solution[2] == 0)
		{
			// Default to setting a pseudo-random combo...  If you flag the actor wth STANDSTILL, it will stay unlocked
			if (s && !s.bStandStill)
			{
				solution[0] = int(abs(s.pos.x % steps));
				solution[1] = int(abs(s.pos.y % steps));
				solution[2] = int(abs(s.pos.z % steps));
			}
		}

		if (developer) { console.printf("%i %i %i", solution[0], solution[1], solution[2]); }

		DontDim = true;
		menuactive = OnNoPause;

		destangle = 360 * 3;
		initial = 1;
	}

	override void Drawer()
	{
		if (solution[0] != 0 || solution[1] != 0 || solution[2] != 0)
		{
			screen.Dim(0x000000, 0.2, 0, 0, screen.GetWidth(), screen.GetHeight());

			if (background)
			{
				screen.DrawTexture(background, false, location.x - bgsize.x * bgscale / 9.2, location.y, DTA_DestWidth, int(bgsize.x * bgscale), DTA_DestHeight, int(bgsize.y * bgscale), DTA_CenterOffset, true);
			}

			if (spinnerback)
			{
				screen.DrawTexture(spinnerback, false, location.x, location.y, DTA_DestWidth, int(size.x * scale), DTA_DestHeight, int(size.y * scale), DTA_CenterOffset, true);
			}

			if (spinner)
			{
				let shape = ShapeUtil.MakeSquare();
				ShapeUtil.MoveSquare(shape, size * scale, location, 360 - angle);
				Screen.DrawShape(spinner, false, shape);
			}

			if (spinnerfront)
			{
				screen.DrawTexture(spinnerfront, false, location.x, location.y, DTA_DestWidth, int(size.x * scale), DTA_DestHeight, int(size.y * scale), DTA_CenterOffset, true);
			}

			if (ticcount > 0)
			{
				if (ticcount > 35)
				{
					double alpha = 0.5 * (0.5 + sin(((ticcount - 35) * 720 / 70 - 90) / 2));

					if (ticcount < 105 || ticcount > 175)
					{
						screen.DrawTexture(turn, false, location.x, location.y, DTA_DestWidth, int(size.x * scale), DTA_DestHeight, int(size.y * scale), DTA_CenterOffset, true, DTA_Alpha, alpha);
					}
					else if (ticcount < 245)
					{
						screen.DrawTexture(turn, false, location.x, location.y, DTA_DestWidth, int(size.x * scale), DTA_DestHeight, int(size.y * scale), DTA_CenterOffset, true, DTA_FlipX, true, DTA_Alpha, alpha);
					}
				}
			}
		}
	}

	override void Ticker()
	{
		if (solution[0] == 0 && solution[1] == 0 && solution[2] == 0)
		{
			TryOpen();
			Close();

			return;
		}

		if (initial)
		{
			ticcount++;

			if (ticcount >= 245)
			{
				ticcount = 0;
				initial++;

				if (initial > 2) { initial = 0; }
			}
		}

		if (keyactive > 0)
		{
			keyactive--;
			ticcount = 0;
			initial = 0;
		}

		if (keyactive)
		{
			S_StartSound("safe/dial", CHAN_7, CHANF_UI | CHANF_NOSTOP, 0.5);

			if (destangle > angle)
			{
				angle += speed * 2;
				dir = 1;

				if (angle > 360)
				{
					angle -= 360;
					count = max(0, count -1);
				}
			}
			else if (destangle < angle)
			{
				angle -= speed * 2;
				dir = -1;

				if (angle < 0)
				{
					angle += 360;
				}
			}
		}
		else
		{
			destangle = angle - (angle % speed);
			angle = destangle;
		}
// if (set < 3) { console.printf("%i >>> %i", (angle / (360 / steps)) % steps, solution[set]); }
		if (olddir && olddir != dir && set < 3)
		{
			combo[set] = (angle / (360 / steps)) % steps;

			set++;
			count++;
		}

		olddir = dir;

		if (set > 0 && count <= 0)
		{
			DoReset();
		}

		Super.Ticker();
	}

	override bool MenuEvent(int mkey, bool fromcontroller)
	{
		switch (mkey)
		{
			case MKEY_Up:
			case MKEY_Down:
			case MKEY_Back:
				Close();
				return true;
			case MKEY_Enter:
				// Attempt Open
				if (set == 2)
				{
					combo[2] = angle / (360 / steps);
					TryOpen();
				}

				if (set > 2)
				{
					TryOpen();
				}

				return true;
			case MKEY_Right:
				// Turn Right
				keyactive = 5;
				destangle = angle - speed * 4;

				return true;
			case MKEY_Left:
				// Turn Left
				keyactive = 5;
				destangle = angle + speed * 4;

				return true;
			default:
				return false;
		}
	}

	override bool MouseEvent(int type, int x, int y)
	{
		return false;
	}

	override bool OnUIEvent(UIEvent ev)
	{
		// Intercept key presses to see if we're pressing the strafe controls or use, 
		// and redirect those to call the correct left/right/open movement menu event code.

		if (ev.Type == UIEvent.Type_KeyDown || ev.Type == UIEVent.Type_Char)
		{
			CheckControl(ev, "+moveleft", MKEY_Left);
			CheckControl(ev, "+moveright", MKEY_Right);
			CheckControl(ev, "+use", MKEY_Enter);
			CheckControl(ev, "+forward", MKEY_Up);
			CheckControl(ev, "+back", MKEY_Down);
		}

		return false;
	}
/*
// Input events apparently don't handle repeating when you hold down a key...  Makes this approach painful to use.
//  Requires "menuactive = Menu.WaitKey;" in Ticker()
	override bool OnInputEvent(InputEvent ev)
	{
		if (InputEvent.Type_KeyDown)
		{
			Switch (ev.keyscan)
			{
				case 0:
					break;
				case InputEvent.KEY_ESCAPE:
					menuactive = Menu.On;
					Close();
					MenuEvent(Menu.MKEY_Abort, false);
					return true;
					break;
				default:
					if (
						CheckControl(ev, "+moveleft") ||
						ev.keyscan == InputEvent.KEY_LeftArrow
					) { MenuEvent(MKEY_Left, false); }
					else if (
						CheckControl(ev, "+moveright") ||
						ev.keyscan == InputEvent.KEY_RightArrow
					) { MenuEvent(MKEY_Right, false); }
					else if (
						CheckControl(ev, "+use") ||
						ev.keyscan == InputEvent.KEY_Enter
					) { MenuEvent(MKEY_Enter, false); }
					else if (
						CheckControl(ev, "+forward") ||
						CheckControl(ev, "+back")
					) { MenuEvent(MKEY_Back, false); }
					return true;
					break;
			}
		}

		return false;
	}


	bool CheckControl(InputEvent ev, String control)
	{
		int c1, c2;
		[c1, c2] = Bindings.GetKeysForCommand(control);

		if (ev.keyscan == c1 || ev.keyscan == c2) { return true; }

		return false;
	}
*/
	void CheckControl(UIEvent ev, String control, int type)
	{
		int c1, c2;
		[c1, c2] = Bindings.GetKeysForCommand(control);

		Array<String> keys;
		Bindings.NameKeys(c1, c2).Split(keys, ", ");

		String keychar = String.Format("%c", ev.KeyChar);
		keychar = keychar.MakeUpper();

		for (int i = 0; i < keys.Size(); i++)
		{
			if (keys[i].Length() > 1) { continue; } // Skip named keys (Alt, Shift, Ctrl, etc.)

			if (keys[i].ByteAt(0) == keychar.ByteAt(0))
			{
				MenuEvent(type, false);
			}
		}
	}

	void TryOpen()
	{
		int match = true;

		for (int i = 0; i < 3; i++)
		{
			// Allow a step to either side of the correct number to be accepted
			if (combo[i] >= solution[i] - 1 && combo[i] <= solution[i] + 1) { continue; }
			if (solution[i] == 0 && combo[i] >= steps - 1) { continue; }

			match = false;
		}

		if (match)
		{
			S_StartSound("safe/open", CHAN_7, CHANF_UI | CHANF_NOSTOP, 0.5);
			EventHandler.SendNetworkEvent("opensafe", int(s.pos.x), int(s.pos.y), int(s.pos.z));

			Close();
		}
		else
		{
			S_StartSound("safe/locked", CHAN_7, CHANF_UI | CHANF_NOSTOP, 0.5);
		}
	}

	void DoReset()
	{
		for (int i = 0; i < 3; i++) { combo[i] = 0; }
		count = 0;
		set = 0;
	}
}