class BoAInfo : GenericMenu
{
	int mScreen;
	int mInfoTic;
	int dir, w, h;
	font titlefnt, fnt, fallbackfnt;
	ParsedValue data;
	int maxpages;

	override void Init(Menu parent)
	{
		Super.Init(parent);
		mScreen = 1;
		dir = 0;
		mInfoTic = gametic;

		w = 800;
		h = 600;

		fnt = Font.GetFont("SmallFont");
		titlefnt = Font.GetFont("BigFont");
		fallbackfnt = NewSmallFont;

		data = FileReader.Parse("data/InfoScreen.txt");

		if (!data) { return; }

		data.Init();
		while (data.Next("page")) { maxpages++; }
	}

	override void Drawer()
	{
		double alpha;
		TextureID tex, prevpic, labels;
		
		if (!data) { return; }
		
		if (!tex.IsValid())
		{
			ParsedValue page = data.Find("page", mScreen);
			tex = TexMan.CheckForTexture(FileReader.GetString(page, "attributes.background"), TexMan.Type_Any);
		}

		if (mScreen > 0 && mScreen <= maxpages)
		{
			ParsedValue prevpage = data.Find("page", mScreen - dir);
			prevpic = TexMan.CheckForTexture(FileReader.GetString(prevpage, "attributes.background"), TexMan.Type_Any);
		}

		screen.Dim(0, 1.0, 0,0, screen.GetWidth(), screen.GetHeight());
		alpha = MIN((gametic - mInfoTic) * (3. / Thinker.TICRATE), 1.);
		if (alpha < 1. && prevpic.IsValid())
		{
			screen.DrawTexture (prevpic, false, 0, 0, DTA_FullscreenEx, 3);
			DrawBlocks(data, mScreen - dir, 1.0);
		}
		else alpha = 1;
		screen.DrawTexture (tex, false, 0, 0, DTA_FullscreenEx, 3, DTA_Alpha, alpha);

		DrawBlocks(data, mScreen, alpha);

		labels = TexMan.CheckForTexture("graphics/finale/finale_labels.png", TexMan.Type_Any);

		if (labels)
		{
			screen.DrawTexture(labels, false, 0, 0, DTA_FullScreenEx, 3);
			screen.DrawText(SmallFont, Font.CR_GRAY, 213, 183, "pg " .. mScreen .. " of " .. maxpages, DTA_320x200, true);
		}
	}

	override bool MenuEvent(int mkey, bool fromcontroller)
	{
		if (mkey == MKEY_Back)
		{
			Close();	
			return true;
		}
		else if (mkey == MKEY_Right || mkey == MKEY_Down || mkey == MKEY_Enter)
		{
			if (mScreen + 1 <= maxpages)
			{
				mScreen++;
				dir = 1;
				mInfoTic = gametic;
				return true;
			}
		}
		else if (mkey == MKEY_Left || mkey == MKEY_Up)
		{
			if (mScreen - 1 > 0)
			{
				mScreen--;
				dir = -1;
				mInfoTic = gametic;
				return true;
			}
		}

		return false;
	}

	override bool MouseEvent(int type, int x, int y)
	{
		if (type == MOUSE_Click)
		{
			MenuEvent(MKEY_Enter, false);
		}

		return false;
	}

	override bool OnUIEvent(UIEvent ev)
	{
		// Intercept key presses to see if we're pressing the strafe controls or use, 
		// and redirect those to call the correct left/right/open movement menu event code.

		if (ev.Type == UIEvent.Type_KeyDown || ev.Type == UIEVent.Type_Char)
		{
			CheckControl(ev, "+moveleft", MKEY_Left);
			CheckControl(ev, "+moveright", MKEY_Right);
			CheckControl(ev, "+use", MKEY_Enter);
			CheckControl(ev, "+forward", MKEY_Up);
			CheckControl(ev, "+back", MKEY_Down);
		}

		return Super.OnUIEvent(ev);
	}

	void CheckControl(UIEvent ev, String control, int type)
	{
		int c1, c2;
		[c1, c2] = Bindings.GetKeysForCommand(control);

		Array<String> keys;
		Bindings.NameKeys(c1, c2).Split(keys, ", ");

		String keychar = String.Format("%c", ev.KeyChar);
		keychar = keychar.MakeUpper();

		for (int i = 0; i < keys.Size(); i++)
		{
			if (keys[i].ByteAt(0) == keychar.ByteAt(0))
			{
				MenuEvent(type, false);
			}
		}
	}

	void DrawBlocks(ParsedValue data, int pagenum, double alpha)
	{
		if (data)
		{
			data.Init(); // Reset to the top of the file

			ParsedValue page = data.Find("page", pagenum);

			if (page)
			{
				page.Init();

				ParsedValue block = page.Find("block");

				while (block)
				{
					DrawBlock(block, alpha);

					block = page.Next("block");
				}
			}
		}
	}

	void DrawBlock(ParsedValue block, double alpha)
	{
		int x = FileReader.GetInt(block, "attributes.x");
		int y = FileReader.GetInt(block, "attributes.y");
		int bw = FileReader.GetInt(block, "attributes.width");
		int bh = FileReader.GetInt(block, "attributes.height");
		int margin = FileReader.GetInt(block, "attributes.margin");

		Vector2 pos, size, marginsize;
		[pos, marginsize] = Screen.VirtualToRealCoords((x, y), (margin, margin), (w, h));
		[pos, size] = Screen.VirtualToRealCoords((x, y), (bw, bh), (w, h));
		Screen.Dim(0x333333, alpha, int(pos.x), int(pos.y), int(size.x), int(size.y));

		ParsedValue content = block.Find("content");

		double scrollspeed = FileReader.GetDouble(block, "attributes.scrollspeed");
		double yoffset = margin - (gametic - mInfoTic) * scrollspeed;

		while (content)
		{
			Font fnt = Font.FindFont(FileReader.GetString(content, "font"));
			if (!fnt) { fnt = SmallFont; }

			String text = StringTable.Localize(FileReader.GetString(content, "text"));
			TextureID pic = TexMan.CheckForTexture(Filereader.GetString(content, "pic"), TexMan.Type_Any);

			int clr = Font.CR_GRAY;
			String fontcolor = FileReader.GetString(content, "fontcolor");
			if (fontcolor.length()) { clr = Font.FindFontColor(fontcolor); }

			String align = FileReader.GetString(content, "align");

			double textscale = FileReader.GetDouble(content, "textscale");
			if (textscale == 0) { textscale = 1.0; }
			BrokenLines lines = fnt.BreakLines(text, int((bw - margin * 2) / textscale));

			if (pic.IsValid())
			{
				double scale = FileReader.GetDouble(content, "picscale");
				if (scale == 0) { scale = 1.0; }

				Vector2 picsize = TexMan.GetScaledSize(pic);

				if (yoffset + int(picsize.y * scale) + margin / 2 > 0)
				{
					int xoffset = int((bw / scale) / 2 - picsize.x / 2);
					if (align ~== "right") { xoffset = int((bw - margin) / scale - picsize.x); }
					else if (align ~== "left") { xoffset = int(margin / scale); }

					screen.DrawTexture (pic, true, x / scale + xoffset, y / scale + yoffset / scale, DTA_VirtualWidth, int(w / scale), DTA_VirtualHeight, int(h / scale), DTA_TopOffset, 0, DTA_LeftOffset, 0, DTA_Alpha, alpha, DTA_ClipTop, int(pos.y + marginsize.y), DTA_ClipBottom, int(pos.y + size.y - marginsize.y));
				}

				yoffset += int(picsize.y * scale) + margin / 2;

				if (yoffset > bh - margin * 2) { return; }
			}		

			for (int t = 0; t < lines.Count(); t++)
			{
				String line = lines.StringAt(t);

				if (yoffset + int(fnt.GetHeight() * textscale) > 0)
				{
					int xoffset = int(margin / textscale);
					if (align ~== "right") { xoffset = int((bw - margin) / textscale) - fnt.StringWidth(line); }
					else if (align ~== "center") { xoffset = int((bw / textscale) / 2 - fnt.StringWidth(line) / 2); }

					screen.DrawText(fnt, clr, x / textscale + xoffset, y / textscale + yoffset / textscale, line, DTA_VirtualWidth, int(w / textscale), DTA_VirtualHeight, int(h / textscale), DTA_Alpha, alpha, DTA_ClipTop, int(pos.y + marginsize.y), DTA_ClipBottom, int(pos.y + size.y - marginsize.y));
				}
				yoffset += int(fnt.GetHeight() * textscale);

				if (yoffset > bh - margin) { return; }
			}

			content = block.Next("content");

			if (!content && scrollspeed) // Incomplete handling for looped scrolling blocks, but enough for our purposes
			{
				content = block.Find("content");
				yoffset += margin / 2;
			}

			yoffset += margin / 2;
		}
	}
}