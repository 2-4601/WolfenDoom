// Base class that handles drawing informational text under menu entries
class ExtendedListMenu : ListMenu
{
	String lookupBase;
	int itemCount;
	Name overlay;
	String overlaytext;
	Array<int> placeholders;

	override void Init(Menu parent = null, ListMenuDescriptor desc = null)
	{
		Super.Init(parent, desc);

		int index = 0;
		placeholders.Clear();

		for (int i = 0; i < mDesc.mItems.Size(); i++)
		{
			if (mDesc.mItems[i].Selectable()) { index++; }

			if (mDesc.mItems[i] is "ListMenuItemTextItem")
			{
				String temp = ListMenuItemTextItem(mDesc.mItems[i]).mText;
				temp.Replace("[Unreleased]", "");

				// If the replacement string wasn't there, then this one is good
				if (temp == ListMenuItemTextItem(mDesc.mItems[i]).mText) { continue; }

				// Otherwise, fix the text string and recolor it, and add it to the list of known placeholders
				ListMenuItemTextItem(mDesc.mItems[i]).mText = temp;
				ListMenuItemTextItem(mDesc.mItems[i]).mColor = Font.CR_BLACK;
				ListMenuItemTextItem(mDesc.mItems[i]).mColorSelected = Font.CR_BLACK;

				placeholders.Push(index);
			}
		}

		// Allow generic lookups - strip "menu" off of the menu name, and use that stub as the lookup base (e.g., SKILL, EPISODE, etc.)
		String MenuName = ToUpper(mDesc.mMenuName);
		MenuName.Replace("MENU", "");

		lookupBase = MenuName;
	}

	override void Drawer()
	{
		// Draw the text description for the currently selected item
		DrawItemText(mDesc.mSelectedItem, breakWidth:230, scale:0.6);

		Super.Drawer();

		if (overlay)
		{
			TextureID tex = TexMan.CheckForTexture(overlay, TexMan.Type_MiscPatch);
			if (tex.IsValid()) { screen.DrawTexture(tex, false, 160, 100, DTA_Clean, true, DTA_CenterOffset, true, DTA_KeepRatio, true); };

			if (overlaytext.Length())
			{
				double scale = 0.8;
				double fontheight = BigFont.GetHeight() * scale;

				// Default position is centered on the screen (offset slightly toward the bottom so the graphic can have a title and still be centered)
				double x = 158;
				double y = 108;

				BrokenLines message = BigFont.BreakLines(overlaytext, int(240 / scale));

				int c = message.Count();

				for (int i = 0; i < c; i++) { y -= fontheight / 2; }

				for (int i = 0; i < c; i++)
				{
					screen.DrawText (BigFont, 0, x / scale - message.StringWidth(i) / 2, y / scale, message.StringAt(i), DTA_Clean, true, DTA_KeepRatio, true, DTA_VirtualWidthF, 320 / scale, DTA_VirtualHeightF, 200 / scale);
					y += fontheight;
				}
			}
		}
	}

	virtual void DrawItemIcon(int index, double x = -1, double y = -1, double alpha = 1.0)
	{
		return;
	}

	void DrawItemText(int index, double x = -1, double y = -1, double alpha = 1.0, int breakWidth = 300, double scale = 1.0)
	{
		if (index < 0) { return; }

		double fontheight = SmallFont.GetHeight() * scale;

		// Default position is centered, 35 pixels off the bottom of the screen
		if (x < 0) { x = 160; }
		if (y < 0) { y = 165; }

		// Semi-hard-coded, unfortunately - Descriptions must be named [Menu name]DESCRIPTION1, [Menu name]DESCRIPTION2, etc.
		String text = StringTable.Localize("$" .. lookupBase .. "DESCRIPTION"..index);
		if (text == lookupBase .. "DESCRIPTION"..index) { return; }

		BrokenLines message = SmallFont.BreakLines(text, int(breakWidth / scale));

		int c = message.Count();

		for (int i = 0; i < c; i++) { y -= fontheight / 2; }

		for (int i = 0; i < c; i++)
		{
			screen.DrawText (SmallFont, OptionMenuSettings.mFontColor, x / scale - message.StringWidth(i) / 2, y / scale, message.StringAt(i), DTA_Clean, true, DTA_Alpha, alpha, DTA_VirtualWidthF, 320 / scale, DTA_VirtualHeightF, 200 / scale);
			y += fontheight;
		}
	}

	override bool MenuEvent(int mkey, bool fromcontroller)
	{
		if (overlay) { overlay = ""; return false; }

		switch (mkey)
		{
			case MKEY_Back:
				RestorePlaceholderMarkers();
				return Super.MenuEvent(mkey, fromcontroller);
			case MKEY_Enter:
				if (mDesc.mSelectedItem >= 0)
				{
					if (placeholders.Find(mDesc.mSelectedItem) != placeholders.Size())
					{
						overlay = "NOTAVAIL";

						overlaytext = StringTable.Localize("$" .. lookupBase .. mDesc.mSelectedItem .. "MESSAGE");
						if (overlaytext == lookupBase .. mDesc.mSelectedItem .. "MESSAGE") // Message wasn't found
						{
							overlaytext = StringTable.Localize("$DEFAULTMESSAGE");
							if (overlaytext == "DEFAULTMESSAGE") { overlaytext = ""; return false; } // Default wasn't found either
						}

						MenuSound("menu/choose");
						return false;
					}
					else
					{
						if (mDesc.mItems[mDesc.mSelectedItem].Activate()) { MenuSound("menu/choose"); }
					}
				}
 				RestorePlaceholderMarkers();
				return true;
			default:
				return Super.MenuEvent(mkey, fromcontroller);
		}
	}

	void RestorePlaceholderMarkers()
	{
		// Restore the placeholder marker for popup message menus so that they will be treated correctly next time the menu is opened
		if (placeholders.Size())
		{
			for (int p = 0; p < placeholders.Size(); p++)
			{
				String temp = "[Unreleased]";
				temp.AppendFormat("%s", ListMenuItemTextItem(mDesc.mItems[placeholders[p]]).mText);

				ListMenuItemTextItem(mDesc.mItems[placeholders[p]]).mText = temp;
			}
		}
	}

	String ToUpper(String input)
	{
		String output;

		for (int i = 0; i < input.length(); i++)
		{
			int c = input.CharCodeAt(i);

			if (c >= 97 && c <= 122) { c -= 32; }

			output.AppendFormat("%c", c);
		}

		return output;
	}
}

// For an icon beside the menu entry, like Wolf3D episode select
class IconListMenu : ExtendedListMenu
{
	override void Init(Menu parent = null, ListMenuDescriptor desc = null)
	{
		Super.Init(parent, desc);

		Vector2 iconSize;

		for (int i = 0; i < mDesc.mItems.Size(); i++)
		{
			TextureID tex = TexMan.CheckForTexture(lookupBase .. i, TexMan.Type_MiscPatch);

			if (tex.IsValid())
			{
				Vector2 texsize = TexMan.GetScaledSize(tex);

				if (texsize.x > iconSize.x) { iconSize.x = int(texsize.x); }
			}

			if (mDesc.mItems[i].Selectable()) { mDesc.mItems[i].SetX(mDesc.mXpos + iconsize.x / 2); }
		}

		if (mDesc.mXpos + mDesc.mSelectOfsX > mDesc.mXpos - iconSize.x * 1.3) { mDesc.mSelectOfsX -= iconSize.x * 1.3; }
	}

	override void Drawer()
	{
		// Draw the icons
		DrawItemIcon(mDesc.mSelectedItem);

		Super.Drawer();
	}

	override void DrawItemIcon(int index, double x = -1, double y = -1, double alpha = 1.0)
	{
		double fontheight = mDesc.mFont.GetHeight();
		double drawx = x;
		double drawy = y;
		int itemindex = 0;

		for (int i = 0; i < mDesc.mItems.Size(); i++)
		{
			if (mDesc.mItems[i].Selectable())
			{
				itemindex++;

				// Again, semi-hard-coded, unfortunately - Icons must be named [Menu name]1, [Menu name]2, etc.
				TextureID tex = TexMan.CheckForTexture(lookupBase .. itemindex, TexMan.Type_MiscPatch);
				if (tex.IsValid())
				{
					Vector2 texsize = TexMan.GetScaledSize(tex);

					// Default to Wolf3D-style positioning, roughly vertically centered on the episode name
					if (x == -1) { drawx = mDesc.mItems[itemindex].GetX() - texsize.x / 2 - 10; }
					if (y == -1) { drawy = mDesc.mItems[itemindex].GetY() + fontheight / 2; }

					// Use the center of the image for positioning
					drawx -= texsize.x / 2;
					drawy -= texsize.y / 2; 

					screen.DrawTexture(tex, false, drawx, drawy, DTA_Clean, true, DTA_Alpha, itemindex != index ? alpha * 0.6 : alpha);
				}
			}
		}
	}
}

// For an icon that swaps out in place, like the Wolf3D skill menu
class StaticIconListMenu : ExtendedListMenu
{
	double iconOffset;

	override void Init(Menu parent = null, ListMenuDescriptor desc = null)
	{
		// Some logic to determine the rightmost pixel point of the middle skill values
		//  Used for default positioning a la Wolf3D
		double maxWidth;
		int min;

		mDesc = desc;

		// Find the middle skill menu entry (with rounding if odd number of entries)
		double median = (mDesc.mItems.Size() - 1) / 2;
		if (median < int(median) + 0.5) { min = int(median); }
		else { min = int(median) + 1; } 

		// Figure out the widest skill name...
		for (int i = min; i < min + 2; i++)
		{
			int width = mDesc.mItems[i].GetWidth();
			if (width > maxWidth) { maxWidth = width; }
		}

		// ... And use it's length to calculate the default x offset
		iconOffset = mDesc.mXPos + maxWidth;

		Super.Init(parent, desc);
	}


	override void Drawer()
	{
		// Draw the icon for the currently selected item
		DrawItemIcon(mDesc.mSelectedItem);

		Super.Drawer();
	}

	override void DrawItemIcon(int index, double x = -1, double y = -1, double alpha = 1.0)
	{
		if (index < 0) { return; }

		double fontheight = mDesc.mFont.GetHeight();

		// Again, semi-hard-coded, unfortunately - Icons must be named [Menu name]1, [Menu name]2, etc.
		TextureID tex = TexMan.CheckForTexture(lookupBase .. index, TexMan.Type_MiscPatch);
		if (tex.IsValid())
		{
			Vector2 texsize = TexMan.GetScaledSize(tex);

			// Default to Wolf3D-style positioning, roughly vertically centered on the skill list, 
			//  horizontally centered between the screen edge and the longest of the middle skill names.
			if (x == -1) { x = (320 + iconOffset) / 2; }
			if (y == -1) { y = mDesc.mYpos + ((mDesc.mItems.Size() - 1) * mDesc.mLinespacing) / 2; }

			// Use the center of the image for positioning
			x -= texsize.x / 2;
			y -= texsize.y / 2; 

			screen.DrawTexture(tex, false, x, y, DTA_Clean, true, DTA_Alpha, alpha);
		}
	}
}