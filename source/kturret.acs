#library "kturret"
#include "zcommon.acs"

#define turret_maxturn 0.25
#define turret_maxpitch 0.15
//instead of using constants for the above, they could be passed to the script as arguments in the turret stand's decorate (args[0],args[1] for example) if you want to set the angle restriction in GZDoom Builder or in Decorate instead.

script "GunLoop" (void)
{		
	int turret_tid = ActivatorTID(); // turret stand needs to have a TID!
	int stand_angle = GetActorAngle(0); // the angle of the turret stand as it appears in doom builder

	int lc = stand_angle + turret_maxturn;
	int rc = stand_angle - turret_maxturn;

	SetPointer(AAPTR_MASTER, 0, AAPTR_TARGET); // Activation sets player as target. This copies the player to the Master pointer.
	SetPointer(AAPTR_TARGET, 0, AAPTR_NULL); // clears the Target pointer
	SetActivator(0, AAPTR_MASTER); // sets activator to player
	
	int playerangle = GetActorAngle(0);
	int playerpitch = GetActorPitch(0);

	if (!angle_within(rc, playerangle, lc)) // Can't use the turret unless behind it
	{
		SetActivator(turret_tid);
		SetPointer(AAPTR_MASTER, 0, AAPTR_NULL); //turret forgets you
		terminate;
	}

	str lastWeapon = GetWeapon(); //logs the weapon you had equipped while activating the turret
	GiveInventory("KHolster", 1);
	SetWeapon("KHolster");	//the above lowers your weapon and equips a dummy weapon
	
	while (true)
	{
		playerangle = GetActorAngle(0);
		playerpitch = GetactorPitch(0);
		int playerinput = GetPlayerInput(-1, INPUT_BUTTONS);
		int playeroldinput = GetPlayerInput(-1, INPUT_OLDBUTTONS);

		SetActivator(turret_tid, AAPTR_TRACER); // sets the turret's Gun actor as the activator
		SetPointer(AAPTR_TARGET, turret_tid, AAPTR_MASTER); // sets the player as the Gun's target - so projectiles fire from it are owned by the player!
		
		if (playerpitch >= -turret_maxpitch && playerpitch <= turret_maxpitch) // clamp turret pitch
			ChangeActorPitch(0, playerpitch, true);
		
		if (angle_within(rc, playerangle,lc)) // clamp turret angle
			ChangeActorAngle(0, playerangle);
	
		if (playerinput & bt_attack)
		{
			if (CheckInventory("KTurret_Ammo"))
			{
				GiveInventory("KTurret_Token", 1); // fires the gun by giving a missile-firing custom inventory item to the turret's Gun
				TakeInventory("KTurret_Ammo", 1);  // these regenerate in the Gun actor's decorate loop
			}
		}
		
		if ((playerinput & BT_FORWARD && playeroldinput & BT_FORWARD) ||
			(playerinput & BT_BACK && playeroldinput & BT_BACK) ||
			(playerinput & BT_MOVELEFT && playeroldinput & BT_MOVELEFT) ||
			(playerinput & BT_MOVERIGHT && playeroldinput & BT_MOVERIGHT) ||
			(playerinput & BT_jump && !(playeroldinput & BT_jump)))
		{
			// disengages from the turret if the player moves
			SetActivator(0,AAPTR_TARGET);
			SetWeapon(lastweapon);
			TakeInventory("KHolster",1);
			SetActivator(turret_tid);
			SetPointer(AAPTR_MASTER, 0, AAPTR_NULL);
			Terminate;
		}
		SetActivator(turret_tid);
		SetActivator(0, AAPTR_MASTER); // the player again
		Delay(1);
	}
}

/////////////
//FUNCTIONS//
/////////////
function int between (int low, int val,int high)
{
int ret = 0;
if(val > low && val < high) {ret = 1;}
return ret;
}

function int fixangle (int angle)
{
//thank you /vr/. Can't explain what happens here though. - It seems that it corrects the UDMF flag used for actor pitches (ozy)
angle -= (angle / 1.0) * 1.0; 
if (angle < 0) { angle += 1.0; }
return angle;
}	

function int angle_within (int low, int angle, int high)
{//oh god what am i doing send help - it works, but it's probably inefficient as all hell

/*
for the arguments, use this:
Low: [angle to clamp to] - [offset]
angle: the input angle
high [angle to clamp to] + [offset]

example:

	if(angle_within(0.0-0.5,getactorangle(0),0.0+0.5)) { stuff;}

the above will return true if the player is facing the eastern semicircle between North and South.
*/

int ret = 0;
int limit_high = fixangle(high);
int limit_low = fixangle(low);

if (high > 1.0  )
	{
	if (between(0.0,angle,limit_high) || between(limit_low,angle,1.0 ))
		{	
		ret = 1;
		}
	}
	
else if (low < 0.0  )
	{
	if (between(limit_low,angle,1.0) || between(0.0,angle,limit_high ))
		{	
		ret = 1;
		}
	}

else if(limit_high > limit_low)
	{
	if (between(limit_low,angle,limit_high))
		{	
		ret = 1;
		}
	}
else 
	{
	if (between(limit_low,angle,1.0))
		{	
		ret = 1;
		}
	}
return ret;
}